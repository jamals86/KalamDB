# Plan: Dart/Flutter SDK via flutter_rust_bridge

Create a Dart/Flutter SDK for KalamDB by adding a **new Rust bridge crate** (`kalam-link-dart`) that wraps the existing `kalam-link` library with flutter_rust_bridge (FRB) v2 annotations, and a **Flutter package** (`link/sdks/dart/`) exposing an idiomatic Dart API.  
Scope: **queries, auth, subscriptions, health/login/setup** — no consumer/topic APIs.

```
Flutter App
  └─ Dart SDK (link/sdks/dart/)         ← hand-written idiomatic API
      └─ Generated FRB bindings          ← auto-generated by flutter_rust_bridge_codegen
          └─ kalam-link-dart (Rust)      ← NEW bridge crate, FRB-annotated wrappers
              └─ kalam-link (existing)   ← unchanged
```

---

### Phase 1: Rust Bridge Crate (`link/kalam-link-dart/`)

**Step 1.1** — Create crate scaffold
- New workspace member at `link/kalam-link-dart/` with `crate-type = ["cdylib", "staticlib"]`
- Add to root `Cargo.toml` workspace members; add `flutter_rust_bridge = "2"` to workspace deps

**Step 1.2** — FRB-annotated wrapper types in `src/api.rs`
- `DartAuthProvider` enum → mirrors `AuthProvider` (Basic, JWT, None)
- `DartKalamClient` struct wrapping `KalamLinkClient` → exposes: `execute_query()`, `login()`, `refresh_token()`, `health_check()`, `check_setup_status()`, `server_setup()`
- All async methods return FRB-friendly model structs (`DartQueryResponse`, `DartLoginResponse`, etc.)
- Conversion via `From<kalam_link::X>` for each `DartX` type

**Step 1.3** — Subscription bridge in `src/subscription.rs`
- Use FRB's `StreamSink<DartChangeEvent>` to push events as a **Dart Stream** — idiomatic for Flutter
- `subscribe_stream(sink, client, sql)` spawns a tokio task that loops `SubscriptionManager::next()` and pushes into the sink
- `DartChangeEvent` enum mirrors `ChangeEvent` variants (InitialDataBatch, Insert, Update, Delete, Error)

**Step 1.4** — Handle FFI-unfriendly patterns

| Pattern | Solution |
|---------|----------|
| `UploadProgressCallback` (`Arc<dyn Fn>`) | Out of scope (no file upload in MVP) |
| `SubscriptionManager::next()` async iterator | StreamSink push model (Step 1.3) |
| `Duration` fields | `u64` milliseconds |
| `Option<Vec<serde_json::Value>>` params | `Option<String>` JSON, parsed in Rust |

**Step 1.5** — FRB config file `flutter_rust_bridge.yaml`
- `rust_input: src/api.rs`
- `dart_output: ../../sdks/dart/lib/src/generated/`
- `web: true` for WASM support

---

### Phase 2: Flutter Package (`link/sdks/dart/`)

**Step 2.1** — Create Flutter package
- `pubspec.yaml` with `flutter_rust_bridge: ^2.0.0`, rust crate path pointing to `../../kalam-link-dart`

**Step 2.2** — Run codegen: `flutter_rust_bridge_codegen generate` → outputs to `lib/src/generated/`

**Step 2.3** — High-level Dart API (hand-written wrappers):
- `lib/src/kalam_client.dart` — `KalamClient` class with `connect()`, `query()`, `subscribe()` returning a `Stream<ChangeEvent>`, `login()`, `healthCheck()`, `dispose()`
- `lib/src/auth.dart` — `Auth` sealed class (`.basic()`, `.jwt()`, `.none()`)
- `lib/src/models.dart` — re-export generated types
- `lib/kalam_link.dart` — barrel export

---

### Phase 3: Web/WASM Support

**Step 3.1** — Feature flags in `kalam-link-dart/Cargo.toml`:
- `default = ["native"]`
- `native = ["kalam-link/tokio-runtime"]` → tokio + reqwest + tungstenite
- `web = ["kalam-link/wasm"]` → wasm-bindgen + browser fetch + browser WebSocket

FRB v2 handles selecting the right feature based on compile target.

**Step 3.2** — Platform matrix: iOS (staticlib), Android (cdylib via cargo-ndk), macOS/Windows/Linux (cdylib), Web (WASM via FRB)

---

### Phase 4: Testing & Documentation

**Step 4.1** — Unit tests: `test/kalam_client_test.dart` (mock-based, verify type conversions)
**Step 4.2** — Integration tests: `test/integration/` (requires running KalamDB, mirrors Rust e2e tests)
**Step 4.3** — Example app: `example/` — connect, auth, query, subscribe to live changes
**Step 4.4** — README.md with quickstart

---

### Relevant Files

**Existing (reference, unchanged):**
- `link/src/lib.rs` — public API, feature gates
- `link/src/client.rs` — `KalamLinkClient` + builder
- `link/src/auth.rs` — `AuthProvider` enum
- `link/src/subscription.rs` — `SubscriptionManager::next()` pattern
- `link/src/query.rs` — `QueryExecutor`
- `link/src/models/mod.rs` — all data models
- `link/Cargo.toml` — features: `tokio-runtime`, `wasm`
- `Cargo.toml` — workspace members (to modify)

**New files to create:**
- `link/kalam-link-dart/Cargo.toml`, `src/lib.rs`, `src/api.rs`, `src/models.rs`, `src/subscription.rs`
- `link/kalam-link-dart/flutter_rust_bridge.yaml`
- `link/sdks/dart/pubspec.yaml`, `lib/kalam_link.dart`, `lib/src/kalam_client.dart`, `lib/src/auth.dart`, `lib/src/models.dart`
- `link/sdks/dart/lib/src/generated/` (auto-generated)
- `link/sdks/dart/test/`, `link/sdks/dart/example/`, `link/sdks/dart/README.md`

---

### Verification

1. `cd link/kalam-link-dart && cargo check` — bridge crate compiles
2. `flutter_rust_bridge_codegen generate` — codegen succeeds
3. `cd link/sdks/dart && dart analyze` — no analysis errors
4. `cd link/sdks/dart && flutter test` — unit tests pass
5. Manual: start KalamDB server → run integration tests
6. Manual: `flutter run` example on Android/iOS/Chrome — cross-platform sanity check

---

### Decisions

- **No changes to `kalam-link`** — all bridge logic in the new crate
- **StreamSink for subscriptions** — idiomatic Dart Streams instead of poll-based `next()`
- **Query params as JSON string** — avoids complex `serde_json::Value` FRB bridging
- **Rows stay as `Vec<Vec<Option<String>>>`** — Dart layer handles parsing to typed values

---

### End-User Dart API — Usage Examples

#### Authentication

```dart
import 'package:kalam_link/kalam_link.dart';

// Basic auth
final client = await KalamClient.connect(
  url: 'https://db.example.com',
  auth: Auth.basic('alice', 'secret123'),
);

// JWT token (e.g. after login)
final loginResult = await client.login('alice', 'secret123');
final authedClient = await KalamClient.connect(
  url: 'https://db.example.com',
  auth: Auth.jwt(loginResult.accessToken),
);

// Refresh an expiring token
final refreshed = await client.refreshToken(loginResult.refreshToken);

// No auth (public server / testing)
final anonClient = await KalamClient.connect(
  url: 'http://localhost:3000',
  auth: Auth.none(),
);
```

---

#### Query with Parameters

```dart
import 'package:kalam_link/kalam_link.dart';

final client = await KalamClient.connect(
  url: 'https://db.example.com',
  auth: Auth.basic('alice', 'secret123'),
);

// Simple query
final result = await client.query('SELECT * FROM users LIMIT 10');
for (final row in result.rows) {
  print(row); // List<String?> — one value per column
}

// Parameterized query ($1, $2, ... placeholders)
final filtered = await client.query(
  'SELECT * FROM orders WHERE user_id = \$1 AND status = \$2',
  params: ['user-uuid-123', 'pending'],
);

// Access column metadata
for (final col in filtered.columns) {
  print('${col.name}: ${col.dataType}');
}

// Query in a specific namespace
final nsResult = await client.query(
  'SELECT * FROM products',
  namespace: 'shop',
);

// Typed helper — parse rows into maps
final maps = filtered.toMaps(); // List<Map<String, String?>>
for (final m in maps) {
  print('Order ${m['id']} — status: ${m['status']}');
}

await client.dispose();
```

---

#### Subscriptions (Live Queries)

```dart
import 'package:kalam_link/kalam_link.dart';

final client = await KalamClient.connect(
  url: 'https://db.example.com',
  auth: Auth.basic('alice', 'secret123'),
);

// subscribe() returns a standard Dart Stream<ChangeEvent>
final stream = client.subscribe('SELECT * FROM messages WHERE room_id = \$1',
  params: ['room-42'],
);

await for (final event in stream) {
  switch (event) {
    case InitialDataBatch(:final rows):
      print('Snapshot: ${rows.length} rows');
    case InsertEvent(:final row):
      print('New message: ${row['body']}');
    case UpdateEvent(:final row, :final oldRow):
      print('Edited: ${oldRow?['body']} → ${row['body']}');
    case DeleteEvent(:final row):
      print('Deleted: ${row['id']}');
    case SubscriptionError(:final message):
      print('Error: $message');
  }
}

// Cancel the subscription by cancelling the StreamSubscription
final sub = client.subscribe('SELECT * FROM notifications').listen((event) {
  // handle event
});

// Later, to stop receiving events:
await sub.cancel();

await client.dispose();
```

---

#### Full Flutter Widget Example

```dart
import 'package:flutter/material.dart';
import 'package:kalam_link/kalam_link.dart';

class MessagesPage extends StatefulWidget {
  const MessagesPage({super.key});

  @override
  State<MessagesPage> createState() => _MessagesPageState();
}

class _MessagesPageState extends State<MessagesPage> {
  late KalamClient _client;
  final _messages = <Map<String, String?>>[]; 
  StreamSubscription<ChangeEvent>? _sub;

  @override
  void initState() {
    super.initState();
    _init();
  }

  Future<void> _init() async {
    _client = await KalamClient.connect(
      url: 'https://db.example.com',
      auth: Auth.basic('alice', 'secret123'),
    );

    // Load initial data + stream live changes
    _sub = _client.subscribe('SELECT * FROM messages ORDER BY created_at').listen((event) {
      setState(() {
        switch (event) {
          case InitialDataBatch(:final rows):
            _messages
              ..clear()
              ..addAll(rows.map((r) => r.toMap()));
          case InsertEvent(:final row):
            _messages.add(row.toMap());
          case DeleteEvent(:final row):
            _messages.removeWhere((m) => m['id'] == row['id']);
          case _:
            break;
        }
      });
    });
  }

  @override
  void dispose() {
    _sub?.cancel();
    _client.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: _messages.length,
      itemBuilder: (_, i) => ListTile(title: Text(_messages[i]['body'] ?? '')),
    );
  }
}
```

---

### Further Considerations

1. **FRB version pinning** — v2 is actively evolving; pin to a specific minor (e.g., `2.9.x`) to avoid codegen breaks.
2. **Web path uses different underlying HTTP/WS** — `kalam-link/wasm` uses browser fetch + WebSocket (not reqwest/tungstenite). This is already handled by kalam-link's feature flags; the bridge just selects the right one.
3. **Row data format** — keeping rows as string arrays keeps the bridge simple. A future iteration could add typed `DartValue` enum if needed.
