//! Data Applier traits for persisting user and shared table data
//!
//! These traits are called by UserDataStateMachine and SharedDataStateMachine
//! after Raft consensus commits a command. All nodes (leader and followers)
//! call this, ensuring that all replicas persist the same data.
//!
//! The implementation lives in kalamdb-core using provider infrastructure.

use async_trait::async_trait;
use kalamdb_commons::models::UserId;
use kalamdb_commons::TableId;

use crate::RaftError;

/// Applier callback for user table data operations
///
/// This trait is called by UserDataStateMachine after Raft consensus commits
/// a data command. All nodes (leader and followers) call this, ensuring that
/// all replicas persist the same data to their local storage.
///
/// # Implementation
///
/// The implementation lives in kalamdb-core and uses table providers
/// to persist data to RocksDB.
#[async_trait]
pub trait UserDataApplier: Send + Sync {
    /// Insert rows into a user table
    ///
    /// # Arguments
    /// * `table_id` - The table identifier
    /// * `user_id` - The user who owns this data
    /// * `rows` - Row data to insert
    ///
    /// # Returns
    /// Number of rows inserted
    async fn insert(
        &self,
        table_id: &TableId,
        user_id: &UserId,
        rows: &[kalamdb_commons::models::Row],
    ) -> Result<usize, RaftError>;

    /// Update rows in a user table
    ///
    /// # Arguments
    /// * `table_id` - The table identifier
    /// * `user_id` - The user who owns this data
    /// * `updates` - Update row data
    /// * `filter` - Optional filter string (e.g., primary key value)
    ///
    /// # Returns
    /// Number of rows updated
    async fn update(
        &self,
        table_id: &TableId,
        user_id: &UserId,
        updates: &[kalamdb_commons::models::Row],
        filter: Option<&str>,
    ) -> Result<usize, RaftError>;

    /// Delete rows from a user table
    ///
    /// # Arguments
    /// * `table_id` - The table identifier
    /// * `user_id` - The user who owns this data
    /// * `pk_values` - Optional list of primary key values to delete
    ///
    /// # Returns
    /// Number of rows deleted
    async fn delete(
        &self,
        table_id: &TableId,
        user_id: &UserId,
        pk_values: Option<&[String]>,
    ) -> Result<usize, RaftError>;
}

/// Applier callback for shared table data operations
///
/// This trait is called by SharedDataStateMachine after Raft consensus commits
/// a data command. All nodes (leader and followers) call this.
#[async_trait]
pub trait SharedDataApplier: Send + Sync {
    /// Insert rows into a shared table
    ///
    /// # Arguments
    /// * `table_id` - The table identifier
    /// * `rows` - Row data to insert
    ///
    /// # Returns
    /// Number of rows inserted
    async fn insert(
        &self,
        table_id: &TableId,
        rows: &[kalamdb_commons::models::Row],
    ) -> Result<usize, RaftError>;

    /// Update rows in a shared table
    ///
    /// # Arguments
    /// * `table_id` - The table identifier
    /// * `updates` - Update row data
    /// * `filter` - Optional filter string (e.g., primary key value)
    ///
    /// # Returns
    /// Number of rows updated
    async fn update(
        &self,
        table_id: &TableId,
        updates: &[kalamdb_commons::models::Row],
        filter: Option<&str>,
    ) -> Result<usize, RaftError>;

    /// Delete rows from a shared table
    ///
    /// # Arguments
    /// * `table_id` - The table identifier
    /// * `pk_values` - Optional list of primary key values to delete
    ///
    /// # Returns
    /// Number of rows deleted
    async fn delete(
        &self,
        table_id: &TableId,
        pk_values: Option<&[String]>,
    ) -> Result<usize, RaftError>;
}

/// No-op applier for testing or standalone scenarios
pub struct NoOpUserDataApplier;

#[async_trait]
impl UserDataApplier for NoOpUserDataApplier {
    async fn insert(
        &self,
        _table_id: &TableId,
        _user_id: &UserId,
        _rows: &[kalamdb_commons::models::Row],
    ) -> Result<usize, RaftError> {
        Ok(0)
    }

    async fn update(
        &self,
        _table_id: &TableId,
        _user_id: &UserId,
        _updates: &[kalamdb_commons::models::Row],
        _filter: Option<&str>,
    ) -> Result<usize, RaftError> {
        Ok(0)
    }

    async fn delete(
        &self,
        _table_id: &TableId,
        _user_id: &UserId,
        _pk_values: Option<&[String]>,
    ) -> Result<usize, RaftError> {
        Ok(0)
    }
}

/// No-op applier for testing or standalone scenarios
pub struct NoOpSharedDataApplier;

#[async_trait]
impl SharedDataApplier for NoOpSharedDataApplier {
    async fn insert(
        &self,
        _table_id: &TableId,
        _rows: &[kalamdb_commons::models::Row],
    ) -> Result<usize, RaftError> {
        Ok(0)
    }

    async fn update(
        &self,
        _table_id: &TableId,
        _updates: &[kalamdb_commons::models::Row],
        _filter: Option<&str>,
    ) -> Result<usize, RaftError> {
        Ok(0)
    }

    async fn delete(
        &self,
        _table_id: &TableId,
        _pk_values: Option<&[String]>,
    ) -> Result<usize, RaftError> {
        Ok(0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use kalamdb_commons::models::{NamespaceId, TableName};
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::sync::Arc;

    /// Mock applier that tracks calls for testing
    struct MockUserDataApplier {
        insert_count: Arc<AtomicUsize>,
        update_count: Arc<AtomicUsize>,
        delete_count: Arc<AtomicUsize>,
    }

    impl MockUserDataApplier {
        fn new() -> Self {
            Self {
                insert_count: Arc::new(AtomicUsize::new(0)),
                update_count: Arc::new(AtomicUsize::new(0)),
                delete_count: Arc::new(AtomicUsize::new(0)),
            }
        }

        fn get_counts(&self) -> (usize, usize, usize) {
            (
                self.insert_count.load(Ordering::SeqCst),
                self.update_count.load(Ordering::SeqCst),
                self.delete_count.load(Ordering::SeqCst),
            )
        }
    }

    #[async_trait]
    impl UserDataApplier for MockUserDataApplier {
        async fn insert(
            &self,
            _table_id: &TableId,
            _user_id: &UserId,
            rows_data: &[u8],
        ) -> Result<usize, RaftError> {
            self.insert_count.fetch_add(1, Ordering::SeqCst);
            Ok(rows_data.len())
        }

        async fn update(
            &self,
            _table_id: &TableId,
            _user_id: &UserId,
            _updates_data: &[u8],
            _filter_data: Option<&[u8]>,
        ) -> Result<usize, RaftError> {
            self.update_count.fetch_add(1, Ordering::SeqCst);
            Ok(1)
        }

        async fn delete(
            &self,
            _table_id: &TableId,
            _user_id: &UserId,
            _filter_data: Option<&[u8]>,
        ) -> Result<usize, RaftError> {
            self.delete_count.fetch_add(1, Ordering::SeqCst);
            Ok(1)
        }
    }

    /// Mock shared applier for testing
    struct MockSharedDataApplier {
        insert_count: Arc<AtomicUsize>,
    }

    impl MockSharedDataApplier {
        fn new() -> Self {
            Self {
                insert_count: Arc::new(AtomicUsize::new(0)),
            }
        }
    }

    #[async_trait]
    impl SharedDataApplier for MockSharedDataApplier {
        async fn insert(
            &self,
            _table_id: &TableId,
            rows_data: &[u8],
        ) -> Result<usize, RaftError> {
            self.insert_count.fetch_add(1, Ordering::SeqCst);
            Ok(rows_data.len())
        }

        async fn update(
            &self,
            _table_id: &TableId,
            _updates_data: &[u8],
            _filter_data: Option<&[u8]>,
        ) -> Result<usize, RaftError> {
            Ok(1)
        }

        async fn delete(
            &self,
            _table_id: &TableId,
            _filter_data: Option<&[u8]>,
        ) -> Result<usize, RaftError> {
            Ok(1)
        }
    }

    #[tokio::test]
    async fn test_user_data_applier_insert() {
        let applier = MockUserDataApplier::new();
        let table_id = TableId::new(NamespaceId::from("test_ns"), TableName::from("test_table"));
        let user_id = UserId::from("user_123");
        let rows_data = vec![1, 2, 3, 4];

        let result = applier.insert(&table_id, &user_id, &rows_data).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 4);
        assert_eq!(applier.get_counts(), (1, 0, 0));
    }

    #[tokio::test]
    async fn test_user_data_applier_update() {
        let applier = MockUserDataApplier::new();
        let table_id = TableId::new(NamespaceId::from("test_ns"), TableName::from("test_table"));
        let user_id = UserId::from("user_123");
        let updates_data = vec![5, 6];

        let result = applier.update(&table_id, &user_id, &updates_data, None).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 1);
        assert_eq!(applier.get_counts(), (0, 1, 0));
    }

    #[tokio::test]
    async fn test_user_data_applier_delete() {
        let applier = MockUserDataApplier::new();
        let table_id = TableId::new(NamespaceId::from("test_ns"), TableName::from("test_table"));
        let user_id = UserId::from("user_123");

        let result = applier.delete(&table_id, &user_id, None).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 1);
        assert_eq!(applier.get_counts(), (0, 0, 1));
    }

    #[tokio::test]
    async fn test_noop_user_applier_returns_zero() {
        let applier = NoOpUserDataApplier;
        let table_id = TableId::new(NamespaceId::from("test_ns"), TableName::from("test_table"));
        let user_id = UserId::from("user_123");

        assert_eq!(applier.insert(&table_id, &user_id, &[]).await.unwrap(), 0);
        assert_eq!(applier.update(&table_id, &user_id, &[], None).await.unwrap(), 0);
        assert_eq!(applier.delete(&table_id, &user_id, None).await.unwrap(), 0);
    }

    #[tokio::test]
    async fn test_shared_data_applier_insert() {
        let applier = MockSharedDataApplier::new();
        let table_id = TableId::new(NamespaceId::from("shared_ns"), TableName::from("shared_table"));
        let rows_data = vec![10, 20, 30];

        let result = applier.insert(&table_id, &rows_data).await;
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), 3);
        assert_eq!(applier.insert_count.load(Ordering::SeqCst), 1);
    }

    #[tokio::test]
    async fn test_noop_shared_applier_returns_zero() {
        let applier = NoOpSharedDataApplier;
        let table_id = TableId::new(NamespaceId::from("test_ns"), TableName::from("test_table"));

        assert_eq!(applier.insert(&table_id, &[]).await.unwrap(), 0);
        assert_eq!(applier.update(&table_id, &[], None).await.unwrap(), 0);
        assert_eq!(applier.delete(&table_id, None).await.unwrap(), 0);
    }

    #[tokio::test]
    async fn test_user_applier_with_filter() {
        let applier = MockUserDataApplier::new();
        let table_id = TableId::new(NamespaceId::from("test_ns"), TableName::from("test_table"));
        let user_id = UserId::from("user_123");
        let filter = vec![1, 2, 3];

        // Update with filter
        let result = applier.update(&table_id, &user_id, &[], Some(&filter)).await;
        assert!(result.is_ok());
        
        // Delete with filter
        let result = applier.delete(&table_id, &user_id, Some(&filter)).await;
        assert!(result.is_ok());
        
        assert_eq!(applier.get_counts(), (0, 1, 1));
    }

    #[tokio::test]
    async fn test_multiple_operations_sequential() {
        let applier = MockUserDataApplier::new();
        let table_id = TableId::new(NamespaceId::from("test_ns"), TableName::from("test_table"));
        let user_id = UserId::from("user_123");

        applier.insert(&table_id, &user_id, &[1, 2]).await.unwrap();
        applier.insert(&table_id, &user_id, &[3, 4]).await.unwrap();
        applier.update(&table_id, &user_id, &[5], None).await.unwrap();
        applier.delete(&table_id, &user_id, None).await.unwrap();

        assert_eq!(applier.get_counts(), (2, 1, 1));
    }
}
