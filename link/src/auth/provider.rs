//! Authentication provider for KalamDB client.
//!
//! Handles JWT tokens, HTTP Basic Auth, and async dynamic auth providers.
//!
//! ## Dynamic Auth Provider
//!
//! Use [`DynamicAuthProvider`] to supply credentials lazily — called on every
//! connect or reconnect.  This is the right choice for:
//! - OAuth / OIDC token flows where tokens expire
//! - Credentials fetched from secure storage (e.g. keychain, secret manager)
//! - Automatic refresh-token rotation
//!
//! ```rust,no_run
//! use kalam_link::{AuthProvider, DynamicAuthProvider};
//! use std::sync::Arc;
//!
//! struct MyTokenStore { /* ... */ }
//!
//! #[async_trait::async_trait]
//! impl DynamicAuthProvider for MyTokenStore {
//!     async fn get_auth(&self) -> kalam_link::Result<AuthProvider> {
//!         // fetch / refresh token here
//!         Ok(AuthProvider::jwt_token("fresh-token".into()))
//!     }
//! }
//!
//! // Wrap in Arc and pass to the builder:
//! // .auth_provider(Arc::new(MyTokenStore { ... }))
//! ```

use crate::error::Result;
use base64::{engine::general_purpose, Engine as _};
use std::sync::Arc;

/// Authentication credentials for KalamDB server.
///
/// Supports JWT tokens and HTTP Basic Auth.
/// The auth provider automatically attaches the appropriate Authorization header.
///
/// # Examples
///
/// ```rust
/// use kalam_link::AuthProvider;
///
/// // HTTP Basic Auth (recommended)
/// let auth = AuthProvider::basic_auth("username".to_string(), "password".to_string());
///
/// // JWT token authentication
/// let auth = AuthProvider::jwt_token("eyJhbGc...".to_string());
///
/// // No authentication (localhost bypass mode)
/// let auth = AuthProvider::none();
/// ```
#[derive(Debug, Clone)]
pub enum AuthProvider {
    /// HTTP Basic Auth (username, password)
    BasicAuth(String, String),

    /// JWT token authentication
    JwtToken(String),

    /// No authentication (localhost bypass)
    None,
}

impl AuthProvider {
    /// Create HTTP Basic Auth (recommended for user authentication)
    ///
    /// Encodes username:password as base64 for Authorization: Basic header
    /// following RFC 7617.
    pub fn basic_auth(username: String, password: String) -> Self {
        Self::BasicAuth(username, password)
    }

    /// Create system user authentication (convenience for CLI and internal tools)
    ///
    /// Uses the default system username "root" with provided password.
    pub fn system_user_auth(password: String) -> Self {
        Self::BasicAuth("root".to_string(), password)
    }

    /// Create JWT token authentication
    pub fn jwt_token(token: String) -> Self {
        Self::JwtToken(token)
    }

    /// No authentication (for localhost bypass mode)
    pub fn none() -> Self {
        Self::None
    }

    /// Attach authentication headers to an HTTP request builder
    ///
    /// Applies the appropriate Authorization header based on the auth method:
    /// - BasicAuth: `Authorization: Basic <base64(username:password)>`
    /// - JwtToken: `Authorization: Bearer <token>`
    /// - None: No headers
    pub fn apply_to_request(
        &self,
        request: reqwest::RequestBuilder,
    ) -> Result<reqwest::RequestBuilder> {
        match self {
            Self::BasicAuth(username, password) => {
                let credentials = format!("{}:{}", username, password);
                let encoded = general_purpose::STANDARD.encode(credentials.as_bytes());
                Ok(request.header("Authorization", format!("Basic {}", encoded)))
            },
            Self::JwtToken(token) => Ok(request.bearer_auth(token)),
            Self::None => Ok(request),
        }
    }

    /// Check if authentication is configured
    pub fn is_authenticated(&self) -> bool {
        !matches!(self, Self::None)
    }
}

// ── Dynamic (async) auth provider ────────────────────────────────────────────

/// Async authentication provider called on every connect or reconnect.
///
/// Implement this trait to supply credentials lazily from any source:
/// OAuth token refresh, secure storage, interactive login, etc.
#[async_trait::async_trait]
pub trait DynamicAuthProvider: Send + Sync + 'static {
    /// Return the current (or freshly refreshed) credentials.
    async fn get_auth(&self) -> Result<AuthProvider>;
}

/// A boxed, reference-counted [`DynamicAuthProvider`].
pub type ArcDynAuthProvider = Arc<dyn DynamicAuthProvider>;

/// Resolves the effective [`AuthProvider`] for a connection.
///
/// Holds either a static provider or a dynamic one.  Call [`resolve`] before
/// each connect/reconnect to obtain a fresh [`AuthProvider`].
///
/// [`resolve`]: ResolvedAuth::resolve
#[derive(Clone)]
pub enum ResolvedAuth {
    /// Static credentials set at construction time.
    Static(AuthProvider),
    /// Dynamic provider called on every connect.
    Dynamic(ArcDynAuthProvider),
}

impl ResolvedAuth {
    /// Obtain effective credentials, calling the dynamic provider if present.
    pub async fn resolve(&self) -> Result<AuthProvider> {
        match self {
            Self::Static(p) => Ok(p.clone()),
            Self::Dynamic(provider) => provider.get_auth().await,
        }
    }

    /// `true` when no credentials of either kind are configured.
    pub fn is_none(&self) -> bool {
        matches!(self, Self::Static(AuthProvider::None))
    }
}

impl std::fmt::Debug for ResolvedAuth {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Static(p) => write!(f, "ResolvedAuth::Static({:?})", p),
            Self::Dynamic(_) => write!(f, "ResolvedAuth::Dynamic(<fn>)"),
        }
    }
}

impl Default for ResolvedAuth {
    fn default() -> Self {
        Self::Static(AuthProvider::None)
    }
}

impl From<AuthProvider> for ResolvedAuth {
    fn from(p: AuthProvider) -> Self {
        Self::Static(p)
    }
}

impl From<ArcDynAuthProvider> for ResolvedAuth {
    fn from(p: ArcDynAuthProvider) -> Self {
        Self::Dynamic(p)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_auth_provider_creation() {
        let basic = AuthProvider::basic_auth("alice".to_string(), "secret".to_string());
        assert!(basic.is_authenticated());

        let system = AuthProvider::system_user_auth("password123".to_string());
        assert!(system.is_authenticated());

        let jwt = AuthProvider::jwt_token("test_token".to_string());
        assert!(jwt.is_authenticated());

        let none = AuthProvider::none();
        assert!(!none.is_authenticated());
    }

    #[test]
    fn test_basic_auth_encoding() {
        let auth = AuthProvider::basic_auth("alice".to_string(), "secret123".to_string());

        let client = reqwest::Client::new();
        let request = client.get("http://localhost:8080");
        let result = auth.apply_to_request(request);
        assert!(result.is_ok());
    }

    #[test]
    fn test_system_user_auth_uses_root() {
        let auth = AuthProvider::system_user_auth("test_password".to_string());

        match auth {
            AuthProvider::BasicAuth(username, password) => {
                assert_eq!(username, "root");
                assert_eq!(password, "test_password");
            },
            _ => panic!("Expected BasicAuth variant"),
        }
    }

    #[test]
    fn test_basic_auth_base64_format() {
        let username = "alice";
        let password = "secret123";
        let credentials = format!("{}:{}", username, password);
        let encoded = general_purpose::STANDARD.encode(credentials.as_bytes());
        assert_eq!(encoded, "YWxpY2U6c2VjcmV0MTIz");
    }
}
