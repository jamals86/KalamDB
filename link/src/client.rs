//! Main KalamDB client with builder pattern.
//!
//! Provides the primary interface for connecting to KalamDB servers
//! and executing operations.

use crate::{
    auth::AuthProvider,
    consumer::ConsumerBuilder,
    error::{KalamLinkError, Result},
    event_handlers::EventHandlers,
    models::{
        ConnectionOptions, HealthCheckResponse, HttpVersion, QueryResponse, SubscriptionConfig,
    },
    query::{QueryExecutor, UploadProgressCallback},
    subscription::SubscriptionManager,
    timeouts::KalamLinkTimeouts,
};
use std::{
    sync::Arc,
    time::{Duration, Instant},
};
use tokio::sync::Mutex;

/// Main KalamDB client.
///
/// Use [`KalamLinkClientBuilder`] to construct instances with custom configuration.
///
/// # Examples
///
/// ```rust,no_run
/// use kalam_link::KalamLinkClient;
///
/// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
/// let client = KalamLinkClient::builder()
///     .base_url("http://localhost:3000")
///     .timeout(std::time::Duration::from_secs(30))
///     .build()?;
///
/// let response = client.execute_query("SELECT 1", None, None, None).await?;
/// println!("Result: {:?}", response);
/// # Ok(())
/// # }
/// ```
#[derive(Clone)]
pub struct KalamLinkClient {
    base_url: String,
    http_client: reqwest::Client,
    auth: AuthProvider,
    query_executor: QueryExecutor,
    health_cache: Arc<Mutex<HealthCheckCache>>,
    timeouts: KalamLinkTimeouts,
    connection_options: ConnectionOptions,
    event_handlers: EventHandlers,
}

impl KalamLinkClient {
    /// Create a new builder for configuring the client
    pub fn builder() -> KalamLinkClientBuilder {
        KalamLinkClientBuilder::new()
    }

    /// Execute a SQL query with optional files, parameters, and namespace context
    ///
    /// # Arguments
    /// * `sql` - The SQL query string
    /// * `files` - Optional file uploads for FILE("name") placeholders
    /// * `params` - Optional query parameters for $1, $2, ... placeholders
    /// * `namespace_id` - Optional namespace for unqualified table names
    ///
    /// # Example
    /// ```rust,no_run
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let client = kalam_link::KalamLinkClient::builder().base_url("http://localhost:3000").build()?;
    /// // Simple query
    /// let result = client.execute_query("SELECT * FROM users", None, None, None).await?;
    ///
    /// // Query with parameters
    /// let params = vec![serde_json::json!(42)];
    /// let result = client.execute_query("SELECT * FROM users WHERE id = $1", None, Some(params), None).await?;
    ///
    /// // Query in specific namespace
    /// let result = client.execute_query("SELECT * FROM messages", None, None, Some("chat")).await?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn execute_query(
        &self,
        sql: &str,
        files: Option<Vec<(&str, &str, Vec<u8>, Option<&str>)>>,
        params: Option<Vec<serde_json::Value>>,
        namespace_id: Option<&str>,
    ) -> Result<QueryResponse> {
        self.execute_query_with_progress(sql, files, params, namespace_id, None).await
    }

    /// Execute a SQL query with optional files and a progress callback for uploads.
    pub async fn execute_query_with_progress(
        &self,
        sql: &str,
        files: Option<Vec<(&str, &str, Vec<u8>, Option<&str>)>>,
        params: Option<Vec<serde_json::Value>>,
        namespace_id: Option<&str>,
        progress: Option<UploadProgressCallback>,
    ) -> Result<QueryResponse> {
        let files_owned = files.map(|items| {
            items
                .into_iter()
                .map(|(placeholder, filename, data, mime)| {
                    (
                        placeholder.to_string(),
                        filename.to_string(),
                        data,
                        mime.map(|m| m.to_string()),
                    )
                })
                .collect()
        });

        self.query_executor
            .execute_with_progress(
                sql,
                files_owned,
                params,
                namespace_id.map(|s| s.to_string()),
                progress,
            )
            .await
    }

    /// Execute a SQL query with file uploads (FILE datatype support).
    ///
    /// This method allows inserting/updating rows that contain FILE columns.
    /// Use FILE("name") placeholders in SQL that reference uploaded files.
    ///
    /// # Arguments
    /// * `sql` - SQL statement containing FILE("name") placeholders
    /// * `files` - Vector of (placeholder_name, filename, data, optional_mime_type)
    /// * `params` - Optional query parameters for $1, $2, ... placeholders  
    /// * `namespace_id` - Optional namespace for unqualified table names
    ///
    /// # Example
    /// ```rust,no_run
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// # let client = kalam_link::KalamLinkClient::builder().base_url("http://localhost:3000").build()?;
    /// use std::fs;
    ///
    /// // Read file from disk
    /// let avatar_data = fs::read("avatar.png")?;
    ///
    /// // Insert with file
    /// let result = client.execute_with_files(
    ///     "INSERT INTO users (name, avatar) VALUES ($1, FILE(\"avatar\"))",
    ///     vec![("avatar", "avatar.png", avatar_data, Some("image/png"))],
    ///     Some(vec![serde_json::json!("Alice")]),
    ///     None
    /// ).await?;
    /// # Ok(())
    /// # }
    /// ```
    #[cfg(feature = "tokio-runtime")]
    pub async fn execute_with_files(
        &self,
        sql: &str,
        files: Vec<(&str, &str, Vec<u8>, Option<&str>)>,
        params: Option<Vec<serde_json::Value>>,
        namespace_id: Option<&str>,
    ) -> Result<QueryResponse> {
        self.execute_query(sql, Some(files), params, namespace_id).await
    }

    /// Execute a SQL query with file uploads and a progress callback.
    #[cfg(feature = "tokio-runtime")]
    pub async fn execute_with_files_with_progress(
        &self,
        sql: &str,
        files: Vec<(&str, &str, Vec<u8>, Option<&str>)>,
        params: Option<Vec<serde_json::Value>>,
        namespace_id: Option<&str>,
        progress: Option<UploadProgressCallback>,
    ) -> Result<QueryResponse> {
        self.execute_query_with_progress(sql, Some(files), params, namespace_id, progress)
            .await
    }

    /// Subscribe to real-time changes
    pub async fn subscribe(&self, query: &str) -> Result<SubscriptionManager> {
        // Generate a unique subscription ID using timestamp + random component
        let nanos = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_nanos();
        let subscription_id = format!("sub_{}", nanos);
        self.subscribe_with_config(SubscriptionConfig::new(subscription_id, query))
            .await
    }

    /// Subscribe with advanced configuration (pre-generated ID, options, ws_url override)
    pub async fn subscribe_with_config(
        &self,
        config: SubscriptionConfig,
    ) -> Result<SubscriptionManager> {
        SubscriptionManager::new(
            &self.base_url,
            config,
            &self.auth,
            &self.timeouts,
            &self.connection_options,
            &self.event_handlers,
        )
        .await
    }

    /// Get the current event handlers
    pub fn event_handlers(&self) -> &EventHandlers {
        &self.event_handlers
    }

    /// Get the configured timeouts
    pub fn timeouts(&self) -> &KalamLinkTimeouts {
        &self.timeouts
    }

    /// Create a topic consumer builder bound to this client
    pub fn consumer(&self) -> ConsumerBuilder {
        ConsumerBuilder::from_client(self.clone())
    }

    pub(crate) fn base_url(&self) -> &str {
        &self.base_url
    }

    pub(crate) fn http_client(&self) -> reqwest::Client {
        self.http_client.clone()
    }

    pub(crate) fn auth(&self) -> &AuthProvider {
        &self.auth
    }

    /// Check server health and get server information
    pub async fn health_check(&self) -> Result<HealthCheckResponse> {
        {
            let cache = self.health_cache.lock().await;
            if let (Some(last_check), Some(response)) =
                (cache.last_check, cache.last_response.clone())
            {
                if last_check.elapsed() < HEALTH_CHECK_TTL {
                    log::debug!(
                        "[HEALTH_CHECK] Returning cached response (age: {:?})",
                        last_check.elapsed()
                    );
                    return Ok(response);
                }
            }
        }

        let url = format!("{}/v1/api/healthcheck", self.base_url);
        log::debug!("[HEALTH_CHECK] Fetching from url={}", url);
        let start = std::time::Instant::now();
        let response = self.http_client.get(&url).send().await?;
        log::debug!(
            "[HEALTH_CHECK] HTTP response received in {:?}, status={}",
            start.elapsed(),
            response.status()
        );
        let status = response.status();
        if !status.is_success() {
            let body = response.text().await.unwrap_or_default();
            let message = if status.as_u16() == 403 {
                format!(
                    "Health check endpoint is restricted to localhost connections ({})",
                    body
                )
            } else {
                format!("HTTP {} â€” {}", status, body)
            };
            return Err(crate::error::KalamLinkError::ServerError {
                status_code: status.as_u16(),
                message,
            });
        }
        let health_response = response.json::<HealthCheckResponse>().await?;
        log::debug!("[HEALTH_CHECK] JSON parsed in {:?}", start.elapsed());

        let mut cache = self.health_cache.lock().await;
        cache.last_check = Some(Instant::now());
        cache.last_response = Some(health_response.clone());

        Ok(health_response)
    }

    /// Login with username and password to obtain a JWT token
    ///
    /// This method authenticates with the server and returns a JWT access token
    /// that can be used for subsequent API calls via `AuthProvider::jwt_token()`.
    ///
    /// # Arguments
    /// * `username` - The username for authentication
    /// * `password` - The password for authentication
    ///
    /// # Returns
    /// A `LoginResponse` containing the JWT access token and user information
    ///
    /// # Example
    /// ```rust,no_run
    /// # async fn example() -> Result<(), Box<dyn std::error::Error>> {
    /// use kalam_link::{KalamLinkClient, AuthProvider};
    ///
    /// // Create a client without authentication to perform login
    /// let client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:3000")
    ///     .build()?;
    ///
    /// // Login to get JWT token
    /// let login_response = client.login("alice", "secret123").await?;
    ///
    /// // Create a new client with the JWT token for subsequent calls
    /// let authenticated_client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:3000")
    ///     .auth(AuthProvider::jwt_token(login_response.access_token))
    ///     .build()?;
    /// # Ok(())
    /// # }
    /// ```
    pub async fn login(
        &self,
        username: &str,
        password: &str,
    ) -> Result<crate::models::LoginResponse> {
        let url = format!("{}/v1/api/auth/login", self.base_url);
        log::debug!("[LOGIN] Authenticating user '{}' at url={}", username, url);

        let login_request = crate::models::LoginRequest {
            username: username.to_string(),
            password: password.to_string(),
        };

        let start = std::time::Instant::now();
        let response = self.http_client.post(&url).json(&login_request).send().await?;

        let status = response.status();
        log::debug!("[LOGIN] HTTP response received in {:?}, status={}", start.elapsed(), status);

        if !status.is_success() {
            let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
            log::debug!("[LOGIN] Login failed: {}", error_text);

            // Check for setup_required error (HTTP 428 Precondition Required)
            if status.as_u16() == 428 {
                // Parse the error message for more details
                let message = if let Ok(error_json) =
                    serde_json::from_str::<serde_json::Value>(&error_text)
                {
                    error_json
                        .get("message")
                        .and_then(|m| m.as_str())
                        .unwrap_or("Server requires initial setup")
                        .to_string()
                } else {
                    "Server requires initial setup".to_string()
                };
                return Err(KalamLinkError::SetupRequired(message));
            }

            return Err(KalamLinkError::AuthenticationError(format!(
                "Login failed ({}): {}",
                status, error_text
            )));
        }

        let login_response = response.json::<crate::models::LoginResponse>().await?;
        log::debug!(
            "[LOGIN] Successfully authenticated user '{}' in {:?}",
            username,
            start.elapsed()
        );

        Ok(login_response)
    }

    /// Refresh an access token using a refresh token.
    ///
    /// This is useful when the access token has expired but the refresh token
    /// is still valid. Returns a new LoginResponse with fresh tokens.
    ///
    /// # Arguments
    /// * `refresh_token` - The refresh token obtained from a previous login
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use kalam_link::KalamLinkClient;
    ///
    /// # async fn example() -> kalam_link::Result<()> {
    /// let client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:3000")
    ///     .build()?;
    ///
    /// // Refresh using a stored refresh token
    /// let response = client.refresh_access_token("old_refresh_token").await?;
    /// println!("New access token: {}", response.access_token);
    /// # Ok(())
    /// # }
    /// ```
    pub async fn refresh_access_token(
        &self,
        refresh_token: &str,
    ) -> Result<crate::models::LoginResponse> {
        let url = format!("{}/v1/api/auth/refresh", self.base_url);
        log::debug!("[REFRESH] Refreshing access token at url={}", url);

        let start = std::time::Instant::now();

        // Send refresh token in Authorization header as Bearer token
        let response = self
            .http_client
            .post(&url)
            .header("Authorization", format!("Bearer {}", refresh_token))
            .send()
            .await?;

        let status = response.status();
        log::debug!("[REFRESH] HTTP response received in {:?}, status={}", start.elapsed(), status);

        if !status.is_success() {
            let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
            log::debug!("[REFRESH] Token refresh failed: {}", error_text);
            return Err(KalamLinkError::AuthenticationError(format!(
                "Token refresh failed ({}): {}",
                status, error_text
            )));
        }

        let login_response = response.json::<crate::models::LoginResponse>().await?;
        log::debug!("[REFRESH] Successfully refreshed token in {:?}", start.elapsed());

        Ok(login_response)
    }

    /// Check if the server requires initial setup.
    ///
    /// Returns a SetupStatusResponse indicating whether setup is needed.
    /// This endpoint only works from localhost connections.
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use kalam_link::KalamLinkClient;
    ///
    /// # async fn example() -> kalam_link::Result<()> {
    /// let client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:8080")
    ///     .build()?;
    ///
    /// let status = client.check_setup_status().await?;
    /// if status.needs_setup {
    ///     println!("Server requires setup: {}", status.message);
    /// }
    /// # Ok(())
    /// # }
    /// ```
    pub async fn check_setup_status(&self) -> Result<crate::models::SetupStatusResponse> {
        let url = format!("{}/v1/api/auth/status", self.base_url);
        log::debug!("[SETUP] Checking setup status at url={}", url);

        let start = std::time::Instant::now();
        let response = self.http_client.get(&url).send().await?;

        let status = response.status();
        log::debug!("[SETUP] Status check response in {:?}, status={}", start.elapsed(), status);

        if !status.is_success() {
            let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());
            return Err(KalamLinkError::ServerError {
                status_code: status.as_u16(),
                message: error_text,
            });
        }

        Ok(response.json::<crate::models::SetupStatusResponse>().await?)
    }

    /// Perform initial server setup.
    ///
    /// This sets the root password and creates a DBA user.
    /// Only works from localhost when root has no password configured.
    ///
    /// # Arguments
    /// * `request` - The setup request containing username, password, root_password, and optional email
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use kalam_link::{KalamLinkClient, ServerSetupRequest};
    ///
    /// # async fn example() -> kalam_link::Result<()> {
    /// let client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:8080")
    ///     .build()?;
    ///
    /// let request = ServerSetupRequest::new(
    ///     "admin",
    ///     "secure_password123",
    ///     "root_password123",
    ///     Some("admin@example.com".to_string()),
    /// );
    ///
    /// let response = client.server_setup(request).await?;
    /// println!("Setup complete: {}", response.message);
    /// # Ok(())
    /// # }
    /// ```
    pub async fn server_setup(
        &self,
        request: crate::models::ServerSetupRequest,
    ) -> Result<crate::models::ServerSetupResponse> {
        let url = format!("{}/v1/api/auth/setup", self.base_url);
        log::debug!("[SETUP] Performing server setup at url={}", url);

        let start = std::time::Instant::now();
        let response = self.http_client.post(&url).json(&request).send().await?;

        let status = response.status();
        log::debug!("[SETUP] Setup response in {:?}, status={}", start.elapsed(), status);

        if !status.is_success() {
            let error_text = response.text().await.unwrap_or_else(|_| "Unknown error".to_string());

            // Check for specific error types
            if status.as_u16() == 409 {
                return Err(KalamLinkError::ConfigurationError(
                    "Server is already configured".to_string(),
                ));
            }
            if status.as_u16() == 400 {
                // Parse error for weak password or invalid username
                if let Ok(error_json) = serde_json::from_str::<serde_json::Value>(&error_text) {
                    if let Some(message) = error_json.get("message").and_then(|m| m.as_str()) {
                        return Err(KalamLinkError::ConfigurationError(message.to_string()));
                    }
                }
            }

            return Err(KalamLinkError::ServerError {
                status_code: status.as_u16(),
                message: error_text,
            });
        }

        let setup_response = response.json::<crate::models::ServerSetupResponse>().await?;
        log::info!("[SETUP] Server setup complete: {}", setup_response.message);

        Ok(setup_response)
    }
}

/// Builder for configuring [`KalamLinkClient`] instances.
pub struct KalamLinkClientBuilder {
    base_url: Option<String>,
    timeout: Duration,
    auth: AuthProvider,
    max_retries: u32,
    timeouts: KalamLinkTimeouts,
    connection_options: ConnectionOptions,
    event_handlers: EventHandlers,
}

impl KalamLinkClientBuilder {
    pub(crate) fn new() -> Self {
        Self {
            base_url: None,
            timeout: Duration::from_secs(30),
            auth: AuthProvider::none(),
            max_retries: 3,
            timeouts: KalamLinkTimeouts::default(),
            connection_options: ConnectionOptions::default(),
            event_handlers: EventHandlers::default(),
        }
    }

    /// Set the base URL for the KalamDB server
    pub fn base_url(mut self, url: impl Into<String>) -> Self {
        self.base_url = Some(url.into());
        self
    }

    /// Set request timeout (for HTTP requests)
    pub fn timeout(mut self, timeout: Duration) -> Self {
        self.timeout = timeout;
        self
    }

    /// Set JWT token authentication
    pub fn jwt_token(mut self, token: impl Into<String>) -> Self {
        self.auth = AuthProvider::jwt_token(token.into());
        self
    }

    /// Set authentication provider directly
    ///
    /// Note: WebSocket subscriptions require JWT authentication. BasicAuth is for HTTP-only flows.
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use kalam_link::{KalamLinkClient, AuthProvider};
    ///
    /// # async fn example() -> kalam_link::Result<()> {
    /// let client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:3000")
    ///     .auth(AuthProvider::basic_auth("alice".to_string(), "secret".to_string()))
    ///     .build()?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn auth(mut self, auth: AuthProvider) -> Self {
        self.auth = auth;
        self
    }

    /// Set maximum number of retries for failed requests
    pub fn max_retries(mut self, retries: u32) -> Self {
        self.max_retries = retries;
        self
    }

    /// Set comprehensive timeout configuration for all operations
    ///
    /// This overrides individual timeout settings like `timeout()`.
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use kalam_link::{KalamLinkClient, KalamLinkTimeouts};
    ///
    /// # async fn example() -> kalam_link::Result<()> {
    /// let client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:3000")
    ///     .timeouts(KalamLinkTimeouts::fast())
    ///     .build()?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn timeouts(mut self, timeouts: KalamLinkTimeouts) -> Self {
        // Also update the HTTP timeout to match
        self.timeout = timeouts.receive_timeout;
        self.timeouts = timeouts;
        self
    }

    /// Set connection options for HTTP and WebSocket behavior
    ///
    /// This allows configuring HTTP version, reconnection behavior, and other
    /// connection-level settings.
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use kalam_link::{KalamLinkClient, ConnectionOptions, HttpVersion};
    ///
    /// # async fn example() -> kalam_link::Result<()> {
    /// let client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:3000")
    ///     .connection_options(
    ///         ConnectionOptions::new()
    ///             .with_http_version(HttpVersion::Http2)
    ///             .with_auto_reconnect(true)
    ///     )
    ///     .build()?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn connection_options(mut self, options: ConnectionOptions) -> Self {
        self.connection_options = options;
        self
    }

    /// Set the HTTP protocol version to use
    ///
    /// Shorthand for setting just the HTTP version without other connection options.
    ///
    /// - `HttpVersion::Http1` - HTTP/1.1 (default, maximum compatibility)
    /// - `HttpVersion::Http2` - HTTP/2 (multiplexing, better for concurrent requests)
    /// - `HttpVersion::Auto` - Let the client negotiate with the server
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use kalam_link::{KalamLinkClient, HttpVersion};
    ///
    /// # async fn example() -> kalam_link::Result<()> {
    /// let client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:3000")
    ///     .http_version(HttpVersion::Http2)
    ///     .build()?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn http_version(mut self, version: HttpVersion) -> Self {
        self.connection_options.http_version = version;
        self
    }

    /// Set connection lifecycle event handlers.
    ///
    /// Registers callbacks for connect, disconnect, error, and message
    /// debug hooks. All handlers are optional.
    ///
    /// # Example
    ///
    /// ```rust,no_run
    /// use kalam_link::{KalamLinkClient, EventHandlers};
    ///
    /// # async fn example() -> kalam_link::Result<()> {
    /// let client = KalamLinkClient::builder()
    ///     .base_url("http://localhost:3000")
    ///     .event_handlers(
    ///         EventHandlers::new()
    ///             .on_connect(|| println!("Connected!"))
    ///             .on_disconnect(|reason| println!("Disconnected: {}", reason))
    ///             .on_error(|err| eprintln!("Error: {}", err))
    ///             .on_receive(|msg| println!("[RECV] {}", msg))
    ///             .on_send(|msg| println!("[SEND] {}", msg)),
    ///     )
    ///     .build()?;
    /// # Ok(())
    /// # }
    /// ```
    pub fn event_handlers(mut self, handlers: EventHandlers) -> Self {
        self.event_handlers = handlers;
        self
    }

    /// Build the client
    pub fn build(self) -> Result<KalamLinkClient> {
        let base_url = self
            .base_url
            .ok_or_else(|| KalamLinkError::ConfigurationError("base_url is required".into()))?;

        // Build HTTP client with connection pooling for better throughput
        // Keep-alive connections reduce TCP handshake overhead significantly
        let mut client_builder = reqwest::Client::builder()
            .timeout(self.timeout)
            .connect_timeout(self.timeouts.connection_timeout)
            // Enable connection pooling for high throughput (keep-alive)
            .pool_max_idle_per_host(10)
            // Keep idle connections for 90 seconds (slightly longer than server's 75s)
            .pool_idle_timeout(std::time::Duration::from_secs(90));

        // Configure HTTP version based on connection options
        client_builder = match self.connection_options.http_version {
            HttpVersion::Http1 => {
                log::debug!("[CLIENT] Using HTTP/1.1 only");
                client_builder.http1_only()
            },
            HttpVersion::Http2 => {
                log::debug!("[CLIENT] Using HTTP/2 with prior knowledge");
                // http2_prior_knowledge() assumes the server speaks HTTP/2
                // Use this for known HTTP/2 servers for best performance
                client_builder.http2_prior_knowledge()
            },
            HttpVersion::Auto => {
                log::debug!("[CLIENT] Using automatic HTTP version negotiation");
                // Default behavior - will negotiate via ALPN for HTTPS
                // For HTTP, will use HTTP/1.1
                client_builder
            },
        };

        let http_client = client_builder
            .build()
            .map_err(|e| KalamLinkError::ConfigurationError(e.to_string()))?;

        let query_executor = QueryExecutor::new(
            base_url.clone(),
            http_client.clone(),
            self.auth.clone(),
            self.max_retries,
        );

        Ok(KalamLinkClient {
            base_url,
            http_client,
            auth: self.auth,
            query_executor,
            health_cache: Arc::new(Mutex::new(HealthCheckCache::default())),
            timeouts: self.timeouts,
            connection_options: self.connection_options,
            event_handlers: self.event_handlers,
        })
    }
}

const HEALTH_CHECK_TTL: Duration = Duration::from_secs(10);

#[derive(Debug, Default)]
struct HealthCheckCache {
    last_check: Option<Instant>,
    last_response: Option<HealthCheckResponse>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_builder_pattern() {
        let result = KalamLinkClient::builder()
            .base_url("http://localhost:3000")
            .timeout(Duration::from_secs(10))
            .jwt_token("test_token")
            .build();

        assert!(result.is_ok());
    }

    #[test]
    fn test_builder_missing_url() {
        let result = KalamLinkClient::builder().build();
        assert!(result.is_err());
    }
}
