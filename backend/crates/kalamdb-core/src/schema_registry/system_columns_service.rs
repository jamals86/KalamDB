//! System Column Management Service
//!
//! **Phase 12, User Story 5 - MVCC Architecture**:
//! Centralizes all system column logic (`_seq`, `_deleted`) for KalamDB tables.
//! 
//! ## Responsibilities
//! - Generate unique Snowflake-based SeqIds for `_seq` column (version identifier)
//! - Handle `_deleted` soft delete flags
//! - Inject system columns into table schemas
//! - Apply deletion filters to queries
//!
//! ## MVCC Architecture Changes
//! - **Removed**: `_id` (replaced by user-defined PK), `_updated` (replaced by _seq.timestamp_millis())
//! - **Added**: `_seq: SeqId` - Snowflake ID for version tracking with embedded timestamp
//! - **Kept**: `_deleted: bool` - Soft delete flag
//!
//! ## Architecture
//! - **SnowflakeGenerator**: Generates time-ordered unique IDs (41-bit timestamp + 10-bit worker + 12-bit sequence)
//! - **SeqId Wrapper**: Wraps Snowflake ID with timestamp extraction methods
//! - **Soft Deletes**: Records marked `_deleted=true` are filtered from queries unless explicitly requested
//!
//! ## Usage
//! ```rust
//! use kalamdb_registry::SystemColumnsService;
//!
//! let sys_cols = SystemColumnsService::new(1); // worker_id = 1
//!
//! // Generate unique SeqId
//! let seq = sys_cols.generate_seq_id()?;
//!
//! // Handle INSERT operation
//! let (seq_id, deleted_flag) = sys_cols.handle_insert()?;
//!
//! // Handle UPDATE operation  
//! let (new_seq_id, deleted_flag) = sys_cols.handle_update()?;
//!
//! // Handle DELETE operation
//! let (new_seq_id, deleted_flag) = sys_cols.handle_delete()?;
//! # Ok::<(), kalamdb_registry::RegistryError>(())
//! ```

use kalamdb_commons::ids::snowflake::SnowflakeGenerator;
use kalamdb_commons::ids::SeqId;
use kalamdb_commons::models::schemas::{ColumnDefinition, ColumnDefault, TableDefinition};
use super::error::RegistryError;
use std::sync::Arc;

/// System Columns Service
///
/// **MVCC Architecture**: Manages system columns `_seq` and `_deleted`.
/// Thread-safe via interior mutability in SnowflakeGenerator.
pub struct SystemColumnsService {
    /// Snowflake ID generator for `_seq` column
    snowflake_gen: Arc<SnowflakeGenerator>,

    /// Worker ID from config (for logging/debugging)
    worker_id: u16,
}

impl SystemColumnsService {
    /// System column names (MVCC Architecture)
    pub const COL_SEQ: &'static str = "_seq";
    pub const COL_DELETED: &'static str = "_deleted";

    // /// Legacy column names (deprecated, for migration reference)
    // #[deprecated(note = "Use COL_SEQ instead - _id removed in MVCC architecture")]
    // pub const COL_ID: &'static str = "_id";
    // #[deprecated(note = "Use _seq.timestamp_millis() instead - _updated removed in MVCC architecture")]
    // pub const COL_UPDATED: &'static str = "_updated";

    /// Create a new SystemColumnsService
    ///
    /// # Arguments
    /// * `worker_id` - Node identifier from config.toml [server.node_id]
    ///
    /// # Returns
    /// A new SystemColumnsService instance
    pub fn new(worker_id: u16) -> Self {
        let snowflake_gen = Arc::new(SnowflakeGenerator::new(worker_id));

        Self {
            snowflake_gen,
            worker_id,
        }
    }

    /// Generate a unique SeqId for `_seq` column
    ///
    /// **MVCC Architecture**: SeqId wraps Snowflake ID for version tracking.
    ///
    /// # Returns
    /// A SeqId containing a 64-bit Snowflake ID:
    /// - 41 bits: timestamp in milliseconds since 2024-01-01
    /// - 10 bits: worker/node ID
    /// - 12 bits: sequence number
    ///
    /// # Errors
    /// Returns `RegistryError::InvalidOperation` if clock moves backwards
    pub fn generate_seq_id(&self) -> Result<SeqId, RegistryError> {
        let id = self.snowflake_gen
            .next_id()
            .map_err(|e| RegistryError::InvalidOperation(format!("SeqId generation failed: {}", e)))?;
        Ok(SeqId::new(id))
    }

    /// Add system columns to a table definition
    ///
    /// **MVCC Architecture**: Injects `_seq BIGINT` and `_deleted BOOLEAN` columns
    /// if they don't already exist.
    ///
    /// # Arguments
    /// * `table_def` - Mutable reference to table definition
    ///
    /// # Errors
    /// Returns error if column names conflict with user-defined columns
    pub fn add_system_columns(&self, table_def: &mut TableDefinition) -> Result<(), RegistryError> {
        // Check for conflicts
        for col in &table_def.columns {
            if col.column_name == Self::COL_SEQ || col.column_name == Self::COL_DELETED {
                return Err(RegistryError::InvalidOperation(format!(
                    "Column name '{}' is reserved for system columns",
                    col.column_name
                )));
            }
        }

        let next_ordinal = table_def.columns.len() as u32 + 1;

        // Add _seq column (BIGINT, NOT NULL)
        // Note: _seq is NOT a primary key - user must define their own PK
        table_def.columns.push(ColumnDefinition {
            column_name: Self::COL_SEQ.to_string(),
            ordinal_position: next_ordinal,
            data_type: kalamdb_commons::models::datatypes::KalamDataType::BigInt,
            is_nullable: false,
            is_primary_key: false, // User-defined PK required separately
            is_partition_key: false,
            default_value: ColumnDefault::None,
            column_comment: Some("System-generated Snowflake-based version ID (MVCC)".to_string()),
        });

        // Add _deleted column (BOOLEAN, NOT NULL, DEFAULT FALSE)
        table_def.columns.push(ColumnDefinition {
            column_name: Self::COL_DELETED.to_string(),
            ordinal_position: next_ordinal + 1,
            data_type: kalamdb_commons::models::datatypes::KalamDataType::Boolean,
            is_nullable: false,
            is_primary_key: false,
            is_partition_key: false,
            default_value: ColumnDefault::Literal(serde_json::json!(false)),
            column_comment: Some("Soft delete flag (true = deleted, false = active)".to_string()),
        });

        Ok(())
    }

    /// Handle INSERT operation - generate system column values
    ///
    /// **MVCC Architecture**: Returns new SeqId and _deleted=false.
    ///
    /// # Returns
    /// Tuple of (`_seq`, `_deleted` = false)
    ///
    /// # Errors
    /// - `InvalidOperation` if SeqId generation fails
    pub fn handle_insert(&self) -> Result<(SeqId, bool), RegistryError> {
        // Generate unique SeqId
        let seq = self.generate_seq_id()?;

        // New records are not deleted
        let deleted = false;

        Ok((seq, deleted))
    }

    /// Handle UPDATE operation - generate new version
    ///
    /// **MVCC Architecture**: Appends new version with new SeqId, _deleted=false.
    ///
    /// # Returns
    /// Tuple of (new `_seq`, `_deleted` = false)
    ///
    /// # Details
    /// UPDATE creates a new version with a new SeqId (append-only).
    pub fn handle_update(&self) -> Result<(SeqId, bool), RegistryError> {
        let new_seq = self.generate_seq_id()?;

        // UPDATE preserves _deleted=false (use DELETE to mark deleted)
        let deleted = false;

        Ok((new_seq, deleted))
    }

    /// Handle DELETE operation - set `_deleted = true` with new version
    ///
    /// **MVCC Architecture**: Appends tombstone version with new SeqId, _deleted=true.
    ///
    /// # Returns
    /// Tuple of (new `_seq`, `_deleted` = true)
    ///
    /// # Details
    /// Soft delete: record remains in storage with `_deleted=true`.
    /// Queries filter deleted records unless `include_deleted=true`.
    pub fn handle_delete(&self) -> Result<(SeqId, bool), RegistryError> {
        let new_seq = self.generate_seq_id()?;

        // Soft delete
        let deleted = true;

        Ok((new_seq, deleted))
    }

    /// Apply deletion filter to query
    ///
    /// Injects `WHERE _deleted = false` predicate into query AST unless explicitly disabled.
    ///
    /// # Arguments
    /// * `include_deleted` - If true, don't filter deleted records
    ///
    /// # Returns
    /// SQL predicate string to inject, or None if include_deleted=true
    pub fn apply_deletion_filter(&self, include_deleted: bool) -> Option<String> {
        if include_deleted {
            None
        } else {
            Some(format!("{} = false", Self::COL_DELETED))
        }
    }

    /// Get worker ID (for debugging/logging)
    pub fn worker_id(&self) -> u16 {
        self.worker_id
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_seq_id() {
        let svc = SystemColumnsService::new(1);
        let seq1 = svc.generate_seq_id().unwrap();
        let seq2 = svc.generate_seq_id().unwrap();

        assert!(seq1.as_i64() > 0);
        assert!(seq2 > seq1, "SeqIds should be strictly increasing");
    }

    #[test]
    fn test_add_system_columns() {
        use kalamdb_commons::models::schemas::{TableOptions, TableType};
        use kalamdb_commons::{NamespaceId, TableName};

        let svc = SystemColumnsService::new(1);
        let mut table_def = TableDefinition::new(
            NamespaceId::new("test"),
            TableName::new("table"),
            TableType::User,
            vec![],
            TableOptions::user(),
            None,
        )
        .unwrap();

        svc.add_system_columns(&mut table_def).unwrap();

        assert_eq!(table_def.columns.len(), 2); // _seq and _deleted
        assert_eq!(table_def.columns[0].column_name, "_seq");
        assert_eq!(table_def.columns[1].column_name, "_deleted");
    }

    #[test]
    fn test_handle_insert_success() {
        let svc = SystemColumnsService::new(1);
        let (seq, deleted) = svc.handle_insert().unwrap();

        assert!(seq.as_i64() > 0);
        assert!(!deleted);
    }

    #[test]
    fn test_handle_update_new_seq() {
        let svc = SystemColumnsService::new(1);

        let (new_seq, deleted) = svc.handle_update().unwrap();

        assert!(new_seq.as_i64() > 0);
        assert!(!deleted);
    }

    #[test]
    fn test_handle_delete() {
        let svc = SystemColumnsService::new(1);

        let (new_seq, deleted) = svc.handle_delete().unwrap();

        assert!(new_seq.as_i64() > 0);
        assert!(deleted);
    }

    #[test]
    fn test_apply_deletion_filter() {
        let svc = SystemColumnsService::new(1);

        let filter = svc.apply_deletion_filter(false);
        assert_eq!(filter, Some("_deleted = false".to_string()));

        let no_filter = svc.apply_deletion_filter(true);
        assert_eq!(no_filter, None);
    }
}
