# Data Model: User Authentication

**Feature**: User Authentication (007-user-auth)  
**Date**: October 27, 2025  
**Status**: Phase 1 - Data Model Complete

---

## Overview

This document defines all data entities, schemas, and relationships for the User Authentication feature. All entities are technology-agnostic specifications that will be implemented using RocksDB storage and Rust type systems.

---

## Entities

### 1. User

**Purpose**: Represents an authenticated entity (person, service account, or system process) in KalamDB

**Storage**: RocksDB column family `system_users`  
**Key Format**: `{user_id}` (UserId type, role-based prefix + snowflake ID)  
**Value Format**: JSON-serialized User struct

**ID Generation**: Automatically generated by database using role-based prefixes:

| Role | ID Pattern | Example | Notes |
|------|-----------|---------|-------|
| user | `usr_<snowflake>` | `usr_123456789012345` | Default for app users |
| service | `svc_<snowflake>` | `svc_987654321098765` | Background/service accounts |
| dba | `dba_<snowflake>` | `dba_456789012345678` | Admin accounts |
| system | `sys_<snowflake>` | `sys_789012345678901` | Internal, localhost-only |

**Snowflake Format**: 64-bit integer (Twitter Snowflake algorithm) ensuring globally unique, time-ordered IDs

#### Schema

| Field | Type | Nullable | Constraints | Description |
|-------|------|----------|-------------|-------------|
| `user_id` | UserId | No | PRIMARY KEY, auto-generated, unique | Role-prefixed snowflake ID (e.g., `usr_123456789012345`) |
| `username` | UserName | No | UNIQUE, max 128 chars | Login username (case-sensitive) |
| `email` | TEXT | Yes | Valid email format if provided | User email address |
| `auth_type` | TEXT | No | ENUM: 'password', 'oauth', 'internal' | Authentication method |
| `auth_data` | TEXT | Yes | Format depends on auth_type | Authentication credentials |
| `role` | TEXT | No | ENUM: 'user', 'service', 'dba', 'system' | Authorization role |
| `storage_mode` | TEXT | Yes | ENUM: 'table', 'region' | User's storage isolation mode |
| `storage_id` | TEXT | Yes | FK to system.storages | Storage backend identifier |
| `metadata` | JSONB | Yes | Valid JSON object | Custom application metadata |
| `created_at` | TIMESTAMP | No | ISO 8601 format | User creation timestamp |
| `updated_at` | TIMESTAMP | No | ISO 8601 format | Last modification timestamp |
| `last_seen` | DATE | Yes | ISO 8601 date format (YYYY-MM-DD) | Last activity date (updated once per day) |
| `deleted_at` | TIMESTAMP | Yes | ISO 8601 format if soft-deleted | Soft delete timestamp (NULL = active) |

#### auth_data Field Format

**For auth_type = 'password'**:
```json
"<bcrypt_hash>"  // String: bcrypt hash of password (60 characters)
```

**For auth_type = 'oauth'**:
```json
{
  "provider": "google",  // OAuth provider name
  "subject": "123456789012345678901"  // Provider-specific user ID
}
```

**For auth_type = 'internal'**:
```json
null  // No credentials stored (localhost-only access)
```

#### metadata Field Examples

```json
{
  "created_by": "admin_user_123",
  "department": "engineering",
  "environment": "production",
  "allow_remote": true,  // For system users only
  "last_login": "2025-10-27T12:34:56Z",
  "login_count": 42
}
```

#### State Transitions

```
┌─────────────┐
│   CREATE    │
│  (active)   │
│ deleted_at  │
│   = NULL    │
└──────┬──────┘
       │
       │ DELETE (soft delete)
       ▼
┌──────────────┐     RESTORE (DBA only)     ┌─────────────┐
│ SOFT DELETED │◄──────────────────────────│  ACTIVE     │
│ deleted_at   │                            │ deleted_at  │
│   != NULL    │                            │   = NULL    │
└──────┬───────┘                            └─────────────┘
       │
       │ Cleanup job (after grace period)
       ▼
┌──────────────┐
│   PERMANENTLY│
│    DELETED   │
│  (removed    │
│   from DB)   │
└──────────────┘
```

#### Indexes

- **Primary Key**: `user_id` (RocksDB key)
- **Unique Index**: `username` (implemented via separate RocksDB column family `user_by_username`)
- **Filter Index**: `role` (for listing users by role)
- **Filter Index**: `deleted_at IS NULL` (for active users only)
- **Filter Index**: `last_seen` (for inactive user cleanup queries)

#### Validation Rules

1. **user_id**: Auto-generated by database using role-based prefix + snowflake ID, immutable after creation
2. **username**: Must be unique, 1-128 characters, case-sensitive, alphanumeric + underscore/hyphen allowed
3. **email**: Must be valid email format if provided (RFC 5322)
4. **auth_type**: Must be one of: 'password', 'oauth', 'internal'
5. **role**: Must be one of: 'user', 'service', 'dba', 'system'
6. **auth_data**:
   - If auth_type='password': must be 60-char bcrypt hash
   - If auth_type='oauth': must be valid JSON with provider & subject
   - If auth_type='internal': must be null
7. **metadata**: Must be valid JSON object if provided
8. **created_at**: Auto-generated on INSERT, immutable
9. **updated_at**: Auto-updated on every UPDATE
10. **last_seen**: Updated once per day on first authentication (date only, no time component)
11. **deleted_at**: NULL for active users, timestamp for soft-deleted users

#### Example Records

**Regular User (Password Auth)**:
```json
{
  "user_id": "usr_123456789012345",
  "username": "alice",
  "email": "alice@example.com",
  "auth_type": "password",
  "auth_data": "$2b$12$K3lqIZ.5rP8y8ZlW5yZrO.wF7J2XnQ4cH5gT6pL9mN2kR1sU3vW4x",
  "role": "user",
  "storage_mode": "table",
  "storage_id": "local_storage",
  "metadata": {
    "department": "engineering",
    "created_by": "admin_dba"
  },
  "created_at": "2025-10-27T10:00:00Z",
  "updated_at": "2025-10-27T10:00:00Z",
  "last_seen": "2025-10-27",
  "deleted_at": null
}
```

**Service Account (OAuth)**:
```json
{
  "user_id": "svc_987654321098765",
  "username": "backup_bot",
  "email": null,
  "auth_type": "oauth",
  "auth_data": {
    "provider": "github",
    "subject": "123456789"
  },
  "role": "service",
  "storage_mode": null,
  "storage_id": null,
  "metadata": {
    "purpose": "nightly backups",
    "schedule": "0 2 * * *"
  },
  "created_at": "2025-10-20T08:00:00Z",
  "updated_at": "2025-10-27T02:00:00Z",
  "last_seen": "2025-10-27",
  "deleted_at": null
}
```

**System User (Localhost-Only)**:
```json
{
  "user_id": "sys_456789012345678",
  "username": "cli_system",
  "email": null,
  "auth_type": "internal",
  "auth_data": null,
  "role": "system",
  "storage_mode": null,
  "storage_id": null,
  "metadata": {
    "created_by": "database_initialization",
    "purpose": "CLI access",
    "allow_remote": false
  },
  "created_at": "2025-10-27T09:00:00Z",
  "updated_at": "2025-10-27T09:00:00Z",
  "last_seen": "2025-10-27",
  "deleted_at": null
}
```

**Soft-Deleted User**:
```json
{
  "user_id": "usr_789012345678901",
  "username": "old_user",
  "email": "old@example.com",
  "auth_type": "password",
  "auth_data": "$2b$12$...",
  "role": "user",
  "storage_mode": "table",
  "storage_id": "local_storage",
  "metadata": {},
  "created_at": "2025-09-01T10:00:00Z",
  "updated_at": "2025-10-15T14:30:00Z",
  "last_seen": "2025-10-14",
  "deleted_at": "2025-10-15T14:30:00Z"
}
```

---

### 1.1 UserId Type

**Purpose**: Type-safe wrapper for user identifiers with role-based prefixes

**Implementation**: Rust newtype in `backend/crates/kalamdb-commons/src/models.rs`

**Format**: `{role_prefix}_{snowflake_id}`
- Role prefix: 3 characters (`usr`, `svc`, `dba`, `sys`)
- Separator: underscore (`_`)
- Snowflake ID: 15-digit integer (64-bit timestamp-based)

#### Rust Implementation

```rust
use serde::{Deserialize, Serialize};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct UserId(String);

impl UserId {
    /// Generate new UserId for a given role
    pub fn generate(role: UserRole) -> Self {
        let prefix = match role {
            UserRole::User => "usr",
            UserRole::Service => "svc",
            UserRole::Dba => "dba",
            UserRole::System => "sys",
        };
        
        let snowflake = generate_snowflake_id(); // 64-bit timestamp-based ID
        Self(format!("{}_{}", prefix, snowflake))
    }
    
    /// Parse UserId from string (for deserialization)
    pub fn from_str(s: &str) -> Result<Self, String> {
        // Validate format: {prefix}_{digits}
        if !s.contains('_') {
            return Err(format!("Invalid UserId format: {}", s));
        }
        
        let parts: Vec<&str> = s.split('_').collect();
        if parts.len() != 2 {
            return Err(format!("Invalid UserId format: {}", s));
        }
        
        let prefix = parts[0];
        let snowflake = parts[1];
        
        // Validate prefix
        if !matches!(prefix, "usr" | "svc" | "dba" | "sys") {
            return Err(format!("Invalid UserId prefix: {}", prefix));
        }
        
        // Validate snowflake is numeric
        if !snowflake.chars().all(|c| c.is_ascii_digit()) {
            return Err(format!("Invalid UserId snowflake: {}", snowflake));
        }
        
        Ok(Self(s.to_string()))
    }
    
    /// Extract role from UserId
    pub fn role(&self) -> Result<UserRole, String> {
        match self.0.split('_').next() {
            Some("usr") => Ok(UserRole::User),
            Some("svc") => Ok(UserRole::Service),
            Some("dba") => Ok(UserRole::Dba),
            Some("sys") => Ok(UserRole::System),
            _ => Err(format!("Invalid UserId prefix in: {}", self.0)),
        }
    }
    
    /// Get string representation
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for UserId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<UserId> for String {
    fn from(id: UserId) -> Self {
        id.0
    }
}

/// Generate Twitter Snowflake ID (64-bit)
/// Format: 41 bits timestamp + 10 bits worker + 12 bits sequence
fn generate_snowflake_id() -> u64 {
    // Implementation details:
    // - Timestamp: milliseconds since custom epoch (2020-01-01)
    // - Worker ID: 0-1023 (configurable per instance)
    // - Sequence: 0-4095 (incremented per millisecond)
    // Returns: 15-16 digit decimal number
    
    // Simplified example (actual implementation more complex):
    use std::time::{SystemTime, UNIX_EPOCH};
    
    let epoch_offset = 1577836800000; // 2020-01-01 in ms
    let now_ms = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .as_millis() as u64;
    
    let timestamp = (now_ms - epoch_offset) << 22; // 41 bits
    let worker_id = 1u64 << 12; // 10 bits (instance ID 1)
    let sequence = get_sequence(); // 12 bits (0-4095)
    
    timestamp | worker_id | sequence
}

// Sequence counter (per-instance, atomic)
static SEQUENCE: std::sync::atomic::AtomicU16 = std::sync::atomic::AtomicU16::new(0);

fn get_sequence() -> u64 {
    SEQUENCE.fetch_add(1, std::sync::atomic::Ordering::SeqCst) as u64 % 4096
}
```

#### Example IDs

```rust
// Generate new IDs
let user_id = UserId::generate(UserRole::User);
// Result: "usr_123456789012345"

let service_id = UserId::generate(UserRole::Service);
// Result: "svc_987654321098765"

// Parse existing ID
let id = UserId::from_str("dba_456789012345678")?;
assert_eq!(id.role()?, UserRole::Dba);

// Convert to string
let id_string: String = user_id.into();
```

---

### 1.2 UserName Type

**Purpose**: Type-safe wrapper for usernames with validation

**Implementation**: Rust newtype in `backend/crates/kalamdb-commons/src/models.rs`

**Constraints**:
- Length: 1-128 characters
- Characters: alphanumeric (a-z, A-Z, 0-9), underscore (_), hyphen (-)
- Case-sensitive
- Must be unique across all users

#### Rust Implementation

```rust
use serde::{Deserialize, Serialize};
use std::fmt;

#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub struct UserName(String);

impl UserName {
    /// Create new UserName with validation
    pub fn new(username: &str) -> Result<Self, String> {
        // Validate length
        if username.is_empty() || username.len() > 128 {
            return Err(format!(
                "Username must be 1-128 characters, got {}",
                username.len()
            ));
        }
        
        // Validate characters (alphanumeric + underscore + hyphen)
        if !username
            .chars()
            .all(|c| c.is_alphanumeric() || c == '_' || c == '-')
        {
            return Err(format!(
                "Username must contain only alphanumeric, underscore, or hyphen: {}",
                username
            ));
        }
        
        // Additional validations
        if username.starts_with('-') || username.ends_with('-') {
            return Err("Username cannot start or end with hyphen".to_string());
        }
        
        Ok(Self(username.to_string()))
    }
    
    /// Get string representation
    pub fn as_str(&self) -> &str {
        &self.0
    }
}

impl fmt::Display for UserName {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<UserName> for String {
    fn from(name: UserName) -> Self {
        name.0
    }
}

impl std::str::FromStr for UserName {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::new(s)
    }
}
```

#### Example Usernames

```rust
// Valid usernames
let name1 = UserName::new("alice")?;           // ✅ lowercase
let name2 = UserName::new("Bob_Smith")?;       // ✅ mixed case with underscore
let name3 = UserName::new("user-123")?;        // ✅ with hyphen and numbers
let name4 = UserName::new("Service_Account_1")?; // ✅ service account

// Invalid usernames
UserName::new("")?;                  // ❌ Empty
UserName::new("user@domain")?;       // ❌ Contains @
UserName::new("user name")?;         // ❌ Contains space
UserName::new("-alice")?;            // ❌ Starts with hyphen
UserName::new("a".repeat(129))?;     // ❌ Too long (>128 chars)
```

---

### 2. UserRole Enum

**Purpose**: Defines authorization level and permissions for users

**Implementation**: Rust enum in `backend/crates/kalamdb-commons/src/models.rs`

**Storage**: String representation (lowercase) in database and JSON

#### Variants

| Variant | String Value | Description | Permission Level |
|---------|--------------|-------------|------------------|
| `User` | `"user"` | Standard end-user | Limited (own tables only) |
| `Service` | `"service"` | Service account for integrations | Cross-user access, no DDL |
| `Dba` | `"dba"` | Database administrator | Full administrative access |
| `System` | `"system"` | Internal system processes | Full access (same as DBA) |

#### Rust Implementation

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum UserRole {
    User,
    Service,
    Dba,
    System,
}

impl UserRole {
    /// Check if role can create/drop tables
    pub fn can_create_tables(&self) -> bool {
        matches!(self, UserRole::Dba | UserRole::System)
    }
    
    /// Check if role can manage users
    pub fn can_manage_users(&self) -> bool {
        matches!(self, UserRole::Dba | UserRole::System)
    }
    
    /// Check if role can access other users' tables
    pub fn can_access_other_users_tables(&self) -> bool {
        matches!(self, UserRole::Service | UserRole::Dba | UserRole::System)
    }
    
    /// Check if role can execute admin operations (FLUSH, BACKUP, etc.)
    pub fn can_execute_admin_ops(&self) -> bool {
        !matches!(self, UserRole::User)
    }
}

impl std::fmt::Display for UserRole {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            UserRole::User => write!(f, "user"),
            UserRole::Service => write!(f, "service"),
            UserRole::Dba => write!(f, "dba"),
            UserRole::System => write!(f, "system"),
        }
    }
}

impl std::str::FromStr for UserRole {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "user" => Ok(UserRole::User),
            "service" => Ok(UserRole::Service),
            "dba" => Ok(UserRole::Dba),
            "system" => Ok(UserRole::System),
            _ => Err(format!("Invalid role: {}", s)),
        }
    }
}
```

#### Serialization Examples

**To String**:
```rust
assert_eq!(UserRole::Dba.to_string(), "dba");
```

**From String**:
```rust
let role: UserRole = "service".parse()?;
assert_eq!(role, UserRole::Service);
```

**To/From JSON**:
```rust
// Serialize
let role = UserRole::User;
let json = serde_json::to_string(&role)?;
assert_eq!(json, r#""user""#);

// Deserialize
let role: UserRole = serde_json::from_str(r#""dba""#)?;
assert_eq!(role, UserRole::Dba);
```

---

### 3. TableAccess Enum

**Purpose**: Defines visibility and access permissions for shared tables

**Implementation**: Rust enum in `backend/crates/kalamdb-commons/src/models.rs`

**Storage**: String representation (lowercase) in `system.tables.access` column

#### Variants

| Variant | String Value | Description | Who Can Access |
|---------|--------------|-------------|----------------|
| `Public` | `"public"` | Readable by all authenticated users | Any authenticated user (read-only for regular users) |
| `Private` | `"private"` | Accessible only by privileged roles | Service, DBA, System (full access) |
| `Restricted` | `"restricted"` | Future: fine-grained permissions | Service, DBA, System (same as Private for now) |

**Default**: `Private` (if not specified during table creation)

#### Rust Implementation

```rust
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum TableAccess {
    Public,
    Private,
    Restricted,
}

impl Default for TableAccess {
    fn default() -> Self {
        TableAccess::Private  // Secure by default
    }
}

impl TableAccess {
    /// Check if a given role can read from this table
    pub fn can_read(&self, role: UserRole) -> bool {
        match self {
            TableAccess::Public => true,  // Any authenticated user
            TableAccess::Private | TableAccess::Restricted => {
                matches!(role, UserRole::Service | UserRole::Dba | UserRole::System)
            }
        }
    }
    
    /// Check if a given role can write to this table
    pub fn can_write(&self, role: UserRole) -> bool {
        match self {
            TableAccess::Public => {
                // Public tables: only privileged roles can write
                matches!(role, UserRole::Service | UserRole::Dba | UserRole::System)
            }
            TableAccess::Private | TableAccess::Restricted => {
                matches!(role, UserRole::Service | UserRole::Dba | UserRole::System)
            }
        }
    }
}

impl std::fmt::Display for TableAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            TableAccess::Public => write!(f, "public"),
            TableAccess::Private => write!(f, "private"),
            TableAccess::Restricted => write!(f, "restricted"),
        }
    }
}

impl std::str::FromStr for TableAccess {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "public" => Ok(TableAccess::Public),
            "private" => Ok(TableAccess::Private),
            "restricted" => Ok(TableAccess::Restricted),
            _ => Err(format!("Invalid table access level: {}", s)),
        }
    }
}
```

#### Access Control Matrix

| User Role | Public Table (Read) | Public Table (Write) | Private Table | Restricted Table |
|-----------|---------------------|----------------------|---------------|------------------|
| User      | ✅ SELECT           | ❌ Denied             | ❌ Denied      | ❌ Denied         |
| Service   | ✅ Full DML         | ✅ Full DML           | ✅ Full DML    | ✅ Full DML       |
| DBA       | ✅ Full DML         | ✅ Full DML           | ✅ Full DML    | ✅ Full DML       |
| System    | ✅ Full DML         | ✅ Full DML           | ✅ Full DML    | ✅ Full DML       |

---

### 4. AuthenticatedUser

**Purpose**: Request-scoped context representing the authenticated user

**Lifetime**: Created during authentication, attached to HTTP request, destroyed after response

**Implementation**: Rust struct passed through request pipeline

#### Schema

| Field | Type | Description |
|-------|------|-------------|
| `user_id` | UserId | Unique user identifier (role-prefixed snowflake) |
| `username` | UserName | Login username (validated) |
| `role` | UserRole | Authorization role (enum) |
| `email` | Option<TEXT> | User email (if available) |
| `connection_info` | ConnectionInfo | Connection source details |

#### Rust Implementation

```rust
#[derive(Debug, Clone)]
pub struct AuthenticatedUser {
    pub user_id: UserId,
    pub username: UserName,
    pub role: UserRole,
    pub email: Option<String>,
    pub connection_info: ConnectionInfo,
}

impl AuthenticatedUser {
    /// Check if user has required role
    pub fn has_role(&self, required_role: UserRole) -> bool {
        self.role == required_role || 
        matches!(self.role, UserRole::Dba | UserRole::System)
    }
    
    /// Check if user can access a specific table
    pub fn can_access_table(&self, table_owner: &UserId, table_type: TableType, table_access: Option<TableAccess>) -> bool {
        match table_type {
            TableType::User => {
                // User tables: owner or privileged roles
                &self.user_id == table_owner || self.role.can_access_other_users_tables()
            }
            TableType::Shared => {
                // Shared tables: depends on access level
                match table_access {
                    Some(access) => access.can_read(self.role),
                    None => false,  // Should never happen (default is Private)
                }
            }
            TableType::System => {
                // System tables: privileged roles only
                matches!(self.role, UserRole::Dba | UserRole::System)
            }
        }
    }
    
    /// Check if this is a system user connecting from localhost
    pub fn is_localhost_system_user(&self) -> bool {
        matches!(self.role, UserRole::System) && self.connection_info.is_localhost
    }
}
```

---

### 5. ConnectionInfo

**Purpose**: Captures connection source for security decisions (localhost vs remote)

#### Schema

| Field | Type | Description |
|-------|------|-------------|
| `remote_addr` | IpAddr | Client IP address |
| `is_localhost` | bool | True if connection is from localhost |

#### Rust Implementation

```rust
use std::net::IpAddr;

#[derive(Debug, Clone)]
pub struct ConnectionInfo {
    pub remote_addr: IpAddr,
    pub is_localhost: bool,
}

impl ConnectionInfo {
    pub fn new(remote_addr: IpAddr) -> Self {
        let is_localhost = match remote_addr {
            IpAddr::V4(addr) => addr.is_loopback(),  // 127.0.0.0/8
            IpAddr::V6(addr) => addr.is_loopback(),  // ::1
        };
        
        Self {
            remote_addr,
            is_localhost,
        }
    }
    
    /// Check if connection is from localhost
    pub fn is_local(&self) -> bool {
        self.is_localhost
    }
    
    /// For audit logging
    pub fn to_string(&self) -> String {
        if self.is_localhost {
            "localhost".to_string()
        } else {
            self.remote_addr.to_string()
        }
    }
}
```

#### Localhost Detection

**IPv4 Loopback**: `127.0.0.1` to `127.255.255.255` (127.0.0.0/8)  
**IPv6 Loopback**: `::1`  
**Unix Sockets**: Treated as localhost (no IP address)

---

## Relationships

```
┌──────────────┐
│    User      │
└──────┬───────┘
       │
       │ 1:N (owns)
       ▼
┌──────────────┐
│  User Tables │
│  (TableType  │
│   = User)    │
└──────────────┘

┌──────────────┐
│    User      │
└──────┬───────┘
       │
       │ role (UserRole enum)
       ▼
┌──────────────────────┐
│  Permission Matrix   │
│  (RBAC rules)        │
└──────────────────────┘

┌──────────────┐
│ Shared Table │
└──────┬───────┘
       │
       │ access (TableAccess enum)
       ▼
┌──────────────────────┐
│  Access Control      │
│  (read/write rules)  │
└──────────────────────┘

┌──────────────┐
│ HTTP Request │
└──────┬───────┘
       │
       │ authenticated_user
       ▼
┌──────────────────┐
│ AuthenticatedUser│
│ + ConnectionInfo │
└──────────────────┘
```

### Foreign Keys

- `User.storage_id` → `system.storages.storage_id` (optional)
- User tables have implicit FK: `owner_id` (UserId) → `system.users.user_id`

### Indexes for Performance

1. **user_by_username**: Secondary index for username lookups
   - Key: `{username}`
   - Value: `{user_id}`
   - Used during authentication

2. **users_by_role**: Secondary index for role filtering
   - Key: `{role}:{user_id}`
   - Value: `{user_id}`
   - Used for admin queries (list all DBAs, etc.)

3. **active_users**: Filter index for non-deleted users
   - Implemented via query filter: `WHERE deleted_at IS NULL`
   - Used for default user listings

---

## Storage Implementation

### RocksDB Column Families

1. **`system_users`**: Primary user storage
   - Key: `{user_id}` (UserId format: `{prefix}_{snowflake}`)
   - Value: JSON-serialized User struct

2. **`user_by_username_index`**: Username → user_id mapping
   - Key: `{username}` (UserName)
   - Value: `{user_id}` (UserId string)
   - Ensures username uniqueness

3. **Existing `system_tables`**: Enhanced with `access` column
   - Add nullable `access` field for shared tables
   - NULL for user/system tables, enum value for shared tables

### Database Initialization

**Default Users Created on Initialization**:

```rust
/// Initialize database with default system and admin users
pub async fn initialize_database(&self) -> Result<(), Error> {
    // 1. Create system user for CLI access (localhost-only)
    let system_user = self.create_user(
        UserName::new("cli_system")?,
        UserRole::System,
        AuthType::Internal,
        None,  // No credentials (localhost-only)
        None,  // No email
    ).await?;
    
    info!("Created system user: {} ({})", system_user.username, system_user.user_id);
    // Example: sys_456789012345678
    
    // 2. Create initial DBA user (if credentials provided via env/config)
    if let Some(admin_password) = std::env::var("KALAMDB_ADMIN_PASSWORD").ok() {
        let admin_username = std::env::var("KALAMDB_ADMIN_USERNAME")
            .unwrap_or_else(|_| "admin".to_string());
        
        let password_hash = hash_password(&admin_password).await?;
        
        let dba_user = self.create_user(
            UserName::new(&admin_username)?,
            UserRole::Dba,
            AuthType::Password,
            Some(password_hash),
            None,
        ).await?;
        
        info!("Created DBA user: {} ({})", dba_user.username, dba_user.user_id);
        // Example: dba_123456789012345
    } else {
        warn!("No KALAMDB_ADMIN_PASSWORD provided - DBA user not created");
        warn!("Run: export KALAMDB_ADMIN_PASSWORD='your-secure-password'");
    }
    
    Ok(())
}
```

**Environment Variables**:
- `KALAMDB_ADMIN_USERNAME` (optional, default: "admin")
- `KALAMDB_ADMIN_PASSWORD` (required for DBA creation)

### Example RocksDB Operations

**Create User**:
```rust
/// Create new user with auto-generated UserId
pub async fn create_user(
    &self,
    username: UserName,
    role: UserRole,
    auth_type: AuthType,
    auth_data: Option<String>,
    email: Option<String>,
) -> Result<User, Error> {
    // 1. Generate UserId with role-based prefix
    let user_id = UserId::generate(role);
    
    // 2. Check username uniqueness
    if self.db.get_cf(&self.cf_username_index, username.as_str())?.is_some() {
        return Err(Error::DuplicateUsername);
    }
    
    // 3. Create user record
    let now = Utc::now();
    let user = User {
        user_id: user_id.clone(),
        username: username.clone(),
        email,
        auth_type,
        auth_data,
        role,
        storage_mode: None,
        storage_id: None,
        metadata: serde_json::Value::Object(serde_json::Map::new()),
        created_at: now,
        updated_at: now,
        last_seen: None,
        deleted_at: None,
    };
    
    // 4. Store user record
    let user_json = serde_json::to_string(&user)?;
    self.db.put_cf(&self.cf_system_users, user_id.as_str(), user_json)?;
    
    // 5. Create username index
    self.db.put_cf(&self.cf_username_index, username.as_str(), user_id.as_str())?;
    
    Ok(user)
}
```

**Lookup by Username** (for authentication):
```rust
// 1. Get user_id from index
let user_id_str = self.db.get_cf(&self.cf_username_index, username.as_str())?
    .ok_or(Error::UserNotFound)?;
let user_id = UserId::from_str(&String::from_utf8(user_id_str)?)?;

// 2. Get user record
let user_json = self.db.get_cf(&self.cf_system_users, user_id.as_str())?
    .ok_or(Error::UserNotFound)?;

// 3. Deserialize
let user: User = serde_json::from_slice(&user_json)?;
```

**Soft Delete User**:
```rust
// 1. Load user
let mut user: User = self.load_user(&user_id).await?;

// 2. Set deleted_at
user.deleted_at = Some(Utc::now());
user.updated_at = Utc::now();

// 3. Save back
let user_json = serde_json::to_string(&user)?;
self.db.put_cf(&self.cf_system_users, user.user_id.as_str(), user_json)?;

// Note: Username index remains for conflict detection
```

**Update last_seen (Daily Granularity)**:
```rust
use chrono::{Utc, NaiveDate};

/// Update last_seen only if the current date is different
pub async fn update_last_seen(&self, user_id: &UserId) -> Result<(), Error> {
    // 1. Load user
    let mut user: User = self.load_user(user_id).await?;
    
    // 2. Get today's date (no time component)
    let today = Utc::now().date_naive();
    
    // 3. Check if last_seen is already today
    let needs_update = match user.last_seen {
        Some(last_date) => {
            // Parse stored date (format: "2025-10-27")
            let last_seen_date = NaiveDate::parse_from_str(&last_date, "%Y-%m-%d")?;
            last_seen_date != today
        }
        None => true,  // Never set before
    };
    
    // 4. Update only if date changed (once per day)
    if needs_update {
        user.last_seen = Some(today.format("%Y-%m-%d").to_string());
        user.updated_at = Utc::now();
        
        let user_json = serde_json::to_string(&user)?;
        self.db.put_cf(&self.cf_system_users, user.user_id.as_str(), user_json)?;
        
        // Optional: Invalidate user cache
        self.user_cache.invalidate_user(&user.user_id, &user.username).await;
    }
    
    Ok(())
}
```

**Integration with Authentication Middleware**:
```rust
impl AuthService {
    pub async fn authenticate(
        &self,
        auth_header: Option<&str>,
        connection_info: ConnectionInfo,
    ) -> Result<AuthenticatedUser, AuthError> {
        // 1. Perform authentication (Basic Auth or JWT)
        let authenticated_user = self.do_authenticate(auth_header, connection_info).await?;
        
        // 2. Update last_seen asynchronously (fire-and-forget)
        let user_id = authenticated_user.user_id.clone();
        let service = self.clone();
        tokio::spawn(async move {
            if let Err(e) = service.update_last_seen(&user_id).await {
                warn!("Failed to update last_seen for user {}: {}", user_id, e);
            }
        });
        
        // 3. Return authenticated user immediately (don't block on update)
        Ok(authenticated_user)
    }
}
```

**Why Fire-and-Forget?**
- Authentication must be fast (<50ms target)
- last_seen update is non-critical (audit/cleanup only)
- Update happens asynchronously in background
- Failure doesn't block user access
- Only 1 write per user per day (minimal overhead)

---

## Validation & Constraints Summary

| Entity | Validation Rules |
|--------|------------------|
| **User** | Unique user_id, unique username, valid email format, auth_type enum, role enum, metadata valid JSON |
| **UserRole** | Must be one of 4 variants, serializes to lowercase string |
| **TableAccess** | Must be one of 3 variants, defaults to Private, serializes to lowercase string |
| **AuthenticatedUser** | Created only after successful authentication, destroyed after request |
| **ConnectionInfo** | Valid IP address, localhost detection based on loopback range |

---

## Inactive User Cleanup

### Purpose

The `last_seen` field enables automatic cleanup of inactive users to maintain database hygiene and comply with data retention policies.

### Cleanup Strategy

**Background Job** (runs daily or weekly):

```rust
use chrono::{Utc, Duration};

pub struct InactiveUserCleanup {
    db: Arc<DB>,
    inactivity_threshold_days: i64,
}

impl InactiveUserCleanup {
    pub async fn cleanup_inactive_users(&self) -> Result<CleanupStats, Error> {
        let cutoff_date = (Utc::now() - Duration::days(self.inactivity_threshold_days))
            .date_naive()
            .format("%Y-%m-%d")
            .to_string();
        
        let mut deleted_count = 0;
        let mut warned_count = 0;
        
        // Iterate over all users
        let iter = self.db.iterator_cf(&self.cf_system_users, IteratorMode::Start);
        
        for (user_id_bytes, user_json_bytes) in iter {
            let user: User = serde_json::from_slice(&user_json_bytes)?;
            
            // Skip already deleted users
            if user.deleted_at.is_some() {
                continue;
            }
            
            // Check last_seen date
            let is_inactive = match user.last_seen {
                Some(ref last_seen_str) => last_seen_str < &cutoff_date,
                None => {
                    // Never seen - check created_at instead
                    let created_date = user.created_at.date_naive()
                        .format("%Y-%m-%d")
                        .to_string();
                    created_date < cutoff_date
                }
            };
            
            if is_inactive {
                match self.handle_inactive_user(&user).await? {
                    InactiveAction::Deleted => deleted_count += 1,
                    InactiveAction::Warned => warned_count += 1,
                    InactiveAction::Skipped => {},
                }
            }
        }
        
        Ok(CleanupStats {
            deleted: deleted_count,
            warned: warned_count,
        })
    }
    
    async fn handle_inactive_user(&self, user: &User) -> Result<InactiveAction, Error> {
        // Policy examples:
        
        // 1. Soft delete regular users
        if user.role == UserRole::User {
            self.soft_delete_user(&user.user_id).await?;
            info!("Soft-deleted inactive user: {} (last_seen: {:?})", 
                  user.username, user.last_seen);
            return Ok(InactiveAction::Deleted);
        }
        
        // 2. Send warning email for service accounts
        if user.role == UserRole::Service {
            self.send_inactivity_warning(&user).await?;
            warn!("Service account inactive: {} (last_seen: {:?})", 
                  user.username, user.last_seen);
            return Ok(InactiveAction::Warned);
        }
        
        // 3. Skip DBAs and system users (never auto-delete)
        if matches!(user.role, UserRole::Dba | UserRole::System) {
            return Ok(InactiveAction::Skipped);
        }
        
        Ok(InactiveAction::Skipped)
    }
}

enum InactiveAction {
    Deleted,
    Warned,
    Skipped,
}
```

### Configuration

```toml
[authentication.inactive_cleanup]
# Enable automatic inactive user cleanup (default: false)
enabled = false

# Days of inactivity before action (default: 180 = 6 months)
inactivity_threshold_days = 180

# Cleanup job schedule (cron format, default: daily at 2 AM)
schedule = "0 2 * * *"

# Action per role
# Options: "delete" (soft delete), "warn" (send notification), "skip" (no action)
user_action = "delete"
service_action = "warn"
dba_action = "skip"
system_action = "skip"

# Send warning email N days before deletion (default: 30)
warning_period_days = 30
```

### Queries for Manual Cleanup

**Find users inactive for 6+ months**:
```sql
SELECT user_id, username, role, last_seen, created_at
FROM system.users
WHERE deleted_at IS NULL
  AND (
    last_seen < DATE('now', '-180 days')
    OR (last_seen IS NULL AND created_at < DATE('now', '-180 days'))
  )
ORDER BY last_seen ASC NULLS FIRST;
```

**Count inactive users by role**:
```sql
SELECT role, COUNT(*) as inactive_count
FROM system.users
WHERE deleted_at IS NULL
  AND last_seen < DATE('now', '-180 days')
GROUP BY role;
```

**Find users who never logged in**:
```sql
SELECT user_id, username, role, created_at
FROM system.users
WHERE deleted_at IS NULL
  AND last_seen IS NULL
ORDER BY created_at DESC;
```

---

## Data Model Completeness Checklist

- [x] All entities from spec.md defined
- [x] Schema with fields, types, constraints documented
- [x] Enums with variants and serialization rules
- [x] Relationships between entities mapped
- [x] Validation rules specified
- [x] Storage implementation approach defined (RocksDB)
- [x] Indexes for performance identified
- [x] Example records provided
- [x] State transitions documented (User lifecycle)
- [x] Foreign keys identified
- [x] Access control matrix defined (UserRole + TableAccess)

**Status**: ✅ Ready for contract definition
