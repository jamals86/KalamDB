//! WebSocket message protocol for KalamDB live query subscriptions
//!
//! This module defines the complete WebSocket message protocol between clients and server
//! for real-time query subscriptions with batched initial data loading.
//!
//! # Protocol Flow
//!
//! ## 1. Client Subscription Request
//! ```json
//! {
//!   "type": "subscribe",
//!   "subscriptions": [{
//!     "id": "sub-1",
//!     "sql": "SELECT * FROM messages WHERE user_id = CURRENT_USER()",
//!     "options": {}
//!   }]
//! }
//! ```
//!
//! ## 2. Server Subscription Acknowledgement
//! ```json
//! {
//!   "type": "subscription_ack",
//!   "subscription_id": "sub-1",
//!   "total_rows": 5000,
//!   "batch_control": {
//!     "batch_num": 0,
//!     "has_more": true,
//!     "status": "loading"
//!   }
//! }
//! ```
//!
//! ## 3. Server Initial Data Batch (First Batch)
//! ```json
//! {
//!   "type": "initial_data_batch",
//!   "subscription_id": "sub-1",
//!   "rows": [{"id": 1, "message": "Hello"}, ...],
//!   "batch_control": {
//!     "batch_num": 0,
//!     "has_more": true,
//!     "status": "loading"
//!   }
//! }
//! ```
//!
//! ## 4. Client Next Batch Request
//! ```json
//! {
//!   "type": "next_batch",
//!   "subscription_id": "sub-1",
//!   "last_seq_id": 1000
//! }
//! ```
//!
//! ## 5. Server Subsequent Batch
//! ```json
//! {
//!   "type": "initial_data_batch",
//!   "subscription_id": "sub-1",
//!   "rows": [{"id": 1001, "message": "World"}, ...],
//!   "batch_control": {
//!     "batch_num": 1,
//!     "has_more": true,
//!     "status": "loading_batch"
//!   }
//! }
//! ```
//!
//! ## 6. Server Final Batch
//! ```json
//! {
//!   "type": "initial_data_batch",
//!   "subscription_id": "sub-1",
//!   "rows": [{"id": 4501, "message": "Done"}, ...],
//!   "batch_control": {
//!     "batch_num": 4,
//!     "has_more": false,
//!     "status": "ready"
//!   }
//! }
//! ```
//!
//! ## 7. Real-time Change Notifications (After Initial Load)
//! ```json
//! {
//!   "type": "change",
//!   "subscription_id": "sub-1",
//!   "change_type": "insert",
//!   "rows": [{"id": 5001, "message": "New"}]
//! }
//! ```

use crate::ids::SeqId;
use crate::schemas::SchemaField;

// Simple Row type for WASM (JSON only)
#[cfg(feature = "wasm")]
pub type Row = serde_json::Map<String, serde_json::Value>;

use serde::{Deserialize, Serialize};
use serde_json::Value as JsonValue;
use std::collections::HashMap;

/// Type alias for row data in WebSocket messages (column_name -> JSON value)
pub type RowData = HashMap<String, JsonValue>;

/// Batch size in bytes (8KB) for chunking large initial data payloads
pub const BATCH_SIZE_BYTES: usize = 8 * 1024;

/// Maximum rows per batch to prevent memory spikes (default 1000 rows)
pub const MAX_ROWS_PER_BATCH: usize = 1000;

/// WebSocket message types sent from server to client
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum WebSocketMessage {
    /// Authentication successful response
    ///
    /// Sent after client sends Authenticate message with valid credentials.
    /// Client can now send Subscribe/Unsubscribe messages.
    AuthSuccess {
        /// Authenticated user ID
        user_id: String,
        /// User role
        role: String,
    },

    /// Authentication failed response
    ///
    /// Sent when authentication fails. Connection will be closed immediately.
    AuthError {
        /// Error message describing why authentication failed
        message: String,
    },

    /// Acknowledgement of successful subscription registration
    ///
    /// Sent immediately after client subscribes, includes total row count
    /// and batch control information for paginated initial data loading.
    SubscriptionAck {
        /// The subscription ID that was registered
        subscription_id: String,
        /// Total number of rows available for initial load
        total_rows: u32,
        /// Batch control information for paginated loading
        batch_control: BatchControl,
        /// Schema describing the columns in the subscription result
        /// Contains column name, data type (KalamDataType), and index for each field
        schema: Vec<SchemaField>,
    },

    /// Initial data batch sent after subscription or on client request
    ///
    /// Sent automatically for the first batch after subscription acknowledgement,
    /// then sent on-demand when client requests via ClientMessage::NextBatch.
    InitialDataBatch {
        /// The subscription ID this data is for
        subscription_id: String,
        /// The rows in this batch
        rows: Vec<RowData>,
        /// Batch control information
        batch_control: BatchControl,
    },

    /// Change notification (delegates to Notification enum)
    ///
    /// Sent when data changes (INSERT/UPDATE/DELETE) after initial load completes.
    /// Only sent when batch_control.status == Ready.
    #[serde(untagged)]
    Notification(Notification),
}

/// Authentication credentials for WebSocket connection
///
/// This enum is the **client-facing** authentication model for WebSocket connections.
/// It maps 1:1 with `AuthRequest` variants in `kalamdb-auth` via the `From` impl.
///
/// # Supported Methods
///
/// - `Basic` - Username/password authentication
/// - `Jwt` - JWT token (Bearer) authentication
///
/// # JSON Wire Format
///
/// ```json
/// // Basic Auth
/// {"type": "authenticate", "method": "basic", "username": "alice", "password": "secret"}
///
/// // JWT Auth  
/// {"type": "authenticate", "method": "jwt", "token": "eyJhbGciOiJIUzI1NiIs..."}
/// ```
///
/// # Adding a New Authentication Method
///
/// 1. Add variant here with appropriate fields
/// 2. Add corresponding variant to `AuthRequest` in `kalamdb-auth/unified.rs`
/// 3. Update `From<WsAuthCredentials> for AuthRequest` impl
/// 4. Update client SDKs (TypeScript `Auth` class, WASM `WasmAuthProvider`)
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(tag = "method", rename_all = "snake_case")]
pub enum WsAuthCredentials {
    /// Username and password authentication
    Basic {
        username: String,
        password: String,
    },
    /// JWT token authentication
    Jwt {
        token: String,
    },
    // Future auth methods can be added here:
    // ApiKey { key: String },
    // OAuth { provider: String, token: String },
}

/// Client-to-server request messages
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ClientMessage {
    /// Authenticate WebSocket connection
    ///
    /// Client sends this immediately after establishing WebSocket connection.
    /// Server must receive this within 3 seconds or connection will be closed.
    /// Server responds with AuthSuccess or AuthError.
    ///
    /// Supports multiple authentication methods via the `credentials` field.
    Authenticate {
        /// Authentication credentials (basic, jwt, or future methods)
        #[serde(flatten)]
        credentials: WsAuthCredentials,
    },

    /// Subscribe to live query updates
    ///
    /// Client sends this to register a single subscription.
    /// Server responds with SubscriptionAck followed by InitialDataBatch.
    Subscribe {
        /// Subscription to register
        subscription: SubscriptionRequest,
    },

    /// Request next batch of initial data
    ///
    /// Client sends this after processing a batch to request the next batch.
    /// Server responds with InitialDataBatch.
    NextBatch {
        /// The subscription ID to fetch the next batch for
        subscription_id: String,
        /// The SeqId of the last row received (for pagination)
        last_seq_id: Option<SeqId>,
    },

    /// Unsubscribe from live query
    ///
    /// Client sends this to stop receiving updates for a subscription.
    Unsubscribe {
        /// The subscription ID to unsubscribe from
        subscription_id: String,
    },
}

/// Subscription request details
///
/// This is a client-only struct representing the subscription request.
/// Server-side metadata (table_id, filter_expr, projections, etc.) is stored
/// in SubscriptionState within ConnectionState.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubscriptionRequest {
    /// Unique subscription identifier (client-generated)
    pub id: String,
    /// SQL query for live updates (must be a SELECT statement)
    pub sql: String,
    /// Optional subscription options
    #[serde(default)]
    pub options: SubscriptionOptions,
}

/// Options for live query subscriptions
///
/// These options control individual subscription behavior including:
/// - Initial data loading (batch_size, last_rows)
/// - Data resumption after reconnection (from_seq_id)
///
/// Used by both SQL SUBSCRIBE TO command and WebSocket subscribe messages.
#[derive(Debug, Clone, Default, Serialize, Deserialize, PartialEq)]
pub struct SubscriptionOptions {
    /// Hint for server-side batch sizing during initial data load
    /// Default: server-configured (typically 1000 rows per batch)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub batch_size: Option<usize>,

    /// Number of last (newest) rows to fetch for initial data
    /// Default: None (fetch all matching rows)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_rows: Option<u32>,

    /// Resume subscription from a specific sequence ID
    /// When set, the server will only send changes after this seq_id
    /// Typically set automatically during reconnection to resume from last received event
    #[serde(skip_serializing_if = "Option::is_none")]
    pub from_seq_id: Option<SeqId>,
}

/// Batch control metadata for paginated initial data loading
///
/// Tracks the progress of batched initial data loading to prevent
/// overwhelming clients with large payloads (e.g., 1MB+).
///
/// Note: We don't include total_batches because we can't know it upfront
/// without counting all rows first (expensive). The `has_more` field is
/// sufficient for clients to know whether to request more batches.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub struct BatchControl {
    /// Current batch number (0-indexed)
    pub batch_num: u32,

    /// Whether more batches are available to fetch
    pub has_more: bool,

    /// Loading status for the subscription
    pub status: BatchStatus,

    /// The SeqId of the last row in this batch (used for next request)
    pub last_seq_id: Option<SeqId>,

    /// The snapshot boundary (max SeqId at start of load)
    pub snapshot_end_seq: Option<SeqId>,
}

/// Status of the initial data loading process
///
/// Transitions: Loading → LoadingBatch → Ready
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum BatchStatus {
    /// Initial batch being loaded (batch_num == 0)
    Loading,

    /// Subsequent batches being loaded (batch_num > 0, has_more == true)
    LoadingBatch,

    /// All initial data has been loaded, live updates active (has_more == false)
    Ready,
}

/// Notification message sent to clients for live query updates
///
/// # Example Initial Data
/// ```json
/// {
///   "type": "initial_data",
///   "subscription_id": "sub-1",
///   "rows": [
///     {"id": 1, "message": "Hello"},
///     {"id": 2, "message": "World"}
///   ]
/// }
/// ```
///
/// # Example Change Notification (INSERT)
/// ```json
/// {
///   "type": "change",
///   "subscription_id": "sub-1",
///   "change_type": "insert",
///   "rows": [
///     {"id": 3, "message": "New message"}
///   ]
/// }
/// ```
///
/// # Example Change Notification (UPDATE)
/// ```json
/// {
///   "type": "change",
///   "subscription_id": "sub-1",
///   "change_type": "update",
///   "rows": [
///     {"id": 2, "message": "Updated message"}
///   ],
///   "old_values": [
///     {"id": 2, "message": "World"}
///   ]
/// }
/// ```
///
/// # Example Change Notification (DELETE)
/// ```json
/// {
///   "type": "change",
///   "subscription_id": "sub-1",
///   "change_type": "delete",
///   "old_values": [
///     {"id": 1, "message": "Hello"}
///   ]
/// }
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Notification {
    /// Change notification for INSERT/UPDATE/DELETE operations
    ///
    /// Sent only after initial data loading is complete (batch_control.status == Ready).
    Change {
        /// The subscription ID this notification is for
        subscription_id: String,

        /// Type of change that occurred
        change_type: ChangeType,

        /// New/current row values (for INSERT and UPDATE)
        #[serde(skip_serializing_if = "Option::is_none")]
        rows: Option<Vec<RowData>>,

        /// Previous row values (for UPDATE and DELETE)
        #[serde(skip_serializing_if = "Option::is_none")]
        old_values: Option<Vec<RowData>>,
    },

    /// Error notification (e.g., subscription query failed)
    Error {
        /// The subscription ID this error is for
        subscription_id: String,

        /// Error code
        code: String,

        /// Error message
        message: String,
    },
}

/// Type of change that occurred in the database
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum ChangeType {
    /// New row(s) inserted
    Insert,

    /// Existing row(s) updated
    Update,

    /// Row(s) deleted
    Delete,
}


impl WebSocketMessage {
    /// Create a subscription acknowledgement message with batch control and schema
    pub fn subscription_ack(
        subscription_id: String,
        total_rows: u32,
        batch_control: BatchControl,
        schema: Vec<SchemaField>,
    ) -> Self {
        Self::SubscriptionAck {
            subscription_id,
            total_rows,
            batch_control,
            schema,
        }
    }

    /// Create an initial data batch message
    pub fn initial_data_batch(
        subscription_id: String,
        rows: Vec<RowData>,
        batch_control: BatchControl,
    ) -> Self {
        Self::InitialDataBatch {
            subscription_id,
            rows,
            batch_control,
        }
    }
}

impl ClientMessage {
    /// Create a subscribe message for a single subscription
    pub fn subscribe(subscription: SubscriptionRequest) -> Self {
        Self::Subscribe { subscription }
    }

    /// Create a next batch request message
    pub fn next_batch(subscription_id: String, last_seq_id: Option<SeqId>) -> Self {
        Self::NextBatch {
            subscription_id,
            last_seq_id,
        }
    }

    /// Create an unsubscribe message
    pub fn unsubscribe(subscription_id: String) -> Self {
        Self::Unsubscribe { subscription_id }
    }
}

impl BatchControl {
    /// Create a batch control for the first batch (batch_num=0)
    ///
    /// # Arguments
    /// * `has_more` - Whether there are more batches to fetch after this one
    pub fn first(has_more: bool) -> Self {
        Self {
            batch_num: 0,
            has_more,
            status: if has_more { BatchStatus::Loading } else { BatchStatus::Ready },
            last_seq_id: None,
            snapshot_end_seq: None,
        }
    }

    /// Create a batch control for a subsequent batch (batch_num > 0)
    ///
    /// # Arguments
    /// * `batch_num` - The current batch number (0-indexed)
    /// * `has_more` - Whether there are more batches to fetch after this one
    pub fn subsequent(batch_num: u32, has_more: bool) -> Self {
        Self {
            batch_num,
            has_more,
            status: if has_more { BatchStatus::LoadingBatch } else { BatchStatus::Ready },
            last_seq_id: None,
            snapshot_end_seq: None,
        }
    }

    /// Create batch control with all fields specified
    pub fn new(
        batch_num: u32,
        has_more: bool,
        last_seq_id: Option<SeqId>,
        snapshot_end_seq: Option<SeqId>,
    ) -> Self {
        let status = if batch_num == 0 {
            if has_more { BatchStatus::Loading } else { BatchStatus::Ready }
        } else {
            if has_more { BatchStatus::LoadingBatch } else { BatchStatus::Ready }
        };

        Self {
            batch_num,
            has_more,
            status,
            last_seq_id,
            snapshot_end_seq,
        }
    }
}

impl Notification {
    /// Create an INSERT change notification
    pub fn insert(subscription_id: String, rows: Vec<RowData>) -> Self {
        Self::Change {
            subscription_id,
            change_type: ChangeType::Insert,
            rows: Some(rows),
            old_values: None,
        }
    }

    /// Create an UPDATE change notification
    pub fn update(subscription_id: String, new_rows: Vec<RowData>, old_rows: Vec<RowData>) -> Self {
        Self::Change {
            subscription_id,
            change_type: ChangeType::Update,
            rows: Some(new_rows),
            old_values: Some(old_rows),
        }
    }

    /// Create a DELETE change notification
    pub fn delete(subscription_id: String, old_rows: Vec<RowData>) -> Self {
        Self::Change {
            subscription_id,
            change_type: ChangeType::Delete,
            rows: None,
            old_values: Some(old_rows),
        }
    }

    /// Create an error notification
    pub fn error(subscription_id: String, code: String, message: String) -> Self {
        Self::Error {
            subscription_id,
            code,
            message,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::models::Row;
    use datafusion::scalar::ScalarValue;
    use std::collections::BTreeMap;

    fn create_test_row(id: i64, message: &str) -> Row {
        let mut values = BTreeMap::new();
        values.insert("id".to_string(), ScalarValue::Int64(Some(id)));
        values.insert(
            "message".to_string(),
            ScalarValue::Utf8(Some(message.to_string())),
        );
        Row::new(values)
    }
    
    fn row_to_test_json(row: &Row) -> HashMap<String, JsonValue> {
        // Simple conversion for tests - convert ScalarValue to JSON
        row.values.iter().map(|(k, v)| {
            let json_val = match v {
                ScalarValue::Int64(Some(i)) => JsonValue::String(i.to_string()),
                ScalarValue::Utf8(Some(s)) => JsonValue::String(s.clone()),
                _ => JsonValue::Null,
            };
            (k.clone(), json_val)
        }).collect()
    }

    #[test]
    fn test_client_message_serialization() {
        use crate::websocket::{ClientMessage, SubscriptionOptions, SubscriptionRequest};

        let msg = ClientMessage::subscribe(SubscriptionRequest {
            id: "sub-1".to_string(),
            sql: "SELECT * FROM messages".to_string(),
            options: SubscriptionOptions::default(),
        });

        let json = serde_json::to_string(&msg).unwrap();
        assert!(json.contains("\"type\":\"subscribe\""));
        assert!(json.contains("sub-1"));
    }

    #[test]
    fn test_next_batch_request() {
        use crate::ids::SeqId;
        use crate::websocket::ClientMessage;

        let msg = ClientMessage::next_batch("sub-1".to_string(), Some(SeqId::new(100)));
        let json = serde_json::to_string(&msg).unwrap();

        assert!(json.contains("\"type\":\"next_batch\""));
        assert!(json.contains("\"last_seq_id\":100"));
    }

    #[test]
    fn test_batch_control_helpers() {
        use crate::websocket::{BatchControl, BatchStatus};

        // First batch with more to come
        let first = BatchControl::first(true);
        assert_eq!(first.batch_num, 0);
        assert!(first.has_more);
        assert_eq!(first.status, BatchStatus::Loading);

        // First batch with no more (single batch)
        let single = BatchControl::first(false);
        assert_eq!(single.batch_num, 0);
        assert!(!single.has_more);
        assert_eq!(single.status, BatchStatus::Ready);

        // Subsequent batch with more to come
        let middle = BatchControl::subsequent(2, true);
        assert_eq!(middle.batch_num, 2);
        assert!(middle.has_more);
        assert_eq!(middle.status, BatchStatus::LoadingBatch);

        // Final batch
        let last = BatchControl::subsequent(4, false);
        assert_eq!(last.batch_num, 4);
        assert!(!last.has_more);
        assert_eq!(last.status, BatchStatus::Ready);
    }

    #[test]
    fn test_insert_notification() {
        let row = create_test_row(1, "Hello");
        let row_json = row_to_test_json(&row);
        let notification = Notification::insert("sub-1".to_string(), vec![row_json]);

        let json = serde_json::to_string(&notification).unwrap();
        assert!(json.contains("change"));
        assert!(json.contains("insert"));
        assert!(json.contains("sub-1"));
        assert!(json.contains("Hello"));
    }

    #[test]
    fn test_update_notification() {
        let new_row = create_test_row(1, "Updated");
        let old_row = create_test_row(1, "Original");
        let new_row_json = row_to_test_json(&new_row);
        let old_row_json = row_to_test_json(&old_row);

        let notification = Notification::update("sub-1".to_string(), vec![new_row_json], vec![old_row_json]);

        let json = serde_json::to_string(&notification).unwrap();
        assert!(json.contains("update"));
        assert!(json.contains("Updated"));
        assert!(json.contains("Original"));
    }

    #[test]
    fn test_delete_notification() {
        let old_row = create_test_row(1, "Hello");
        let old_row_json = row_to_test_json(&old_row);

        let notification = Notification::delete("sub-1".to_string(), vec![old_row_json]);

        let json = serde_json::to_string(&notification).unwrap();
        assert!(json.contains("delete"));
        assert!(json.contains("old_values"));
        assert!(!json.contains("\"rows\""));
    }

    #[test]
    fn test_error_notification() {
        let notification = Notification::error(
            "sub-1".to_string(),
            "INVALID_QUERY".to_string(),
            "Query syntax error".to_string(),
        );

        let json = serde_json::to_string(&notification).unwrap();
        assert!(json.contains("error"));
        assert!(json.contains("INVALID_QUERY"));
    }
}
