//! Arrow type conversion for KalamDataType
//!
//! Provides bidirectional conversion between KalamDataType and Apache Arrow DataType.

use crate::models::types::KalamDataType;
use arrow_schema::DataType as ArrowDataType;
use arrow_schema::{Field, TimeUnit};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ArrowConversionError {
    #[error("Unsupported Arrow type: {0:?}")]
    UnsupportedArrowType(ArrowDataType),
    
    #[error("Invalid EMBEDDING dimension: {0}")]
    InvalidEmbeddingDimension(i32),
    
    #[error("Type conversion failed: {0}")]
    ConversionFailed(String),
}

/// Trait for converting to Arrow DataType
pub trait ToArrowType {
    /// Convert to Arrow DataType
    fn to_arrow_type(&self) -> Result<ArrowDataType, ArrowConversionError>;
}

/// Trait for converting from Arrow DataType
pub trait FromArrowType {
    /// Convert from Arrow DataType
    fn from_arrow_type(arrow_type: &ArrowDataType) -> Result<Self, ArrowConversionError>
    where
        Self: Sized;
}

impl ToArrowType for KalamDataType {
    fn to_arrow_type(&self) -> Result<ArrowDataType, ArrowConversionError> {
        let arrow_type = match self {
            KalamDataType::Boolean => ArrowDataType::Boolean,
            KalamDataType::Int => ArrowDataType::Int32,
            KalamDataType::BigInt => ArrowDataType::Int64,
            KalamDataType::Double => ArrowDataType::Float64,
            KalamDataType::Float => ArrowDataType::Float32,
            KalamDataType::Text => ArrowDataType::Utf8,
            KalamDataType::Timestamp => {
                ArrowDataType::Timestamp(TimeUnit::Microsecond, None)
            }
            KalamDataType::Date => ArrowDataType::Date32,
            KalamDataType::DateTime => {
                // DateTime with timezone stored as Timestamp with UTC
                ArrowDataType::Timestamp(TimeUnit::Microsecond, Some("UTC".into()))
            }
            KalamDataType::Time => ArrowDataType::Time64(TimeUnit::Microsecond),
            KalamDataType::Json => ArrowDataType::Utf8, // JSON stored as UTF-8 string
            KalamDataType::Bytes => ArrowDataType::Binary,
            KalamDataType::Embedding(dim) => {
                // EMBEDDING(N) → FixedSizeList<Float32>
                let field = Field::new("item", ArrowDataType::Float32, false);
                ArrowDataType::FixedSizeList(
                    std::sync::Arc::new(field),
                    *dim as i32,
                )
            }
        };
        
        Ok(arrow_type)
    }
}

impl FromArrowType for KalamDataType {
    fn from_arrow_type(arrow_type: &ArrowDataType) -> Result<Self, ArrowConversionError> {
        let kalam_type = match arrow_type {
            ArrowDataType::Boolean => KalamDataType::Boolean,
            ArrowDataType::Int32 => KalamDataType::Int,
            ArrowDataType::Int64 => KalamDataType::BigInt,
            ArrowDataType::Float64 => KalamDataType::Double,
            ArrowDataType::Float32 => KalamDataType::Float,
            ArrowDataType::Utf8 | ArrowDataType::LargeUtf8 => KalamDataType::Text,
            ArrowDataType::Timestamp(TimeUnit::Microsecond, None) => KalamDataType::Timestamp,
            ArrowDataType::Timestamp(TimeUnit::Microsecond, Some(_)) => KalamDataType::DateTime,
            ArrowDataType::Date32 => KalamDataType::Date,
            ArrowDataType::Time64(TimeUnit::Microsecond) => KalamDataType::Time,
            ArrowDataType::Binary | ArrowDataType::LargeBinary => KalamDataType::Bytes,
            ArrowDataType::FixedSizeList(field, size) => {
                // FixedSizeList<Float32> → EMBEDDING
                if matches!(field.data_type(), ArrowDataType::Float32) {
                    if *size < 1 || *size > 8192 {
                        return Err(ArrowConversionError::InvalidEmbeddingDimension(*size));
                    }
                    KalamDataType::Embedding(*size as usize)
                } else {
                    return Err(ArrowConversionError::UnsupportedArrowType(arrow_type.clone()));
                }
            }
            _ => return Err(ArrowConversionError::UnsupportedArrowType(arrow_type.clone())),
        };
        
        Ok(kalam_type)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_simple_types_round_trip() {
        let types = vec![
            KalamDataType::Boolean,
            KalamDataType::Int,
            KalamDataType::BigInt,
            KalamDataType::Double,
            KalamDataType::Float,
            KalamDataType::Text,
            KalamDataType::Timestamp,
            KalamDataType::Date,
            KalamDataType::DateTime,
            KalamDataType::Time,
            KalamDataType::Bytes,
        ];

        for original in types {
            let arrow = original.to_arrow_type().unwrap();
            let round_trip = KalamDataType::from_arrow_type(&arrow).unwrap();
            assert_eq!(original, round_trip, "Failed round-trip for {:?}", original);
        }
    }

    #[test]
    fn test_embedding_conversion() {
        let dimensions = vec![1, 384, 768, 1536, 3072, 8192];
        
        for dim in dimensions {
            let original = KalamDataType::Embedding(dim);
            let arrow = original.to_arrow_type().unwrap();
            
            // Verify Arrow type structure
            if let ArrowDataType::FixedSizeList(ref field, size) = arrow {
                assert_eq!(size, dim as i32);
                assert!(matches!(field.data_type(), ArrowDataType::Float32));
            } else {
                panic!("Expected FixedSizeList, got {:?}", arrow);
            }
            
            // Round-trip
            let round_trip = KalamDataType::from_arrow_type(&arrow).unwrap();
            assert_eq!(original, round_trip);
        }
    }

    #[test]
    fn test_invalid_embedding_dimension() {
        let invalid_arrow = ArrowDataType::FixedSizeList(
            std::sync::Arc::new(Field::new("item", ArrowDataType::Float32, false)),
            9999,
        );
        
        assert!(KalamDataType::from_arrow_type(&invalid_arrow).is_err());
    }

    #[test]
    fn test_unsupported_arrow_type() {
        let unsupported = ArrowDataType::Decimal128(10, 2);
        assert!(KalamDataType::from_arrow_type(&unsupported).is_err());
    }

    #[test]
    fn test_timestamp_variants() {
        // Timestamp without timezone
        let ts = KalamDataType::Timestamp;
        let arrow = ts.to_arrow_type().unwrap();
        assert!(matches!(
            arrow,
            ArrowDataType::Timestamp(TimeUnit::Microsecond, None)
        ));

        // DateTime with timezone
        let dt = KalamDataType::DateTime;
        let arrow = dt.to_arrow_type().unwrap();
        assert!(matches!(
            arrow,
            ArrowDataType::Timestamp(TimeUnit::Microsecond, Some(_))
        ));
    }
}
