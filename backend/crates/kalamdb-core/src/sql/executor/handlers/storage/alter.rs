//! Typed DDL handler for ALTER STORAGE statements

use crate::app_context::AppContext;
use crate::error::KalamDbError;
use crate::error_extensions::KalamDbResultExt;
use crate::sql::executor::handlers::typed::TypedStatementHandler;
use crate::sql::executor::helpers::guards::require_admin;
use crate::sql::executor::models::{ExecutionContext, ExecutionResult, ScalarValue};
use kalamdb_sql::ddl::AlterStorageStatement;
use std::sync::Arc;

/// Typed handler for ALTER STORAGE statements
pub struct AlterStorageHandler {
    app_context: Arc<AppContext>,
}

impl AlterStorageHandler {
    pub fn new(app_context: Arc<AppContext>) -> Self {
        Self { app_context }
    }
}

#[async_trait::async_trait]
impl TypedStatementHandler<AlterStorageStatement> for AlterStorageHandler {
    async fn execute(
        &self,
        statement: AlterStorageStatement,
        _params: Vec<ScalarValue>,
        _context: &ExecutionContext,
    ) -> Result<ExecutionResult, KalamDbError> {
        let storages_provider = self.app_context.system_tables().storages();
        let storage_registry = self.app_context.storage_registry();

        // Get existing storage
        let storage_id = statement.storage_id.clone();
        let mut storage = storages_provider
            .get_storage_by_id(&storage_id)
            .into_kalamdb_error("Failed to get storage")?
            .ok_or_else(|| {
                KalamDbError::InvalidOperation(format!(
                    "Storage '{}' not found",
                    statement.storage_id.as_str()
                ))
            })?;

        // Update fields if provided
        if let Some(name) = statement.storage_name {
            storage.storage_name = name;
        }

        if let Some(desc) = statement.description {
            storage.description = Some(desc);
        }

        if let Some(shared_template) = statement.shared_tables_template {
            // Validate template before updating
            if !shared_template.is_empty() {
                storage_registry.validate_template(&shared_template, false)?;
            }
            storage.shared_tables_template = shared_template;
        }

        if let Some(user_template) = statement.user_tables_template {
            // Validate template before updating
            if !user_template.is_empty() {
                storage_registry.validate_template(&user_template, true)?;
            }
            storage.user_tables_template = user_template;
        }

        if let Some(raw_config) = statement.config_json {
            let value: serde_json::Value = serde_json::from_str(&raw_config)
                .into_invalid_operation("Invalid config_json")?;

            if !value.is_object() {
                return Err(KalamDbError::InvalidOperation(
                    "CONFIG must be a JSON object".to_string(),
                ));
            }

            storage.config_json = Some(serde_json::to_string(&value)
                .into_invalid_operation("Failed to normalize CONFIG JSON")?);
        }

        // Update timestamp
        storage.updated_at = chrono::Utc::now().timestamp();

        // Save updated storage
        storages_provider
            .update_storage(storage)
            .into_kalamdb_error("Failed to update storage")?;

        // Invalidate storage cache to ensure fresh data on next access
        storage_registry.invalidate(&storage_id);

        Ok(ExecutionResult::Success {
            message: format!("Storage '{}' altered successfully", statement.storage_id),
        })
    }

    async fn check_authorization(
        &self,
        _statement: &AlterStorageStatement,
        context: &ExecutionContext,
    ) -> Result<(), KalamDbError> {
        require_admin(context, "alter storage")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_helpers::{create_test_session, init_test_app_context};
    use kalamdb_commons::models::UserId;
    use kalamdb_commons::system::Storage;
    use kalamdb_commons::{Role, StorageId};
    use std::sync::Arc;

    fn init_app_context() -> Arc<AppContext> {
        init_test_app_context();
        AppContext::get()
    }

    fn create_test_context(role: Role) -> ExecutionContext {
        ExecutionContext::new(UserId::new("test_user"), role, create_test_session())
    }

    #[tokio::test]
    async fn test_alter_storage_authorization() {
        let app_ctx = init_app_context();
        let handler = AlterStorageHandler::new(app_ctx);
        let stmt = AlterStorageStatement {
            storage_id: StorageId::from("test_storage"),
            storage_name: Some("Updated Storage".to_string()),
            description: None,
            shared_tables_template: None,
            user_tables_template: None,
            config_json: None,
        };

        // User role should be denied
        let user_ctx = create_test_context(Role::User);
        let result = handler.check_authorization(&stmt, &user_ctx).await;
        assert!(result.is_err());

        // DBA role should be allowed
        let dba_ctx = create_test_context(Role::Dba);
        let result = handler.check_authorization(&stmt, &dba_ctx).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_alter_storage_success() {
        let app_ctx = init_app_context();

        // First create a storage to alter
        let storages_provider = app_ctx.system_tables().storages();
        let storage_id = format!("test_alter_{}", chrono::Utc::now().timestamp_millis());
        let storage = Storage {
            storage_id: StorageId::from(storage_id.as_str()),
            storage_name: "Original Name".to_string(),
            description: None,
            storage_type: kalamdb_commons::models::StorageType::Filesystem,
            base_directory: "/tmp/test".to_string(),
            credentials: None,
            config_json: None,
            shared_tables_template: String::new(),
            user_tables_template: String::new(),
            created_at: chrono::Utc::now().timestamp(),
            updated_at: chrono::Utc::now().timestamp(),
        };
        storages_provider.insert_storage(storage).unwrap();

        // Now alter it
        let handler = AlterStorageHandler::new(app_ctx);
        let stmt = AlterStorageStatement {
            storage_id: StorageId::from(storage_id.as_str()),
            storage_name: Some("Updated Name".to_string()),
            description: Some("New description".to_string()),
            shared_tables_template: None,
            user_tables_template: None,
            config_json: None,
        };
        let ctx = create_test_context(Role::System);

        let result = handler.execute(stmt, vec![], &ctx).await;

        assert!(result.is_ok());
        if let Ok(ExecutionResult::Success { message }) = result {
            assert!(message.contains(&storage_id));
        }

        // Verify the changes
        let updated = storages_provider
            .get_storage_by_id(&StorageId::from(storage_id.as_str()))
            .unwrap();
        assert!(updated.is_some());
        let updated = updated.unwrap();
        assert_eq!(updated.storage_name, "Updated Name");
        assert_eq!(updated.description, Some("New description".to_string()));
    }
}
