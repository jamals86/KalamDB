// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

#![allow(
    non_camel_case_types,
    unused,
    non_snake_case,
    clippy::needless_return,
    clippy::redundant_closure_call,
    clippy::redundant_closure,
    clippy::useless_conversion,
    clippy::unit_arg,
    clippy::unused_unit,
    clippy::double_parens,
    clippy::let_and_return,
    clippy::too_many_arguments,
    clippy::match_single_binding,
    clippy::clone_on_copy,
    clippy::let_unit_value,
    clippy::deref_addrof,
    clippy::explicit_auto_deref,
    clippy::borrow_deref_ref,
    clippy::needless_borrow
)]

// Section: imports

use crate::api::*;
use flutter_rust_bridge::for_generated::byteorder::{NativeEndian, ReadBytesExt, WriteBytesExt};
use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
use flutter_rust_bridge::{Handler, IntoIntoDart};

// Section: boilerplate

flutter_rust_bridge::frb_generated_boilerplate!(
    default_stream_sink_codec = SseCodec,
    default_rust_opaque = RustOpaqueMoi,
    default_rust_auto_opaque = RustAutoOpaqueMoi,
);
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_VERSION: &str = "2.11.1";
pub(crate) const FLUTTER_RUST_BRIDGE_CODEGEN_CONTENT_HASH: i32 = 610288464;

// Section: executor

flutter_rust_bridge::frb_generated_default_handler!();

// Section: wire_funcs

fn wire__crate__api__dart_check_setup_status_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_check_setup_status",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_client_guard = api_client_guard.unwrap();
                        let output_ok =
                            crate::api::dart_check_setup_status(&*api_client_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_connection_events_enabled_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_connection_events_enabled",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_client_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_client,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => api_client_guard = Some(api_client.lockable_decode_sync_ref()),
                        _ => unreachable!(),
                    }
                }
                let api_client_guard = api_client_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::dart_connection_events_enabled(
                    &*api_client_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__dart_create_client_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_create_client",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_base_url = <String>::sse_decode(&mut deserializer);
            let api_auth = <crate::models::DartAuthProvider>::sse_decode(&mut deserializer);
            let api_timeout_ms = <Option<i64>>::sse_decode(&mut deserializer);
            let api_max_retries = <Option<i32>>::sse_decode(&mut deserializer);
            let api_enable_connection_events = <Option<bool>>::sse_decode(&mut deserializer);
            let api_disable_compression = <Option<bool>>::sse_decode(&mut deserializer);
            let api_keepalive_interval_ms = <Option<i64>>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let output_ok = crate::api::dart_create_client(
                        api_base_url,
                        api_auth,
                        api_timeout_ms,
                        api_max_retries,
                        api_enable_connection_events,
                        api_disable_compression,
                        api_keepalive_interval_ms,
                    )?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}
fn wire__crate__api__dart_execute_query_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_execute_query",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            let api_sql = <String>::sse_decode(&mut deserializer);
            let api_params_json = <Option<String>>::sse_decode(&mut deserializer);
            let api_namespace = <Option<String>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_client_guard = api_client_guard.unwrap();
                        let output_ok = crate::api::dart_execute_query(
                            &*api_client_guard,
                            api_sql,
                            api_params_json,
                            api_namespace,
                        )
                        .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_health_check_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_health_check",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_client_guard = api_client_guard.unwrap();
                        let output_ok = crate::api::dart_health_check(&*api_client_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_login_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_login",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            let api_username = <String>::sse_decode(&mut deserializer);
            let api_password = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_client_guard = api_client_guard.unwrap();
                        let output_ok =
                            crate::api::dart_login(&*api_client_guard, api_username, api_password)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_next_connection_event_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_next_connection_event",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_client_guard = api_client_guard.unwrap();
                        let output_ok =
                            crate::api::dart_next_connection_event(&*api_client_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_refresh_token_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_refresh_token",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            let api_refresh_token = <String>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_client_guard = api_client_guard.unwrap();
                        let output_ok =
                            crate::api::dart_refresh_token(&*api_client_guard, api_refresh_token)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_server_setup_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_server_setup",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            let api_request =
                <crate::models::DartServerSetupRequest>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_client_guard = api_client_guard.unwrap();
                        let output_ok =
                            crate::api::dart_server_setup(&*api_client_guard, api_request).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_subscribe_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_subscribe",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            let api_sql = <String>::sse_decode(&mut deserializer);
            let api_config =
                <Option<crate::models::DartSubscriptionConfig>>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_client_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_client,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_client_guard =
                                        Some(api_client.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_client_guard = api_client_guard.unwrap();
                        let output_ok =
                            crate::api::dart_subscribe(&*api_client_guard, api_sql, api_config)
                                .await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_subscription_close_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_subscription_close",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_subscription = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_subscription_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_subscription,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_subscription_guard =
                                        Some(api_subscription.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_subscription_guard = api_subscription_guard.unwrap();
                        let output_ok =
                            crate::api::dart_subscription_close(&*api_subscription_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_subscription_id_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_subscription_id",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_subscription = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, ()>((move || {
                let mut api_subscription_guard = None;
                let decode_indices_ =
                    flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                        flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                            &api_subscription,
                            0,
                            false,
                        ),
                    ]);
                for i in decode_indices_ {
                    match i {
                        0 => {
                            api_subscription_guard =
                                Some(api_subscription.lockable_decode_sync_ref())
                        },
                        _ => unreachable!(),
                    }
                }
                let api_subscription_guard = api_subscription_guard.unwrap();
                let output_ok = Result::<_, ()>::Ok(crate::api::dart_subscription_id(
                    &*api_subscription_guard,
                ))?;
                Ok(output_ok)
            })())
        },
    )
}
fn wire__crate__api__dart_subscription_next_impl(
    port_: flutter_rust_bridge::for_generated::MessagePort,
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_async::<flutter_rust_bridge::for_generated::SseCodec, _, _, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_subscription_next",
            port: Some(port_),
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Normal,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_subscription = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>,
            >>::sse_decode(&mut deserializer);
            deserializer.end();
            move |context| async move {
                transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                    (move || async move {
                        let mut api_subscription_guard = None;
                        let decode_indices_ =
                            flutter_rust_bridge::for_generated::lockable_compute_decode_order(
                                vec![flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                    &api_subscription,
                                    0,
                                    false,
                                )],
                            );
                        for i in decode_indices_ {
                            match i {
                                0 => {
                                    api_subscription_guard =
                                        Some(api_subscription.lockable_decode_async_ref().await)
                                },
                                _ => unreachable!(),
                            }
                        }
                        let api_subscription_guard = api_subscription_guard.unwrap();
                        let output_ok =
                            crate::api::dart_subscription_next(&*api_subscription_guard).await?;
                        Ok(output_ok)
                    })()
                    .await,
                )
            }
        },
    )
}
fn wire__crate__api__dart_update_auth_impl(
    ptr_: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len_: i32,
    data_len_: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    FLUTTER_RUST_BRIDGE_HANDLER.wrap_sync::<flutter_rust_bridge::for_generated::SseCodec, _>(
        flutter_rust_bridge::for_generated::TaskInfo {
            debug_name: "dart_update_auth",
            port: None,
            mode: flutter_rust_bridge::for_generated::FfiCallMode::Sync,
        },
        move || {
            let message = unsafe {
                flutter_rust_bridge::for_generated::Dart2RustMessageSse::from_wire(
                    ptr_,
                    rust_vec_len_,
                    data_len_,
                )
            };
            let mut deserializer =
                flutter_rust_bridge::for_generated::SseDeserializer::new(message);
            let api_client = <RustOpaqueMoi<
                flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
            >>::sse_decode(&mut deserializer);
            let api_auth = <crate::models::DartAuthProvider>::sse_decode(&mut deserializer);
            deserializer.end();
            transform_result_sse::<_, flutter_rust_bridge::for_generated::anyhow::Error>(
                (move || {
                    let mut api_client_guard = None;
                    let decode_indices_ =
                        flutter_rust_bridge::for_generated::lockable_compute_decode_order(vec![
                            flutter_rust_bridge::for_generated::LockableOrderInfo::new(
                                &api_client,
                                0,
                                true,
                            ),
                        ]);
                    for i in decode_indices_ {
                        match i {
                            0 => api_client_guard = Some(api_client.lockable_decode_sync_ref_mut()),
                            _ => unreachable!(),
                        }
                    }
                    let mut api_client_guard = api_client_guard.unwrap();
                    let output_ok = crate::api::dart_update_auth(&mut *api_client_guard, api_auth)?;
                    Ok(output_ok)
                })(),
            )
        },
    )
}

// Section: related_funcs

flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>
);
flutter_rust_bridge::frb_generated_moi_arc_impl_value!(
    flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>
);

// Section: dart2rust

impl SseDecode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <String>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::anyhow::anyhow!("{}", inner);
    }
}

impl SseDecode for DartKalamClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode for DartSubscription {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <RustOpaqueMoi<
            flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>,
        >>::sse_decode(deserializer);
        return flutter_rust_bridge::for_generated::rust_auto_opaque_decode_owned(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <usize>::sse_decode(deserializer);
        return decode_rust_opaque_moi(inner);
    }
}

impl SseDecode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut inner = <Vec<u8>>::sse_decode(deserializer);
        return String::from_utf8(inner).unwrap();
    }
}

impl SseDecode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap() != 0
    }
}

impl SseDecode for crate::models::DartAuthProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_username = <String>::sse_decode(deserializer);
                let mut var_password = <String>::sse_decode(deserializer);
                return crate::models::DartAuthProvider::BasicAuth {
                    username: var_username,
                    password: var_password,
                };
            },
            1 => {
                let mut var_token = <String>::sse_decode(deserializer);
                return crate::models::DartAuthProvider::JwtToken { token: var_token };
            },
            2 => {
                return crate::models::DartAuthProvider::None;
            },
            _ => {
                unimplemented!("");
            },
        }
    }
}

impl SseDecode for crate::models::DartChangeEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                let mut var_subscriptionId = <String>::sse_decode(deserializer);
                let mut var_totalRows = <i32>::sse_decode(deserializer);
                let mut var_schema =
                    <Vec<crate::models::DartSchemaField>>::sse_decode(deserializer);
                let mut var_batchNum = <i32>::sse_decode(deserializer);
                let mut var_hasMore = <bool>::sse_decode(deserializer);
                let mut var_status = <String>::sse_decode(deserializer);
                return crate::models::DartChangeEvent::Ack {
                    subscription_id: var_subscriptionId,
                    total_rows: var_totalRows,
                    schema: var_schema,
                    batch_num: var_batchNum,
                    has_more: var_hasMore,
                    status: var_status,
                };
            },
            1 => {
                let mut var_subscriptionId = <String>::sse_decode(deserializer);
                let mut var_rowsJson = <Vec<String>>::sse_decode(deserializer);
                let mut var_batchNum = <i32>::sse_decode(deserializer);
                let mut var_hasMore = <bool>::sse_decode(deserializer);
                let mut var_status = <String>::sse_decode(deserializer);
                return crate::models::DartChangeEvent::InitialDataBatch {
                    subscription_id: var_subscriptionId,
                    rows_json: var_rowsJson,
                    batch_num: var_batchNum,
                    has_more: var_hasMore,
                    status: var_status,
                };
            },
            2 => {
                let mut var_subscriptionId = <String>::sse_decode(deserializer);
                let mut var_rowsJson = <Vec<String>>::sse_decode(deserializer);
                return crate::models::DartChangeEvent::Insert {
                    subscription_id: var_subscriptionId,
                    rows_json: var_rowsJson,
                };
            },
            3 => {
                let mut var_subscriptionId = <String>::sse_decode(deserializer);
                let mut var_rowsJson = <Vec<String>>::sse_decode(deserializer);
                let mut var_oldRowsJson = <Vec<String>>::sse_decode(deserializer);
                return crate::models::DartChangeEvent::Update {
                    subscription_id: var_subscriptionId,
                    rows_json: var_rowsJson,
                    old_rows_json: var_oldRowsJson,
                };
            },
            4 => {
                let mut var_subscriptionId = <String>::sse_decode(deserializer);
                let mut var_oldRowsJson = <Vec<String>>::sse_decode(deserializer);
                return crate::models::DartChangeEvent::Delete {
                    subscription_id: var_subscriptionId,
                    old_rows_json: var_oldRowsJson,
                };
            },
            5 => {
                let mut var_subscriptionId = <String>::sse_decode(deserializer);
                let mut var_code = <String>::sse_decode(deserializer);
                let mut var_message = <String>::sse_decode(deserializer);
                return crate::models::DartChangeEvent::Error {
                    subscription_id: var_subscriptionId,
                    code: var_code,
                    message: var_message,
                };
            },
            _ => {
                unimplemented!("");
            },
        }
    }
}

impl SseDecode for crate::models::DartConnectionError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_recoverable = <bool>::sse_decode(deserializer);
        return crate::models::DartConnectionError {
            message: var_message,
            recoverable: var_recoverable,
        };
    }
}

impl SseDecode for crate::models::DartConnectionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut tag_ = <i32>::sse_decode(deserializer);
        match tag_ {
            0 => {
                return crate::models::DartConnectionEvent::Connect;
            },
            1 => {
                let mut var_reason =
                    <crate::models::DartDisconnectReason>::sse_decode(deserializer);
                return crate::models::DartConnectionEvent::Disconnect { reason: var_reason };
            },
            2 => {
                let mut var_error = <crate::models::DartConnectionError>::sse_decode(deserializer);
                return crate::models::DartConnectionEvent::Error { error: var_error };
            },
            3 => {
                let mut var_message = <String>::sse_decode(deserializer);
                return crate::models::DartConnectionEvent::Receive {
                    message: var_message,
                };
            },
            4 => {
                let mut var_message = <String>::sse_decode(deserializer);
                return crate::models::DartConnectionEvent::Send {
                    message: var_message,
                };
            },
            _ => {
                unimplemented!("");
            },
        }
    }
}

impl SseDecode for crate::models::DartDisconnectReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_code = <Option<i32>>::sse_decode(deserializer);
        return crate::models::DartDisconnectReason {
            message: var_message,
            code: var_code,
        };
    }
}

impl SseDecode for crate::models::DartErrorDetail {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_code = <String>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_details = <Option<String>>::sse_decode(deserializer);
        return crate::models::DartErrorDetail {
            code: var_code,
            message: var_message,
            details: var_details,
        };
    }
}

impl SseDecode for crate::models::DartHealthCheckResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_status = <String>::sse_decode(deserializer);
        let mut var_version = <String>::sse_decode(deserializer);
        let mut var_apiVersion = <String>::sse_decode(deserializer);
        let mut var_buildDate = <Option<String>>::sse_decode(deserializer);
        return crate::models::DartHealthCheckResponse {
            status: var_status,
            version: var_version,
            api_version: var_apiVersion,
            build_date: var_buildDate,
        };
    }
}

impl SseDecode for crate::models::DartLoginResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_accessToken = <String>::sse_decode(deserializer);
        let mut var_refreshToken = <Option<String>>::sse_decode(deserializer);
        let mut var_expiresAt = <String>::sse_decode(deserializer);
        let mut var_refreshExpiresAt = <Option<String>>::sse_decode(deserializer);
        let mut var_user = <crate::models::DartLoginUserInfo>::sse_decode(deserializer);
        return crate::models::DartLoginResponse {
            access_token: var_accessToken,
            refresh_token: var_refreshToken,
            expires_at: var_expiresAt,
            refresh_expires_at: var_refreshExpiresAt,
            user: var_user,
        };
    }
}

impl SseDecode for crate::models::DartLoginUserInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_role = <String>::sse_decode(deserializer);
        let mut var_email = <Option<String>>::sse_decode(deserializer);
        let mut var_createdAt = <String>::sse_decode(deserializer);
        let mut var_updatedAt = <String>::sse_decode(deserializer);
        return crate::models::DartLoginUserInfo {
            id: var_id,
            username: var_username,
            role: var_role,
            email: var_email,
            created_at: var_createdAt,
            updated_at: var_updatedAt,
        };
    }
}

impl SseDecode for crate::models::DartQueryResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_success = <bool>::sse_decode(deserializer);
        let mut var_results = <Vec<crate::models::DartQueryResult>>::sse_decode(deserializer);
        let mut var_tookMs = <Option<f64>>::sse_decode(deserializer);
        let mut var_error = <Option<crate::models::DartErrorDetail>>::sse_decode(deserializer);
        return crate::models::DartQueryResponse {
            success: var_success,
            results: var_results,
            took_ms: var_tookMs,
            error: var_error,
        };
    }
}

impl SseDecode for crate::models::DartQueryResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_columns = <Vec<crate::models::DartSchemaField>>::sse_decode(deserializer);
        let mut var_rowsJson = <Vec<String>>::sse_decode(deserializer);
        let mut var_rowCount = <i64>::sse_decode(deserializer);
        let mut var_message = <Option<String>>::sse_decode(deserializer);
        return crate::models::DartQueryResult {
            columns: var_columns,
            rows_json: var_rowsJson,
            row_count: var_rowCount,
            message: var_message,
        };
    }
}

impl SseDecode for crate::models::DartSchemaField {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_name = <String>::sse_decode(deserializer);
        let mut var_dataType = <String>::sse_decode(deserializer);
        let mut var_index = <i32>::sse_decode(deserializer);
        let mut var_flags = <Option<String>>::sse_decode(deserializer);
        return crate::models::DartSchemaField {
            name: var_name,
            data_type: var_dataType,
            index: var_index,
            flags: var_flags,
        };
    }
}

impl SseDecode for crate::models::DartServerSetupRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_password = <String>::sse_decode(deserializer);
        let mut var_rootPassword = <String>::sse_decode(deserializer);
        let mut var_email = <Option<String>>::sse_decode(deserializer);
        return crate::models::DartServerSetupRequest {
            username: var_username,
            password: var_password,
            root_password: var_rootPassword,
            email: var_email,
        };
    }
}

impl SseDecode for crate::models::DartServerSetupResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_message = <String>::sse_decode(deserializer);
        let mut var_user = <crate::models::DartSetupUserInfo>::sse_decode(deserializer);
        return crate::models::DartServerSetupResponse {
            message: var_message,
            user: var_user,
        };
    }
}

impl SseDecode for crate::models::DartSetupStatusResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_needsSetup = <bool>::sse_decode(deserializer);
        let mut var_message = <String>::sse_decode(deserializer);
        return crate::models::DartSetupStatusResponse {
            needs_setup: var_needsSetup,
            message: var_message,
        };
    }
}

impl SseDecode for crate::models::DartSetupUserInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_id = <String>::sse_decode(deserializer);
        let mut var_username = <String>::sse_decode(deserializer);
        let mut var_role = <String>::sse_decode(deserializer);
        let mut var_email = <Option<String>>::sse_decode(deserializer);
        let mut var_createdAt = <String>::sse_decode(deserializer);
        let mut var_updatedAt = <String>::sse_decode(deserializer);
        return crate::models::DartSetupUserInfo {
            id: var_id,
            username: var_username,
            role: var_role,
            email: var_email,
            created_at: var_createdAt,
            updated_at: var_updatedAt,
        };
    }
}

impl SseDecode for crate::models::DartSubscriptionConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut var_sql = <String>::sse_decode(deserializer);
        let mut var_id = <Option<String>>::sse_decode(deserializer);
        let mut var_batchSize = <Option<i32>>::sse_decode(deserializer);
        let mut var_lastRows = <Option<i32>>::sse_decode(deserializer);
        return crate::models::DartSubscriptionConfig {
            sql: var_sql,
            id: var_id,
            batch_size: var_batchSize,
            last_rows: var_lastRows,
        };
    }
}

impl SseDecode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_f64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i32::<NativeEndian>().unwrap()
    }
}

impl SseDecode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_i64::<NativeEndian>().unwrap()
    }
}

impl SseDecode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<String>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::DartQueryResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::DartQueryResult>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<crate::models::DartSchemaField> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<crate::models::DartSchemaField>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        let mut len_ = <i32>::sse_decode(deserializer);
        let mut ans_ = vec![];
        for idx_ in 0..len_ {
            ans_.push(<u8>::sse_decode(deserializer));
        }
        return ans_;
    }
}

impl SseDecode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<String>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<bool>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::DartChangeEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::DartChangeEvent>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::DartConnectionEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::DartConnectionEvent>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::DartErrorDetail> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::DartErrorDetail>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<crate::models::DartSubscriptionConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<crate::models::DartSubscriptionConfig>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<f64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i32>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        if (<bool>::sse_decode(deserializer)) {
            return Some(<i64>::sse_decode(deserializer));
        } else {
            return None;
        }
    }
}

impl SseDecode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u8().unwrap()
    }
}

impl SseDecode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {}
}

impl SseDecode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_decode(deserializer: &mut flutter_rust_bridge::for_generated::SseDeserializer) -> Self {
        deserializer.cursor.read_u64::<NativeEndian>().unwrap() as _
    }
}

fn pde_ffi_dispatcher_primary_impl(
    func_id: i32,
    port: flutter_rust_bridge::for_generated::MessagePort,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        1 => wire__crate__api__dart_check_setup_status_impl(port, ptr, rust_vec_len, data_len),
        4 => wire__crate__api__dart_execute_query_impl(port, ptr, rust_vec_len, data_len),
        5 => wire__crate__api__dart_health_check_impl(port, ptr, rust_vec_len, data_len),
        6 => wire__crate__api__dart_login_impl(port, ptr, rust_vec_len, data_len),
        7 => wire__crate__api__dart_next_connection_event_impl(port, ptr, rust_vec_len, data_len),
        8 => wire__crate__api__dart_refresh_token_impl(port, ptr, rust_vec_len, data_len),
        9 => wire__crate__api__dart_server_setup_impl(port, ptr, rust_vec_len, data_len),
        10 => wire__crate__api__dart_subscribe_impl(port, ptr, rust_vec_len, data_len),
        11 => wire__crate__api__dart_subscription_close_impl(port, ptr, rust_vec_len, data_len),
        13 => wire__crate__api__dart_subscription_next_impl(port, ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

fn pde_ffi_dispatcher_sync_impl(
    func_id: i32,
    ptr: flutter_rust_bridge::for_generated::PlatformGeneralizedUint8ListPtr,
    rust_vec_len: i32,
    data_len: i32,
) -> flutter_rust_bridge::for_generated::WireSyncRust2DartSse {
    // Codec=Pde (Serialization + dispatch), see doc to use other codecs
    match func_id {
        2 => wire__crate__api__dart_connection_events_enabled_impl(ptr, rust_vec_len, data_len),
        3 => wire__crate__api__dart_create_client_impl(ptr, rust_vec_len, data_len),
        12 => wire__crate__api__dart_subscription_id_impl(ptr, rust_vec_len, data_len),
        14 => wire__crate__api__dart_update_auth_impl(ptr, rust_vec_len, data_len),
        _ => unreachable!(),
    }
}

// Section: rust2dart

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<DartKalamClient> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<DartKalamClient> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<DartKalamClient>> for DartKalamClient {
    fn into_into_dart(self) -> FrbWrapper<DartKalamClient> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for FrbWrapper<DartSubscription> {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self.0)
            .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive for FrbWrapper<DartSubscription> {}

impl flutter_rust_bridge::IntoIntoDart<FrbWrapper<DartSubscription>> for DartSubscription {
    fn into_into_dart(self) -> FrbWrapper<DartSubscription> {
        self.into()
    }
}

// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartAuthProvider {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::DartAuthProvider::BasicAuth { username, password } => [
                0.into_dart(),
                username.into_into_dart().into_dart(),
                password.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::DartAuthProvider::JwtToken { token } => {
                [1.into_dart(), token.into_into_dart().into_dart()].into_dart()
            },
            crate::models::DartAuthProvider::None => [2.into_dart()].into_dart(),
            _ => {
                unimplemented!("");
            },
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartAuthProvider
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartAuthProvider>
    for crate::models::DartAuthProvider
{
    fn into_into_dart(self) -> crate::models::DartAuthProvider {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartChangeEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::DartChangeEvent::Ack {
                subscription_id,
                total_rows,
                schema,
                batch_num,
                has_more,
                status,
            } => [
                0.into_dart(),
                subscription_id.into_into_dart().into_dart(),
                total_rows.into_into_dart().into_dart(),
                schema.into_into_dart().into_dart(),
                batch_num.into_into_dart().into_dart(),
                has_more.into_into_dart().into_dart(),
                status.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::DartChangeEvent::InitialDataBatch {
                subscription_id,
                rows_json,
                batch_num,
                has_more,
                status,
            } => [
                1.into_dart(),
                subscription_id.into_into_dart().into_dart(),
                rows_json.into_into_dart().into_dart(),
                batch_num.into_into_dart().into_dart(),
                has_more.into_into_dart().into_dart(),
                status.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::DartChangeEvent::Insert {
                subscription_id,
                rows_json,
            } => [
                2.into_dart(),
                subscription_id.into_into_dart().into_dart(),
                rows_json.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::DartChangeEvent::Update {
                subscription_id,
                rows_json,
                old_rows_json,
            } => [
                3.into_dart(),
                subscription_id.into_into_dart().into_dart(),
                rows_json.into_into_dart().into_dart(),
                old_rows_json.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::DartChangeEvent::Delete {
                subscription_id,
                old_rows_json,
            } => [
                4.into_dart(),
                subscription_id.into_into_dart().into_dart(),
                old_rows_json.into_into_dart().into_dart(),
            ]
            .into_dart(),
            crate::models::DartChangeEvent::Error {
                subscription_id,
                code,
                message,
            } => [
                5.into_dart(),
                subscription_id.into_into_dart().into_dart(),
                code.into_into_dart().into_dart(),
                message.into_into_dart().into_dart(),
            ]
            .into_dart(),
            _ => {
                unimplemented!("");
            },
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartChangeEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartChangeEvent>
    for crate::models::DartChangeEvent
{
    fn into_into_dart(self) -> crate::models::DartChangeEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartConnectionError {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.message.into_into_dart().into_dart(),
            self.recoverable.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartConnectionError
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartConnectionError>
    for crate::models::DartConnectionError
{
    fn into_into_dart(self) -> crate::models::DartConnectionError {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartConnectionEvent {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        match self {
            crate::models::DartConnectionEvent::Connect => [0.into_dart()].into_dart(),
            crate::models::DartConnectionEvent::Disconnect { reason } => {
                [1.into_dart(), reason.into_into_dart().into_dart()].into_dart()
            },
            crate::models::DartConnectionEvent::Error { error } => {
                [2.into_dart(), error.into_into_dart().into_dart()].into_dart()
            },
            crate::models::DartConnectionEvent::Receive { message } => {
                [3.into_dart(), message.into_into_dart().into_dart()].into_dart()
            },
            crate::models::DartConnectionEvent::Send { message } => {
                [4.into_dart(), message.into_into_dart().into_dart()].into_dart()
            },
            _ => {
                unimplemented!("");
            },
        }
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartConnectionEvent
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartConnectionEvent>
    for crate::models::DartConnectionEvent
{
    fn into_into_dart(self) -> crate::models::DartConnectionEvent {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartDisconnectReason {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.message.into_into_dart().into_dart(),
            self.code.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartDisconnectReason
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartDisconnectReason>
    for crate::models::DartDisconnectReason
{
    fn into_into_dart(self) -> crate::models::DartDisconnectReason {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartErrorDetail {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.code.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
            self.details.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartErrorDetail
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartErrorDetail>
    for crate::models::DartErrorDetail
{
    fn into_into_dart(self) -> crate::models::DartErrorDetail {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartHealthCheckResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.status.into_into_dart().into_dart(),
            self.version.into_into_dart().into_dart(),
            self.api_version.into_into_dart().into_dart(),
            self.build_date.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartHealthCheckResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartHealthCheckResponse>
    for crate::models::DartHealthCheckResponse
{
    fn into_into_dart(self) -> crate::models::DartHealthCheckResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartLoginResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.access_token.into_into_dart().into_dart(),
            self.refresh_token.into_into_dart().into_dart(),
            self.expires_at.into_into_dart().into_dart(),
            self.refresh_expires_at.into_into_dart().into_dart(),
            self.user.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartLoginResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartLoginResponse>
    for crate::models::DartLoginResponse
{
    fn into_into_dart(self) -> crate::models::DartLoginResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartLoginUserInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.username.into_into_dart().into_dart(),
            self.role.into_into_dart().into_dart(),
            self.email.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.updated_at.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartLoginUserInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartLoginUserInfo>
    for crate::models::DartLoginUserInfo
{
    fn into_into_dart(self) -> crate::models::DartLoginUserInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartQueryResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.success.into_into_dart().into_dart(),
            self.results.into_into_dart().into_dart(),
            self.took_ms.into_into_dart().into_dart(),
            self.error.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartQueryResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartQueryResponse>
    for crate::models::DartQueryResponse
{
    fn into_into_dart(self) -> crate::models::DartQueryResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartQueryResult {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.columns.into_into_dart().into_dart(),
            self.rows_json.into_into_dart().into_dart(),
            self.row_count.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartQueryResult
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartQueryResult>
    for crate::models::DartQueryResult
{
    fn into_into_dart(self) -> crate::models::DartQueryResult {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartSchemaField {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.name.into_into_dart().into_dart(),
            self.data_type.into_into_dart().into_dart(),
            self.index.into_into_dart().into_dart(),
            self.flags.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartSchemaField
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartSchemaField>
    for crate::models::DartSchemaField
{
    fn into_into_dart(self) -> crate::models::DartSchemaField {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartServerSetupRequest {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.username.into_into_dart().into_dart(),
            self.password.into_into_dart().into_dart(),
            self.root_password.into_into_dart().into_dart(),
            self.email.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartServerSetupRequest
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartServerSetupRequest>
    for crate::models::DartServerSetupRequest
{
    fn into_into_dart(self) -> crate::models::DartServerSetupRequest {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartServerSetupResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.message.into_into_dart().into_dart(),
            self.user.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartServerSetupResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartServerSetupResponse>
    for crate::models::DartServerSetupResponse
{
    fn into_into_dart(self) -> crate::models::DartServerSetupResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartSetupStatusResponse {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.needs_setup.into_into_dart().into_dart(),
            self.message.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartSetupStatusResponse
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartSetupStatusResponse>
    for crate::models::DartSetupStatusResponse
{
    fn into_into_dart(self) -> crate::models::DartSetupStatusResponse {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartSetupUserInfo {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.id.into_into_dart().into_dart(),
            self.username.into_into_dart().into_dart(),
            self.role.into_into_dart().into_dart(),
            self.email.into_into_dart().into_dart(),
            self.created_at.into_into_dart().into_dart(),
            self.updated_at.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartSetupUserInfo
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartSetupUserInfo>
    for crate::models::DartSetupUserInfo
{
    fn into_into_dart(self) -> crate::models::DartSetupUserInfo {
        self
    }
}
// Codec=Dco (DartCObject based), see doc to use other codecs
impl flutter_rust_bridge::IntoDart for crate::models::DartSubscriptionConfig {
    fn into_dart(self) -> flutter_rust_bridge::for_generated::DartAbi {
        [
            self.sql.into_into_dart().into_dart(),
            self.id.into_into_dart().into_dart(),
            self.batch_size.into_into_dart().into_dart(),
            self.last_rows.into_into_dart().into_dart(),
        ]
        .into_dart()
    }
}
impl flutter_rust_bridge::for_generated::IntoDartExceptPrimitive
    for crate::models::DartSubscriptionConfig
{
}
impl flutter_rust_bridge::IntoIntoDart<crate::models::DartSubscriptionConfig>
    for crate::models::DartSubscriptionConfig
{
    fn into_into_dart(self) -> crate::models::DartSubscriptionConfig {
        self
    }
}

impl SseEncode for flutter_rust_bridge::for_generated::anyhow::Error {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(format!("{:?}", self), serializer);
    }
}

impl SseEncode for DartKalamClient {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode for DartSubscription {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>>>::sse_encode(flutter_rust_bridge::for_generated::rust_auto_opaque_encode::<_, MoiArc<_>>(self), serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode
    for RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>>
{
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        let (ptr, size) = self.sse_encode_raw();
        <usize>::sse_encode(ptr, serializer);
        <i32>::sse_encode(size, serializer);
    }
}

impl SseEncode for String {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<u8>>::sse_encode(self.into_bytes(), serializer);
    }
}

impl SseEncode for bool {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self as _).unwrap();
    }
}

impl SseEncode for crate::models::DartAuthProvider {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::DartAuthProvider::BasicAuth { username, password } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(username, serializer);
                <String>::sse_encode(password, serializer);
            },
            crate::models::DartAuthProvider::JwtToken { token } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(token, serializer);
            },
            crate::models::DartAuthProvider::None => {
                <i32>::sse_encode(2, serializer);
            },
            _ => {
                unimplemented!("");
            },
        }
    }
}

impl SseEncode for crate::models::DartChangeEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::DartChangeEvent::Ack {
                subscription_id,
                total_rows,
                schema,
                batch_num,
                has_more,
                status,
            } => {
                <i32>::sse_encode(0, serializer);
                <String>::sse_encode(subscription_id, serializer);
                <i32>::sse_encode(total_rows, serializer);
                <Vec<crate::models::DartSchemaField>>::sse_encode(schema, serializer);
                <i32>::sse_encode(batch_num, serializer);
                <bool>::sse_encode(has_more, serializer);
                <String>::sse_encode(status, serializer);
            },
            crate::models::DartChangeEvent::InitialDataBatch {
                subscription_id,
                rows_json,
                batch_num,
                has_more,
                status,
            } => {
                <i32>::sse_encode(1, serializer);
                <String>::sse_encode(subscription_id, serializer);
                <Vec<String>>::sse_encode(rows_json, serializer);
                <i32>::sse_encode(batch_num, serializer);
                <bool>::sse_encode(has_more, serializer);
                <String>::sse_encode(status, serializer);
            },
            crate::models::DartChangeEvent::Insert {
                subscription_id,
                rows_json,
            } => {
                <i32>::sse_encode(2, serializer);
                <String>::sse_encode(subscription_id, serializer);
                <Vec<String>>::sse_encode(rows_json, serializer);
            },
            crate::models::DartChangeEvent::Update {
                subscription_id,
                rows_json,
                old_rows_json,
            } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(subscription_id, serializer);
                <Vec<String>>::sse_encode(rows_json, serializer);
                <Vec<String>>::sse_encode(old_rows_json, serializer);
            },
            crate::models::DartChangeEvent::Delete {
                subscription_id,
                old_rows_json,
            } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(subscription_id, serializer);
                <Vec<String>>::sse_encode(old_rows_json, serializer);
            },
            crate::models::DartChangeEvent::Error {
                subscription_id,
                code,
                message,
            } => {
                <i32>::sse_encode(5, serializer);
                <String>::sse_encode(subscription_id, serializer);
                <String>::sse_encode(code, serializer);
                <String>::sse_encode(message, serializer);
            },
            _ => {
                unimplemented!("");
            },
        }
    }
}

impl SseEncode for crate::models::DartConnectionError {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.message, serializer);
        <bool>::sse_encode(self.recoverable, serializer);
    }
}

impl SseEncode for crate::models::DartConnectionEvent {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        match self {
            crate::models::DartConnectionEvent::Connect => {
                <i32>::sse_encode(0, serializer);
            },
            crate::models::DartConnectionEvent::Disconnect { reason } => {
                <i32>::sse_encode(1, serializer);
                <crate::models::DartDisconnectReason>::sse_encode(reason, serializer);
            },
            crate::models::DartConnectionEvent::Error { error } => {
                <i32>::sse_encode(2, serializer);
                <crate::models::DartConnectionError>::sse_encode(error, serializer);
            },
            crate::models::DartConnectionEvent::Receive { message } => {
                <i32>::sse_encode(3, serializer);
                <String>::sse_encode(message, serializer);
            },
            crate::models::DartConnectionEvent::Send { message } => {
                <i32>::sse_encode(4, serializer);
                <String>::sse_encode(message, serializer);
            },
            _ => {
                unimplemented!("");
            },
        }
    }
}

impl SseEncode for crate::models::DartDisconnectReason {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.message, serializer);
        <Option<i32>>::sse_encode(self.code, serializer);
    }
}

impl SseEncode for crate::models::DartErrorDetail {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.code, serializer);
        <String>::sse_encode(self.message, serializer);
        <Option<String>>::sse_encode(self.details, serializer);
    }
}

impl SseEncode for crate::models::DartHealthCheckResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.status, serializer);
        <String>::sse_encode(self.version, serializer);
        <String>::sse_encode(self.api_version, serializer);
        <Option<String>>::sse_encode(self.build_date, serializer);
    }
}

impl SseEncode for crate::models::DartLoginResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.access_token, serializer);
        <Option<String>>::sse_encode(self.refresh_token, serializer);
        <String>::sse_encode(self.expires_at, serializer);
        <Option<String>>::sse_encode(self.refresh_expires_at, serializer);
        <crate::models::DartLoginUserInfo>::sse_encode(self.user, serializer);
    }
}

impl SseEncode for crate::models::DartLoginUserInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.role, serializer);
        <Option<String>>::sse_encode(self.email, serializer);
        <String>::sse_encode(self.created_at, serializer);
        <String>::sse_encode(self.updated_at, serializer);
    }
}

impl SseEncode for crate::models::DartQueryResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.success, serializer);
        <Vec<crate::models::DartQueryResult>>::sse_encode(self.results, serializer);
        <Option<f64>>::sse_encode(self.took_ms, serializer);
        <Option<crate::models::DartErrorDetail>>::sse_encode(self.error, serializer);
    }
}

impl SseEncode for crate::models::DartQueryResult {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <Vec<crate::models::DartSchemaField>>::sse_encode(self.columns, serializer);
        <Vec<String>>::sse_encode(self.rows_json, serializer);
        <i64>::sse_encode(self.row_count, serializer);
        <Option<String>>::sse_encode(self.message, serializer);
    }
}

impl SseEncode for crate::models::DartSchemaField {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.name, serializer);
        <String>::sse_encode(self.data_type, serializer);
        <i32>::sse_encode(self.index, serializer);
        <Option<String>>::sse_encode(self.flags, serializer);
    }
}

impl SseEncode for crate::models::DartServerSetupRequest {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.password, serializer);
        <String>::sse_encode(self.root_password, serializer);
        <Option<String>>::sse_encode(self.email, serializer);
    }
}

impl SseEncode for crate::models::DartServerSetupResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.message, serializer);
        <crate::models::DartSetupUserInfo>::sse_encode(self.user, serializer);
    }
}

impl SseEncode for crate::models::DartSetupStatusResponse {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.needs_setup, serializer);
        <String>::sse_encode(self.message, serializer);
    }
}

impl SseEncode for crate::models::DartSetupUserInfo {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.id, serializer);
        <String>::sse_encode(self.username, serializer);
        <String>::sse_encode(self.role, serializer);
        <Option<String>>::sse_encode(self.email, serializer);
        <String>::sse_encode(self.created_at, serializer);
        <String>::sse_encode(self.updated_at, serializer);
    }
}

impl SseEncode for crate::models::DartSubscriptionConfig {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <String>::sse_encode(self.sql, serializer);
        <Option<String>>::sse_encode(self.id, serializer);
        <Option<i32>>::sse_encode(self.batch_size, serializer);
        <Option<i32>>::sse_encode(self.last_rows, serializer);
    }
}

impl SseEncode for f64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_f64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i32 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i32::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for i64 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_i64::<NativeEndian>(self).unwrap();
    }
}

impl SseEncode for Vec<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <String>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::DartQueryResult> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::DartQueryResult>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<crate::models::DartSchemaField> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <crate::models::DartSchemaField>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Vec<u8> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <i32>::sse_encode(self.len() as _, serializer);
        for item in self {
            <u8>::sse_encode(item, serializer);
        }
    }
}

impl SseEncode for Option<String> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <String>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<bool> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <bool>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::DartChangeEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::DartChangeEvent>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::DartConnectionEvent> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::DartConnectionEvent>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::DartErrorDetail> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::DartErrorDetail>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<crate::models::DartSubscriptionConfig> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <crate::models::DartSubscriptionConfig>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<f64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <f64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i32> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i32>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for Option<i64> {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        <bool>::sse_encode(self.is_some(), serializer);
        if let Some(value) = self {
            <i64>::sse_encode(value, serializer);
        }
    }
}

impl SseEncode for u8 {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u8(self).unwrap();
    }
}

impl SseEncode for () {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {}
}

impl SseEncode for usize {
    // Codec=Sse (Serialization based), see doc to use other codecs
    fn sse_encode(self, serializer: &mut flutter_rust_bridge::for_generated::SseSerializer) {
        serializer.cursor.write_u64::<NativeEndian>(self as _).unwrap();
    }
}

#[cfg(not(target_family = "wasm"))]
mod io {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_io!();

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kalam_link_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartKalamClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kalam_link_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartKalamClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>>::decrement_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kalam_link_rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSubscription(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>>::increment_strong_count(ptr as _);
    }

    #[unsafe(no_mangle)]
    pub extern "C" fn frbgen_kalam_link_rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSubscription(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(not(target_family = "wasm"))]
pub use io::*;

/// cbindgen:ignore
#[cfg(target_family = "wasm")]
mod web {
    // This file is automatically generated, so please do not edit it.
    // @generated by `flutter_rust_bridge`@ 2.11.1.

    // Section: imports

    use super::*;
    use crate::api::*;
    use flutter_rust_bridge::for_generated::byteorder::{
        NativeEndian, ReadBytesExt, WriteBytesExt,
    };
    use flutter_rust_bridge::for_generated::wasm_bindgen;
    use flutter_rust_bridge::for_generated::wasm_bindgen::prelude::*;
    use flutter_rust_bridge::for_generated::{transform_result_dco, Lifetimeable, Lockable};
    use flutter_rust_bridge::{Handler, IntoIntoDart};

    // Section: boilerplate

    flutter_rust_bridge::frb_generated_boilerplate_web!();

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartKalamClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartKalamClient(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartKalamClient>>::decrement_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSubscription(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>>::increment_strong_count(ptr as _);
    }

    #[wasm_bindgen]
    pub fn rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSubscription(
        ptr: *const std::ffi::c_void,
    ) {
        MoiArc::<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<DartSubscription>>::decrement_strong_count(ptr as _);
    }
}
#[cfg(target_family = "wasm")]
pub use web::*;
