//! Credential storage abstraction for KalamDB clients.
//!
//! Provides a trait-based system for storing and retrieving authentication
//! credentials across different storage backends (files, environment variables,
//! secure keychains, browser localStorage, etc.).
//!
//! This abstraction allows CLI tools, WASM clients, and other applications
//! to manage credentials in a platform-appropriate way.

use crate::error::Result;
use serde::{Deserialize, Serialize};

/// Stored credentials for a KalamDB instance.
///
/// Contains authentication information that can be persisted and reused
/// across sessions.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct Credentials {
    /// Database instance identifier (e.g., "local", "production", URL)
    pub instance: String,
    
    /// Username for authentication
    pub username: String,
    
    /// Password or token for authentication
    /// Note: Stored credentials should be protected with appropriate file permissions
    pub password: String,
    
    /// Optional: Server URL if different from instance name
    pub server_url: Option<String>,
}

impl Credentials {
    /// Create new credentials
    pub fn new(instance: String, username: String, password: String) -> Self {
        Self {
            instance,
            username,
            password,
            server_url: None,
        }
    }
    
    /// Create new credentials with server URL
    pub fn with_server_url(
        instance: String,
        username: String,
        password: String,
        server_url: String,
    ) -> Self {
        Self {
            instance,
            username,
            password,
            server_url: Some(server_url),
        }
    }
    
    /// Get the server URL, defaulting to instance name if not set
    pub fn get_server_url(&self) -> &str {
        self.server_url.as_deref().unwrap_or(&self.instance)
    }
}

/// Trait for credential storage backends.
///
/// Implementations can store credentials in files, environment variables,
/// secure keychains, browser localStorage, or any other storage mechanism.
///
/// # Security Note
///
/// Implementations MUST ensure credentials are stored securely:
/// - Files should use restrictive permissions (0600 on Unix)
/// - Passwords should never be logged
/// - Consider encryption for sensitive deployments
///
/// # Example Implementation
///
/// ```rust,ignore
/// use kalam_link::credentials::{CredentialStore, Credentials};
///
/// struct MyCredentialStore;
///
/// impl CredentialStore for MyCredentialStore {
///     fn get_credentials(&self, instance: &str) -> Result<Option<Credentials>> {
///         // Read from your storage backend
///         Ok(None)
///     }
///     
///     fn set_credentials(&mut self, credentials: &Credentials) -> Result<()> {
///         // Write to your storage backend
///         Ok(())
///     }
///     
///     fn delete_credentials(&mut self, instance: &str) -> Result<()> {
///         // Remove from your storage backend
///         Ok(())
///     }
///     
///     fn list_instances(&self) -> Result<Vec<String>> {
///         // List all stored instances
///         Ok(vec![])
///     }
/// }
/// ```
pub trait CredentialStore {
    /// Retrieve credentials for a specific database instance
    ///
    /// Returns `Ok(None)` if no credentials are stored for the instance.
    ///
    /// # Arguments
    /// * `instance` - Instance identifier (e.g., "local", "production")
    fn get_credentials(&self, instance: &str) -> Result<Option<Credentials>>;
    
    /// Store credentials for a database instance
    ///
    /// Overwrites existing credentials for the same instance.
    ///
    /// # Arguments
    /// * `credentials` - Credentials to store
    fn set_credentials(&mut self, credentials: &Credentials) -> Result<()>;
    
    /// Delete stored credentials for an instance
    ///
    /// Returns `Ok(())` even if no credentials were stored.
    ///
    /// # Arguments
    /// * `instance` - Instance identifier to delete
    fn delete_credentials(&mut self, instance: &str) -> Result<()>;
    
    /// List all stored instance identifiers
    ///
    /// Returns a vector of instance names that have stored credentials.
    fn list_instances(&self) -> Result<Vec<String>>;
    
    /// Check if credentials exist for an instance
    ///
    /// Default implementation calls `get_credentials()` and checks for Some.
    fn has_credentials(&self, instance: &str) -> Result<bool> {
        Ok(self.get_credentials(instance)?.is_some())
    }
}

/// In-memory credential store for testing and temporary use.
///
/// Does NOT persist credentials across restarts. Useful for:
/// - Unit tests
/// - Temporary sessions
/// - WASM applications without localStorage access
///
/// # Example
///
/// ```rust
/// use kalam_link::credentials::{CredentialStore, Credentials, MemoryCredentialStore};
///
/// let mut store = MemoryCredentialStore::new();
/// let creds = Credentials::new(
///     "local".to_string(),
///     "alice".to_string(),
///     "secret123".to_string(),
/// );
///
/// store.set_credentials(&creds).unwrap();
/// let retrieved = store.get_credentials("local").unwrap();
/// assert_eq!(retrieved, Some(creds));
/// ```
#[derive(Debug, Default, Clone)]
pub struct MemoryCredentialStore {
    credentials: std::collections::HashMap<String, Credentials>,
}

impl MemoryCredentialStore {
    /// Create a new empty in-memory credential store
    pub fn new() -> Self {
        Self {
            credentials: std::collections::HashMap::new(),
        }
    }
}

impl CredentialStore for MemoryCredentialStore {
    fn get_credentials(&self, instance: &str) -> Result<Option<Credentials>> {
        Ok(self.credentials.get(instance).cloned())
    }
    
    fn set_credentials(&mut self, credentials: &Credentials) -> Result<()> {
        self.credentials.insert(credentials.instance.clone(), credentials.clone());
        Ok(())
    }
    
    fn delete_credentials(&mut self, instance: &str) -> Result<()> {
        self.credentials.remove(instance);
        Ok(())
    }
    
    fn list_instances(&self) -> Result<Vec<String>> {
        Ok(self.credentials.keys().cloned().collect())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_credentials_creation() {
        let creds = Credentials::new(
            "local".to_string(),
            "alice".to_string(),
            "secret".to_string(),
        );
        
        assert_eq!(creds.instance, "local");
        assert_eq!(creds.username, "alice");
        assert_eq!(creds.password, "secret");
        assert_eq!(creds.server_url, None);
        assert_eq!(creds.get_server_url(), "local");
    }

    #[test]
    fn test_credentials_with_server_url() {
        let creds = Credentials::with_server_url(
            "prod".to_string(),
            "bob".to_string(),
            "pass123".to_string(),
            "https://db.example.com".to_string(),
        );
        
        assert_eq!(creds.server_url, Some("https://db.example.com".to_string()));
        assert_eq!(creds.get_server_url(), "https://db.example.com");
    }

    #[test]
    fn test_memory_store_basic_operations() {
        let mut store = MemoryCredentialStore::new();
        
        // Initially empty
        assert_eq!(store.get_credentials("local").unwrap(), None);
        assert!(!store.has_credentials("local").unwrap());
        
        // Store credentials
        let creds = Credentials::new(
            "local".to_string(),
            "alice".to_string(),
            "secret".to_string(),
        );
        store.set_credentials(&creds).unwrap();
        
        // Retrieve credentials
        let retrieved = store.get_credentials("local").unwrap();
        assert_eq!(retrieved, Some(creds.clone()));
        assert!(store.has_credentials("local").unwrap());
        
        // Delete credentials
        store.delete_credentials("local").unwrap();
        assert_eq!(store.get_credentials("local").unwrap(), None);
    }

    #[test]
    fn test_memory_store_multiple_instances() {
        let mut store = MemoryCredentialStore::new();
        
        let creds1 = Credentials::new("local".to_string(), "alice".to_string(), "pass1".to_string());
        let creds2 = Credentials::new("prod".to_string(), "bob".to_string(), "pass2".to_string());
        let creds3 = Credentials::new("dev".to_string(), "carol".to_string(), "pass3".to_string());
        
        store.set_credentials(&creds1).unwrap();
        store.set_credentials(&creds2).unwrap();
        store.set_credentials(&creds3).unwrap();
        
        // List instances
        let instances = store.list_instances().unwrap();
        assert_eq!(instances.len(), 3);
        assert!(instances.contains(&"local".to_string()));
        assert!(instances.contains(&"prod".to_string()));
        assert!(instances.contains(&"dev".to_string()));
        
        // Retrieve specific instances
        assert_eq!(store.get_credentials("local").unwrap().unwrap().username, "alice");
        assert_eq!(store.get_credentials("prod").unwrap().unwrap().username, "bob");
        assert_eq!(store.get_credentials("dev").unwrap().unwrap().username, "carol");
    }

    #[test]
    fn test_memory_store_overwrite() {
        let mut store = MemoryCredentialStore::new();
        
        let creds1 = Credentials::new("local".to_string(), "alice".to_string(), "old_pass".to_string());
        let creds2 = Credentials::new("local".to_string(), "alice".to_string(), "new_pass".to_string());
        
        store.set_credentials(&creds1).unwrap();
        store.set_credentials(&creds2).unwrap();
        
        let retrieved = store.get_credentials("local").unwrap().unwrap();
        assert_eq!(retrieved.password, "new_pass");
    }

    #[test]
    fn test_credentials_serialization() {
        let creds = Credentials::with_server_url(
            "prod".to_string(),
            "alice".to_string(),
            "secret123".to_string(),
            "https://db.example.com".to_string(),
        );
        
        // Serialize to JSON
        let json = serde_json::to_string(&creds).unwrap();
        
        // Deserialize back
        let deserialized: Credentials = serde_json::from_str(&json).unwrap();
        
        assert_eq!(deserialized, creds);
    }
}
