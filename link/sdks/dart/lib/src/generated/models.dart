// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'models.freezed.dart';

@freezed
sealed class DartAuthProvider with _$DartAuthProvider {
  const DartAuthProvider._();

  /// HTTP Basic Auth with username and password.
  const factory DartAuthProvider.basicAuth({
    required String username,
    required String password,
  }) = DartAuthProvider_BasicAuth;

  /// JWT bearer token.
  const factory DartAuthProvider.jwtToken({
    required String token,
  }) = DartAuthProvider_JwtToken;

  /// No authentication (localhost bypass).
  const factory DartAuthProvider.none() = DartAuthProvider_None;
}

@freezed
sealed class DartChangeEvent with _$DartChangeEvent {
  const DartChangeEvent._();

  /// Subscription acknowledged â€” contains schema info.
  const factory DartChangeEvent.ack({
    required String subscriptionId,
    required int totalRows,
    required List<DartSchemaField> schema,
    required int batchNum,
    required bool hasMore,
    required String status,
  }) = DartChangeEvent_Ack;

  /// Batch of initial data rows.
  const factory DartChangeEvent.initialDataBatch({
    required String subscriptionId,

    /// Each entry is a JSON-encoded row object (`{"col": value, ...}`).
    required List<String> rowsJson,
    required int batchNum,
    required bool hasMore,
    required String status,
  }) = DartChangeEvent_InitialDataBatch;

  /// One or more rows were inserted.
  const factory DartChangeEvent.insert({
    required String subscriptionId,

    /// Each entry is a JSON-encoded row object.
    required List<String> rowsJson,
  }) = DartChangeEvent_Insert;

  /// One or more rows were updated.
  const factory DartChangeEvent.update({
    required String subscriptionId,
    required List<String> rowsJson,
    required List<String> oldRowsJson,
  }) = DartChangeEvent_Update;

  /// One or more rows were deleted.
  const factory DartChangeEvent.delete({
    required String subscriptionId,
    required List<String> oldRowsJson,
  }) = DartChangeEvent_Delete;

  /// Server-side error on this subscription.
  const factory DartChangeEvent.error({
    required String subscriptionId,
    required String code,
    required String message,
  }) = DartChangeEvent_Error;
}

/// Error information from a connection or protocol error.
///
/// Mirrors `kalam_link::ConnectionError`.
class DartConnectionError {
  /// Human-readable error message.
  final String message;

  /// Whether this error is recoverable (auto-reconnect may succeed).
  final bool recoverable;

  const DartConnectionError({
    required this.message,
    required this.recoverable,
  });

  @override
  int get hashCode => message.hashCode ^ recoverable.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartConnectionError &&
          runtimeType == other.runtimeType &&
          message == other.message &&
          recoverable == other.recoverable;
}

@freezed
sealed class DartConnectionEvent with _$DartConnectionEvent {
  const DartConnectionEvent._();

  /// WebSocket connection established and authenticated.
  const factory DartConnectionEvent.connect() = DartConnectionEvent_Connect;

  /// WebSocket connection closed.
  const factory DartConnectionEvent.disconnect({
    required DartDisconnectReason reason,
  }) = DartConnectionEvent_Disconnect;

  /// Connection or protocol error.
  const factory DartConnectionEvent.error({
    required DartConnectionError error,
  }) = DartConnectionEvent_Error;

  /// Raw message received from the server (debug).
  const factory DartConnectionEvent.receive({
    required String message,
  }) = DartConnectionEvent_Receive;

  /// Raw message sent to the server (debug).
  const factory DartConnectionEvent.send({
    required String message,
  }) = DartConnectionEvent_Send;
}

/// Reason why a WebSocket connection was closed.
///
/// Mirrors `kalam_link::DisconnectReason`.
class DartDisconnectReason {
  /// Human-readable description of why the connection closed.
  final String message;

  /// WebSocket close code, if available (e.g. 1000 = normal, 1006 = abnormal).
  final int? code;

  const DartDisconnectReason({
    required this.message,
    this.code,
  });

  @override
  int get hashCode => message.hashCode ^ code.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartDisconnectReason &&
          runtimeType == other.runtimeType &&
          message == other.message &&
          code == other.code;
}

class DartErrorDetail {
  final String code;
  final String message;
  final String? details;

  const DartErrorDetail({
    required this.code,
    required this.message,
    this.details,
  });

  @override
  int get hashCode => code.hashCode ^ message.hashCode ^ details.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartErrorDetail &&
          runtimeType == other.runtimeType &&
          code == other.code &&
          message == other.message &&
          details == other.details;
}

class DartHealthCheckResponse {
  final String status;
  final String version;
  final String apiVersion;
  final String? buildDate;

  const DartHealthCheckResponse({
    required this.status,
    required this.version,
    required this.apiVersion,
    this.buildDate,
  });

  @override
  int get hashCode =>
      status.hashCode ^
      version.hashCode ^
      apiVersion.hashCode ^
      buildDate.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartHealthCheckResponse &&
          runtimeType == other.runtimeType &&
          status == other.status &&
          version == other.version &&
          apiVersion == other.apiVersion &&
          buildDate == other.buildDate;
}

class DartLoginResponse {
  final String accessToken;
  final String? refreshToken;
  final String expiresAt;
  final String? refreshExpiresAt;
  final DartLoginUserInfo user;

  const DartLoginResponse({
    required this.accessToken,
    this.refreshToken,
    required this.expiresAt,
    this.refreshExpiresAt,
    required this.user,
  });

  @override
  int get hashCode =>
      accessToken.hashCode ^
      refreshToken.hashCode ^
      expiresAt.hashCode ^
      refreshExpiresAt.hashCode ^
      user.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartLoginResponse &&
          runtimeType == other.runtimeType &&
          accessToken == other.accessToken &&
          refreshToken == other.refreshToken &&
          expiresAt == other.expiresAt &&
          refreshExpiresAt == other.refreshExpiresAt &&
          user == other.user;
}

class DartLoginUserInfo {
  final String id;
  final String username;
  final String role;
  final String? email;
  final String createdAt;
  final String updatedAt;

  const DartLoginUserInfo({
    required this.id,
    required this.username,
    required this.role,
    this.email,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      username.hashCode ^
      role.hashCode ^
      email.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartLoginUserInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          username == other.username &&
          role == other.role &&
          email == other.email &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

class DartQueryResponse {
  final bool success;
  final List<DartQueryResult> results;

  /// Execution time in milliseconds.
  final double? tookMs;
  final DartErrorDetail? error;

  const DartQueryResponse({
    required this.success,
    required this.results,
    this.tookMs,
    this.error,
  });

  @override
  int get hashCode =>
      success.hashCode ^ results.hashCode ^ tookMs.hashCode ^ error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartQueryResponse &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          results == other.results &&
          tookMs == other.tookMs &&
          error == other.error;
}

class DartQueryResult {
  final List<DartSchemaField> columns;

  /// Each row is a JSON-encoded string (array of values).
  /// Dart side parses this into typed values.
  final List<String> rowsJson;
  final PlatformInt64 rowCount;
  final String? message;

  const DartQueryResult({
    required this.columns,
    required this.rowsJson,
    required this.rowCount,
    this.message,
  });

  @override
  int get hashCode =>
      columns.hashCode ^
      rowsJson.hashCode ^
      rowCount.hashCode ^
      message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartQueryResult &&
          runtimeType == other.runtimeType &&
          columns == other.columns &&
          rowsJson == other.rowsJson &&
          rowCount == other.rowCount &&
          message == other.message;
}

class DartSchemaField {
  final String name;
  final String dataType;
  final int index;

  /// Comma-separated flag short names, e.g. `"pk,nn,uq"`.
  /// `None` when no flags are present.
  final String? flags;

  const DartSchemaField({
    required this.name,
    required this.dataType,
    required this.index,
    this.flags,
  });

  @override
  int get hashCode =>
      name.hashCode ^ dataType.hashCode ^ index.hashCode ^ flags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartSchemaField &&
          runtimeType == other.runtimeType &&
          name == other.name &&
          dataType == other.dataType &&
          index == other.index &&
          flags == other.flags;
}

class DartServerSetupRequest {
  final String username;
  final String password;
  final String rootPassword;
  final String? email;

  const DartServerSetupRequest({
    required this.username,
    required this.password,
    required this.rootPassword,
    this.email,
  });

  @override
  int get hashCode =>
      username.hashCode ^
      password.hashCode ^
      rootPassword.hashCode ^
      email.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartServerSetupRequest &&
          runtimeType == other.runtimeType &&
          username == other.username &&
          password == other.password &&
          rootPassword == other.rootPassword &&
          email == other.email;
}

class DartServerSetupResponse {
  final String message;
  final DartSetupUserInfo user;

  const DartServerSetupResponse({
    required this.message,
    required this.user,
  });

  @override
  int get hashCode => message.hashCode ^ user.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartServerSetupResponse &&
          runtimeType == other.runtimeType &&
          message == other.message &&
          user == other.user;
}

class DartSetupStatusResponse {
  final bool needsSetup;
  final String message;

  const DartSetupStatusResponse({
    required this.needsSetup,
    required this.message,
  });

  @override
  int get hashCode => needsSetup.hashCode ^ message.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartSetupStatusResponse &&
          runtimeType == other.runtimeType &&
          needsSetup == other.needsSetup &&
          message == other.message;
}

class DartSetupUserInfo {
  final String id;
  final String username;
  final String role;
  final String? email;
  final String createdAt;
  final String updatedAt;

  const DartSetupUserInfo({
    required this.id,
    required this.username,
    required this.role,
    this.email,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      username.hashCode ^
      role.hashCode ^
      email.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartSetupUserInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          username == other.username &&
          role == other.role &&
          email == other.email &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt;
}

/// Subscription configuration.
class DartSubscriptionConfig {
  final String sql;

  /// Optional subscription ID (auto-generated if omitted).
  final String? id;
  final int? batchSize;
  final int? lastRows;

  const DartSubscriptionConfig({
    required this.sql,
    this.id,
    this.batchSize,
    this.lastRows,
  });

  @override
  int get hashCode =>
      sql.hashCode ^ id.hashCode ^ batchSize.hashCode ^ lastRows.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is DartSubscriptionConfig &&
          runtimeType == other.runtimeType &&
          sql == other.sql &&
          id == other.id &&
          batchSize == other.batchSize &&
          lastRows == other.lastRows;
}
