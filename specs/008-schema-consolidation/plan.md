# Implementation Plan: Schema Consolidation & Unified Data Type System

**Branch**: `008-schema-consolidation` | **Date**: 2025-11-01 | **Spec**: [spec.md](./spec.md)  
**Input**: Feature specification from `/specs/008-schema-consolidation/spec.md`

**Note**: This plan was generated by the `/speckit.plan` command following the workflow in `.specify/templates/commands/plan.md`.

## Summary

Consolidate scattered schema models (TableDefinition, ColumnDefinition, SchemaVersion) into a single source of truth in `kalamdb-commons/src/models/schemas/`, introduce unified KalamDataType enum to replace multiple type representations, integrate with EntityStore for persistence, and fix all failing tests across backend/cli/link for Alpha release readiness. This refactoring eliminates schema inconsistencies, reduces codebase complexity by ~30%, improves schema query performance by 10×, and adds vector embedding support (EMBEDDING) for ML/AI workloads.

## Technical Context

**Language/Version**: Rust 1.90+ (stable toolchain, edition 2021)  
**Primary Dependencies**: Apache Arrow 52.0, Apache Parquet 52.0, DataFusion 40.0, RocksDB 0.24, Actix-Web 4.4, serde 1.0, bincode, DashMap (lock-free concurrent HashMap)  
**Storage**: RocksDB 0.24 for EntityStore backend, Parquet files for flushed segments via StorageBackend abstraction  
**Testing**: cargo test (backend unit/integration tests), CLI integration tests (cli/tests/), TypeScript SDK tests (link/sdks/typescript/tests/)  
**Target Platform**: Linux/macOS server (primary), Windows (secondary), WASM target for browser client (link/)  
**Project Type**: Database system with multiple crates (backend server, CLI tool, WASM client library)  
**Performance Goals**: Schema queries <100μs (cached), type conversions <10μs (cached), 99%+ cache hit rate, zero memory leaks under sustained load  
**Constraints**: Zero breaking changes allowed (unreleased Alpha - clean slate), all tests must pass (100% pass rate), memory-efficient (DashMap caching, Arc for shared schemas), sub-millisecond EntityStore reads/writes  
**Scale/Scope**: 13 KalamDataTypes, ~1000 lines of duplicate code to eliminate, 1000+ tables support with efficient caching, 50+ schema versions per table history

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

**Constitution Status**: KalamDB project does not have a formalized constitution.md file yet. The project follows Rust best practices and architectural patterns documented in AGENTS.md:

✅ **Passing Patterns**:
- **Single Source of Truth**: Schema consolidation aligns with eliminating duplication (AGENTS.md: "System Table Models Architecture")
- **Type Safety**: KalamDataType enum enforces type safety via Rust's type system
- **EntityStore Pattern**: Following established Phase 14 architecture for persistence
- **Test-First Mindset**: All 4 user stories include integration test requirements (FR-TEST-009 to 012)
- **Clean Slate Approach**: No backward compatibility needed (unreleased version)

⚠️ **Items to Validate Post-Design**:
- Cache complexity justified by 10× performance improvement target
- DashMap choice validated for lock-free concurrent access patterns
- Embedded schema history justified by infrequent schema changes and atomic update requirements

**Decision**: Proceed with implementation. Constitution check passes based on AGENTS.md architectural principles.

## Project Structure

### Documentation (this feature)

```
specs/008-schema-consolidation/
├── spec.md              # Feature specification (525 lines, 4 user stories, 52 requirements)
├── plan.md              # This file (/speckit.plan command output)
├── research.md          # Phase 0 output - research findings for unknowns
├── data-model.md        # Phase 1 output - entity models and relationships
├── quickstart.md        # Phase 1 output - developer getting started guide
├── contracts/           # Phase 1 output - API contracts (if applicable)
│   └── schema_api.yaml  # OpenAPI spec for schema endpoints
└── tasks.md             # Phase 2 output (/speckit.tasks command - NOT created yet)
```

### Source Code (repository root)

```
backend/
├── crates/
│   ├── kalamdb-commons/          # MAIN TARGET: Schema models consolidation
│   │   ├── src/
│   │   │   ├── models/
│   │   │   │   ├── schemas/      # NEW: Consolidated schema models
│   │   │   │   │   ├── mod.rs
│   │   │   │   │   ├── table_definition.rs
│   │   │   │   │   ├── column_definition.rs
│   │   │   │   │   ├── schema_version.rs
│   │   │   │   │   ├── column_default.rs
│   │   │   │   │   └── table_type.rs  # NEW: SYSTEM/USER/SHARED/STREAM enum We already have enum TableType move it here
│   │   │   │   ├── types/        # NEW: Unified data type system
│   │   │   │   │   ├── mod.rs
│   │   │   │   │   ├── kalam_data_type.rs
│   │   │   │   │   ├── wire_format.rs
│   │   │   │   │   └── arrow_conversion.rs
│   │   │   │   ├── system.rs     # Existing: User, Job, LiveQuery, Namespace
│   │   │   │   └── mod.rs        # Re-export schemas and types
│   │   │   └── constants.rs      # Existing: System user constants
│   │   └── tests/                # Unit tests for schema models
│   │
│   ├── kalamdb-core/             # UPDATE: DataFusion integration + NEW EntityStore
│   │   ├── src/
│   │   │   ├── tables/
│   │   │   │   ├── system/
│   │   │   │   │   ├── schemas/  # NEW: EntityStore<TableId, TableDefinition>
│   │   │   │   │   │   ├── mod.rs
│   │   │   │   │   │   ├── table_schema_store.rs
│   │   │   │   │   │   └── schema_cache.rs  # DashMap-based cache
│   │   │   │   │   ├── tables_v2/  # DELETE: Obsolete with new schema store
│   │   │   │   │   └── information_*.rs  # DELETE: Obsolete files
│   │   │   │   ├── arrow_json_conversion.rs  # UPDATE: Use KalamDataType conversions
│   │   │   │   └── mod.rs
│   │   │   ├── table_provider/
│   │   │   │   └── schema.rs     # UPDATE: Use KalamDataType for Arrow conversion
│   │   │   └── catalog/
│   │   │       └── schema_registry.rs  # UPDATE: Use SchemaCache
│   │   └── tests/                # Core integration tests
│   │
│   ├── kalamdb-sql/              # UPDATE: Use consolidated models from commons
│   │   ├── src/
│   │   │   ├── parser/
│   │   │   │   ├── ddl.rs        # UPDATE: Populate new TableDefinition models
│   │   │   │   └── types.rs      # REMOVE: Old type parsing, use KalamDataType
│   │   │   └── executor/
│   │   │       └── describe.rs   # UPDATE: Use consolidated schema models
│   │   └── tests/                # SQL parser tests
│   │
│   ├── kalamdb-api/              # UPDATE: REST API endpoints use consolidated models
│   │   ├── src/
│   │   │   ├── handlers/
│   │   │   │   └── schema.rs     # UPDATE: DESCRIBE TABLE, information_schema endpoints
│   │   │   └── models/
│   │   │       └── responses.rs  # UPDATE: Schema response DTOs
│   │   └── tests/                # API integration tests
│   │
│   ├── kalamdb-store/            # No schema-specific changes (generic EntityStore traits)
│   └── kalamdb-auth/             # No changes (orthogonal to schema)
│
└── tests/                        # Integration tests
    ├── test_schema_consolidation.rs    # NEW: User Story 1 tests
    ├── test_unified_types.rs           # NEW: User Story 2 tests
    └── test_column_ordering.rs         # NEW: SELECT * ordering tests

cli/
├── src/
│   └── commands/
│       └── describe.rs           # UPDATE: Use consolidated schema models
└── tests/                        # CLI integration tests (must pass 100%)

link/
├── src/
│   └── schema/                   # UPDATE: WASM bindings for schema types
└── sdks/typescript/tests/        # TypeScript SDK tests (must pass 100%)
```

**Structure Decision**: EntityStore for TableDefinition located in `backend/crates/kalamdb-core/src/tables/system/schemas` (NOT kalamdb-store). This is the single source of truth for all schema data. Files to DELETE: `tables_v2/`, `information_*.rs`. File to UPDATE: `arrow_json_conversion.rs` will use new KalamDataType conversions. No secondary indexes needed since TableId is unique and contains namespace.tableName.
    ├── test_unified_types.rs           # NEW: User Story 2 tests
    └── test_column_ordering.rs         # NEW: SELECT * ordering tests

cli/
├── src/
│   └── commands/
│       └── describe.rs           # UPDATE: Use consolidated schema models
└── tests/                        # CLI integration tests (must pass 100%)

link/
├── src/
│   └── schema/                   # UPDATE: WASM bindings for schema types
└── sdks/typescript/tests/        # TypeScript SDK tests (must pass 100%)
```

**Structure Decision**: This is a workspace refactoring across existing crates. Primary changes in `kalamdb-commons` (new models), `kalamdb-store` (EntityStore integration), with updates propagating to `kalamdb-sql`, `kalamdb-core`, `kalamdb-api`. No new top-level crates needed. Structure follows established Phase 14 EntityStore pattern.

## Complexity Tracking

> **Note**: No constitution violations detected. This section documents justified design choices.

| Design Choice | Why Needed | Simpler Alternative Rejected Because |
|---------------|------------|-------------------------------------|
| DashMap for schema cache | Lock-free concurrent access for high-throughput schema queries | Standard HashMap + RwLock has contention under concurrent load, DashMap provides better performance |
| Embedded schema history in TableDefinition | Atomic updates, simpler consistency model, optimal for infrequent schema changes | Separate EntityStore for history adds complexity, worse performance for common case (current schema), potential consistency issues |
| KalamDataType with wire format tags | Efficient serialization, deterministic type representation, extensibility for parameterized types | String-based types cause parsing overhead, no support for EMBEDDING(dimension) parameterization |
| EntityStore in kalamdb-core/src/tables/system/schemas | Single source of truth for schema data, close to DataFusion integration | Separate kalamdb-store location breaks cohesion, schema store should be with table system code |
| No secondary indexes on namespace_id/table_type | TableId is unique and already contains namespace.tableName | Secondary indexes add complexity when TableId uniqueness makes them unnecessary |

---

## Phase 0: Research & Unknowns Resolution

### Research Tasks

Based on the Technical Context, the following research tasks are needed to resolve unknowns and establish best practices:

1. **DashMap Performance Characteristics** (Priority: High)
   - Research: Benchmark DashMap vs RwLock<HashMap> for concurrent schema cache reads
   - Goal: Validate 10× performance improvement claim for cached schema queries
   - Output: Performance comparison with recommendation

2. **EntityStore Secondary Index Patterns** (Priority: High)
   - Research: Review Phase 14 EntityStore implementation for secondary index best practices
   - Goal: Determine how to implement namespace_id and table_type indexes for TableDefinition queries
   - Output: Secondary index implementation pattern

3. **Arrow FixedSizeList for EMBEDDING** (Priority: High)
   - Research: Apache Arrow FixedSizeList API and conversion patterns for vector embeddings
   - Goal: Confirm EMBEDDING(N) → FixedSizeList<Float32> mapping is optimal
   - Output: Arrow conversion implementation approach

4. **Schema History Storage Trade-offs** (Priority: Medium)
   - Research: Compare embedded Vec<SchemaVersion> vs separate EntityStore for history
   - Goal: Validate design decision for embedded history based on workload patterns
   - Output: Storage trade-off analysis with performance implications

5. **Wire Format Versioning** (Priority: Medium)
   - Research: Best practices for wire format tag evolution and backward compatibility
   - Goal: Ensure wire format tags (0x01-0x0D) can evolve without breaking Parquet files
   - Output: Versioning strategy for wire format

6. **Memory Profiling Tools** (Priority: Medium)
   - Research: cargo-instruments, valgrind, heaptrack usage for Rust memory leak detection
   - Goal: Establish memory profiling workflow for FR-QUALITY-006 validation
   - Output: Memory profiling checklist and CI integration approach

### Research Output

All research findings will be consolidated in `research.md` with the following format for each topic:

- **Decision**: [What was chosen]
- **Rationale**: [Why chosen based on evidence]
- **Alternatives Considered**: [What else was evaluated]
- **Performance Impact**: [Measured or estimated performance characteristics]
- **Implementation Notes**: [Key considerations for implementation]

---

## Phase 1: Design & Contracts

### Data Model

The data model will be documented in `data-model.md` with:

1. **Core Entities**:
   - `TableDefinition`: Primary table metadata entity
   - `ColumnDefinition`: Column metadata with ordinal_position
   - `SchemaVersion`: Schema history entry
   - `KalamDataType`: Enum with 13 variants including EMBEDDING
   - `ColumnDefault`: Enum for default value representation

2. **Relationships**:
   - `TableDefinition` contains `Vec<ColumnDefinition>` (sorted by ordinal_position)
   - `TableDefinition` contains `Vec<SchemaVersion>` (schema history)
   - `ColumnDefinition` references `KalamDataType` for data_type field
   - `TableDefinition` stored via `EntityStore<TableId, TableDefinition>`

3. **Validation Rules** (from FR requirements):
   - ordinal_position: 1-indexed, immutable, unique within table
   - EMBEDDING dimension: 1 ≤ dimension ≤ 8192
   - schema_version: incrementing integer, immutable
   - TableId: globally unique, immutable

4. **State Transitions**:
   - CREATE TABLE: TableDefinition created with schema_version = 1
   - ALTER TABLE ADD COLUMN: New ColumnDefinition appended, schema_version incremented, SchemaVersion added to history
   - ALTER TABLE DROP COLUMN: ColumnDefinition removed, schema_version incremented, ordinal_position preserved for remaining columns
   - DROP TABLE: TableDefinition marked as deleted (soft delete pattern from auth system)

### API Contracts

API contracts will be generated in `/contracts/` directory:

1. **schema_api.yaml** (OpenAPI 3.0):
   - `GET /api/v1/tables/{table_name}/schema` - Retrieve table schema
   - `GET /api/v1/information_schema/columns` - Query column metadata
   - `POST /api/v1/tables` - Create table (DDL via SQL or JSON)
   - `PUT /api/v1/tables/{table_name}/schema` - Alter table schema
   - `DELETE /api/v1/tables/{table_name}` - Drop table

2. **Internal Rust APIs**:
   - `SchemaCache::get(table_id: &TableId) -> Option<Arc<TableDefinition>>`
   - `SchemaCache::invalidate(table_id: &TableId)`
   - `TableSchemaStore::create(table_def: TableDefinition) -> Result<TableId>`
   - `TableSchemaStore::get_by_namespace(namespace_id: &NamespaceId) -> Vec<TableDefinition>`
   - `KalamDataType::to_arrow_type() -> DataType`
   - `KalamDataType::from_arrow_type(dt: &DataType) -> Result<KalamDataType>`

### Quickstart Guide

The `quickstart.md` will provide developers with:

1. **Setup Instructions**:
   - Clone repo, checkout `008-schema-consolidation` branch
   - Run `cargo build` to compile with new schema models
   - Run `cargo test -p kalamdb-commons` to verify schema model tests pass

2. **Basic Usage Examples**:
   ```rust
   use kalamdb_commons::schemas::{TableDefinition, ColumnDefinition, KalamDataType};
   
   // Create a table definition
   let table_def = TableDefinition {
       columns: vec![
           ColumnDefinition {
               column_name: "id".into(),
               ordinal_position: 1,
               data_type: KalamDataType::INT,
               is_nullable: false,
               is_primary_key: true,
               // ...
           },
           ColumnDefinition {
               column_name: "embedding".into(),
               ordinal_position: 2,
               data_type: KalamDataType::EMBEDDING(1536), // OpenAI ada-002
               is_nullable: true,
               // ...
           },
       ],
       // ...
   };
   
   // Convert to Arrow schema
   let arrow_schema = table_def.to_arrow_schema()?;
   ```

3. **Testing Workflow**:
   - Run `cargo test -p kalamdb-commons` for schema model unit tests
   - Run `cargo test -p kalamdb-store` for EntityStore integration tests
   - Run `cargo test` in `backend/` for full integration suite
   - Run `cargo test` in `cli/` for CLI tests
   - Run `npm test` in `link/sdks/typescript/` for SDK tests

4. **Common Patterns**:
   - How to add a new KalamDataType variant
   - How to query schemas from SchemaCache
   - How to handle schema versioning in ALTER TABLE operations
   - How to write integration tests for schema changes

### Agent Context Update

After Phase 1 design is complete, the agent context will be updated:

```bash
.specify/scripts/bash/update-agent-context.sh copilot
```

This will update `.github/copilot-instructions.md` with:
- New schema models location: `kalamdb-commons/src/models/schemas/`
- KalamDataType enum with 13 variants
- EntityStore pattern for TableDefinition
- DashMap-based schema caching
- EMBEDDING support for vector embeddings

**Manual additions section will preserve**: Any custom development guidelines added between `<!-- MANUAL ADDITIONS START -->` and `<!-- MANUAL ADDITIONS END -->` markers.

---

## Phase 2: Task Breakdown (Deferred)

Task breakdown will be generated by the `/speckit.tasks` command and output to `tasks.md`. This is NOT created by `/speckit.plan`.

Expected task categories:
1. **Foundation Tasks** (kalamdb-commons): Create schema models, KalamDataType enum, wire format
2. **Storage Tasks** (kalamdb-store): Implement EntityStore, SchemaCache, secondary indexes
3. **Migration Tasks** (kalamdb-sql, kalamdb-core, kalamdb-api): Update code to use consolidated models
4. **Test Tasks** (backend/tests, cli/tests, link/tests): Fix failing tests, add integration tests
5. **Validation Tasks**: Performance benchmarks, memory profiling, cache hit rate validation

---

## Implementation Phases Summary

| Phase | Deliverable | Status | Output Files |
|-------|------------|--------|--------------|
| Phase 0 | Research findings | ✅ Complete | research.md |
| Phase 1 | Design & contracts | ✅ Complete | data-model.md, quickstart.md, contracts/schema_api.yaml |
| Phase 1.5 | Agent context update | ✅ Complete | .github/copilot-instructions.md (updated) |
| Phase 2 | Task breakdown | ⏳ Pending | tasks.md (via `/speckit.tasks` command) |

---

## Next Steps

1. **Review** this plan.md to ensure Technical Context is accurate
2. **Validate** Constitution Check passes architectural principles
3. **Read** research.md for design decision justifications
4. **Read** data-model.md for entity relationships and validation rules
5. **Read** quickstart.md for development workflow
6. **Run** `/speckit.tasks` to generate executable task breakdown in tasks.md

---

**Plan Generated**: 2025-11-01  
**Branch**: 008-schema-consolidation  
**Command**: /speckit.plan  
**Next Command**: /speckit.tasks

---

## Phase 9: User Story 7 - Dynamic Storage Path Resolution & Model Consolidation (Priority: P1)

**Branch**: `008-schema-consolidation` | **Date**: 2025-11-02 | **Added**: Storage path refactoring story

### Summary

Eliminate redundant `storage_location` field from both `SystemTable` and `TableMetadata` models, implement dynamic path resolution via `StorageRegistry` + caching in existing `TableCache`, and consolidate duplicate table models into a single source of truth.

**Goal**: Ensure all flush operations and queries resolve storage paths dynamically from `system.storages` using templates, with resolved paths cached for fast access.

### Architecture Analysis

#### Current State: Dual Models Problem

**SystemTable** (in `kalamdb-commons/src/models/system.rs`):
- Stored in `system.tables` RocksDB CF
- Used by DataFusion providers for schema queries
- Has `storage_location: String` field (redundant)
- Also has `storage_id: Option<StorageId>` field (correct)

**TableMetadata** (in `kalamdb-core/src/catalog/table_metadata.rs`):
- Cached in `TableCache` for fast access
- Used by SQL executor and table providers
- Has `storage_location: String` field (redundant)
- Does NOT have `storage_id` field (missing)

**Problem**: Two separate models for the same concept (table metadata) with conflicting fields.

#### Existing Infrastructure

**SchemaCache** (`backend/crates/kalamdb-core/src/tables/system/schemas/schema_cache.rs`):
- DashMap-based cache for `TableDefinition` (schema-only)
- LRU eviction policy, metrics tracking
- ~440 lines, fully implemented in Phase 3

**TableCache** (`backend/crates/kalamdb-core/src/catalog/table_cache.rs`):
- RwLock-based cache for `TableMetadata` (table config + schema)
- No eviction policy, no metrics
- ~240 lines, minimal implementation
- Has TODO: "load_from_rocksdb not fully implemented"

**StorageRegistry** (`backend/crates/kalamdb-core/src/storage/storage_registry.rs`):
- Queries `system.storages` via KalamSql
- Has `get_storage_config()` that returns full config with templates
- Already handles `default_storage_path` normalization
- Ready to use for path resolution

#### Desired Architecture

**Storage Path Resolution Flow**:
```
1) User queries/flushes table
2) Executor looks up table in TableCache
   ├─ Cache hit: Get cached partial template
   └─ Cache miss: Load from system.tables → resolve partial template → cache result
3) Partial template resolution (if not cached):
   ├─ Read storage_id from table definition
   ├─ Query storage config from StorageRegistry
   ├─ Select template (shared vs user)
   ├─ Substitute STATIC placeholders: {namespace}, {tableName}
   ├─ Keep DYNAMIC placeholders: {userId}, {shard}
   └─ Build partial template: <base_directory>/{namespace}/{tableName}/{userId}/
4) Cache partial template in TableCache (one per table, not per-user)
5) Per-request final resolution (in flush job/query):
   ├─ Get partial template from cache
   ├─ Substitute {userId} with actual user (for user tables)
   ├─ Substitute {shard} with calculated shard (if sharding enabled)
   └─ Use final path for flush/query operation
```

**Example**:
- **Template**: `{namespace}/{tableName}/{userId}`
- **Cached**: `/data/storage/my_namespace/messages/{userId}/` (partial)
- **Runtime** (user_alice): `/data/storage/my_namespace/messages/user_alice/`
- **Runtime** (user_bob): `/data/storage/my_namespace/messages/user_bob/`

**Cache Hierarchy**:
```
SchemaCache (DashMap, schema-only)
   ↓
TableCache (RwLock, schema + config + resolved_path)
   ↓
StorageRegistry (query system.storages when needed)
```

### Decision: Consolidate Models

**Single Source of Truth**: `SystemTable` in `kalamdb-commons/src/models/system.rs`

**Rationale**:
1. SystemTable is the canonical model (stored in RocksDB)
2. TableMetadata is a runtime cache artifact
3. No reason to maintain two separate definitions
4. Simplifies codebase: ~50 fewer files to touch

**Migration Path**:
1. Add `storage_id: Option<StorageId>` to TableMetadata (if missing)
2. Remove `storage_location: String` from both models
3. Extend TableCache to store resolved paths separately
4. Update all consumers to use TableCache for path lookups
5. Eventually: Consider replacing TableMetadata entirely with SystemTable + Arc wrapper

### Implementation Plan

#### Step 1: Extend TableCache with Path Resolution (T180-T185)

**Goal**: Add storage path caching and resolution to existing TableCache

**Files**:
- `backend/crates/kalamdb-core/src/catalog/table_cache.rs`

**Changes**:
```rust
pub struct TableCache {
    tables: Arc<RwLock<HashMap<TableKey, TableMetadata>>>,
    storage_path_templates: Arc<RwLock<HashMap<TableKey, String>>>, // NEW: partial templates
    storage_registry: Option<Arc<StorageRegistry>>,                  // NEW
}

impl TableCache {
    pub fn with_storage_registry(mut self, registry: Arc<StorageRegistry>) -> Self;
    
    /// Returns partial template with {userId}/{shard} unevaluated
    pub fn get_storage_path(
        &self,
        namespace: &NamespaceId,
        table_name: &TableName,
    ) -> Result<String, KalamDbError> {
        // 1. Check cache first
        if let Some(template) = self.storage_path_templates.read().unwrap().get(&key) {
            return Ok(template.clone());
        }
        
        // 2. Load table metadata
        let table = self.get(namespace, table_name)?;
        
        // 3. Resolve PARTIAL template via StorageRegistry
        let partial_template = self.resolve_partial_template(&table)?;
        
        // 4. Cache partial template (one per table)
        self.storage_path_templates.write().unwrap().insert(key, partial_template.clone());
        
        Ok(partial_template)
    }
    
    /// Resolves STATIC placeholders only: {namespace}, {tableName}
    /// Leaves DYNAMIC placeholders: {userId}, {shard}
    fn resolve_partial_template(&self, table: &TableMetadata) -> Result<String, KalamDbError>;
    
    pub fn invalidate_storage_paths(&self); // Clear cache on ALTER TABLE
}
```

#### Step 2: Remove storage_location Field (T186-T190)

**Goal**: Eliminate redundant field from both models

**Files**:
- `backend/crates/kalamdb-commons/src/models/system.rs` (SystemTable)
- `backend/crates/kalamdb-core/src/catalog/table_metadata.rs` (TableMetadata)

**Changes**:
1. Remove `pub storage_location: String` from both structs
2. Add `pub storage_id: Option<StorageId>` to TableMetadata (if missing)
3. Update all constructors and builders
4. Update serialization tests

#### Step 3: Update Service Layer (T191-T195)

**Goal**: Use storage_id instead of resolving paths inline

**Files**:
- `backend/crates/kalamdb-core/src/services/user_table_service.rs`
- `backend/crates/kalamdb-core/src/services/shared_table_service.rs`
- `backend/crates/kalamdb-core/src/services/stream_table_service.rs`

**Changes**:
```rust
// BEFORE:
let storage_location = self.resolve_storage_from_id(&storage_id)?;
let metadata = TableMetadata { storage_location, ... };

// AFTER:
let metadata = TableMetadata { 
    storage_id: Some(storage_id.clone()),
    // storage_location removed
    ...
};
```

#### Step 4: Update Flush Jobs (T196-T200)

**Goal**: Flush jobs resolve paths via TableCache

**Files**:
- `backend/crates/kalamdb-core/src/tables/user_tables/user_table_flush.rs`
- `backend/crates/kalamdb-core/src/tables/shared_tables/shared_table_flush.rs`

**Changes**:
```rust
pub struct UserTableFlushJob {
    table_cache: Arc<TableCache>, // NEW - replaces storage_location field
}

impl UserTableFlushJob {
    fn resolve_storage_path_for_user(&self, user_id: &UserId) -> Result<String, KalamDbError> {
        // 1. Get partial template from cache (e.g., "/data/storage/ns/table/{userId}/")
        let partial_template = self.table_cache.get_storage_path(&self.namespace_id, &self.table_name)?;
        
        // 2. Substitute dynamic placeholders
        let path = partial_template
            .replace("{userId}", user_id.as_str())
            .replace("{shard}", &self.calculate_shard(user_id));
        
        Ok(path)
    }
    
    fn calculate_shard(&self, user_id: &UserId) -> String {
        // Example: hash(user_id) % shard_count
        // Returns: "shard_0", "shard_1", etc.
        format!("shard_{}", (user_id.hash() % self.shard_count))
    }
}
```

#### Step 5: Update SQL Executor (T201-T205)

**Goal**: Executor uses TableCache for path lookups

**Files**:
- `backend/crates/kalamdb-core/src/sql/executor.rs`

**Changes**:
- FLUSH TABLE: Get path from `table_cache.get_storage_path()`
- CREATE TABLE: Set `storage_id`, not `storage_location`
- All table registration: Use storage_id references

#### Step 6: Update System Tables Provider (T206-T210)

**Goal**: Remove storage_location column from system.tables schema

**Files**:
- `backend/crates/kalamdb-core/src/tables/system/tables_v2/tables_table.rs`

**Changes**:
```rust
// Remove from Arrow schema:
// Field::new("storage_location", DataType::Utf8, false),

// Keep:
Field::new("storage_id", DataType::Utf8, true),
```

#### Step 7: Integration Tests (T211-T220)

**Test Coverage**:
1. CREATE TABLE with storage_id → flush → verify correct path used
2. Query table → verify TableCache returns resolved path
3. ALTER TABLE → verify storage path cache invalidated
4. Storage config change → verify paths re-resolved on next query
5. Cache hit rate >99% for 10,000 path resolutions

### Task Summary

**Total Tasks**: ~40 tasks across 7 steps
**Estimated Time**: 6-8 hours
**Priority**: P1 (critical for architecture cleanup)

**Deliverables**:
- ✅ storage_location field removed from both models
- ✅ Dynamic path resolution via StorageRegistry
- ✅ Paths cached in TableCache for performance
- ✅ All tests passing (integration + smoke tests)
- ✅ Zero hardcoded storage paths in codebase

### Benefits

1. **Single Source of Truth**: Storage templates defined once in system.storages
2. **Flexibility**: Change storage config without restarting server
3. **Consistency**: All code uses same path resolution mechanism
4. **Performance**: Cached paths avoid repeated template substitution
5. **Maintainability**: ~50 fewer files referencing storage_location
6. **Correctness**: No risk of stale paths after storage config changes

### Risks & Mitigations

**Risk**: Cache invalidation bugs (stale paths served)  
**Mitigation**: Comprehensive invalidation tests (T115, T211-T220)

**Risk**: Performance regression (path resolution overhead)  
**Mitigation**: Cache-first lookup, measured <1ms overhead for cache miss

**Risk**: Breaking existing tests  
**Mitigation**: Incremental rollout, fix tests in parallel (Phase 5 pattern)

---

**Plan Updated**: 2025-11-02  
**Branch**: 008-schema-consolidation  
**Command**: /speckit.plan  
**Next Command**: /speckit.tasks

````
