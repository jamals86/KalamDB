// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;


#[allow(unused_imports, dead_code)]
pub mod kalamdb {

#[allow(unused_imports, dead_code)]
pub mod serialization {

#[allow(unused_imports, dead_code)]
pub mod row {


#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_SCALAR_TAG: u16 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_SCALAR_TAG: u16 = 24;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_SCALAR_TAG: [ScalarTag; 25] = [
  ScalarTag::Null,
  ScalarTag::Boolean,
  ScalarTag::Float32,
  ScalarTag::Float64,
  ScalarTag::Int8,
  ScalarTag::Int16,
  ScalarTag::Int32,
  ScalarTag::Int64,
  ScalarTag::UInt8,
  ScalarTag::UInt16,
  ScalarTag::UInt32,
  ScalarTag::UInt64,
  ScalarTag::Utf8,
  ScalarTag::LargeUtf8,
  ScalarTag::Binary,
  ScalarTag::LargeBinary,
  ScalarTag::FixedSizeBinary,
  ScalarTag::Date32,
  ScalarTag::Time64Microsecond,
  ScalarTag::TimestampMillisecond,
  ScalarTag::TimestampMicrosecond,
  ScalarTag::TimestampNanosecond,
  ScalarTag::Decimal128,
  ScalarTag::Embedding,
  ScalarTag::Fallback,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct ScalarTag(pub u16);
#[allow(non_upper_case_globals)]
impl ScalarTag {
  pub const Null: Self = Self(0);
  pub const Boolean: Self = Self(1);
  pub const Float32: Self = Self(2);
  pub const Float64: Self = Self(3);
  pub const Int8: Self = Self(4);
  pub const Int16: Self = Self(5);
  pub const Int32: Self = Self(6);
  pub const Int64: Self = Self(7);
  pub const UInt8: Self = Self(8);
  pub const UInt16: Self = Self(9);
  pub const UInt32: Self = Self(10);
  pub const UInt64: Self = Self(11);
  pub const Utf8: Self = Self(12);
  pub const LargeUtf8: Self = Self(13);
  pub const Binary: Self = Self(14);
  pub const LargeBinary: Self = Self(15);
  pub const FixedSizeBinary: Self = Self(16);
  pub const Date32: Self = Self(17);
  pub const Time64Microsecond: Self = Self(18);
  pub const TimestampMillisecond: Self = Self(19);
  pub const TimestampMicrosecond: Self = Self(20);
  pub const TimestampNanosecond: Self = Self(21);
  pub const Decimal128: Self = Self(22);
  pub const Embedding: Self = Self(23);
  pub const Fallback: Self = Self(24);

  pub const ENUM_MIN: u16 = 0;
  pub const ENUM_MAX: u16 = 24;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Null,
    Self::Boolean,
    Self::Float32,
    Self::Float64,
    Self::Int8,
    Self::Int16,
    Self::Int32,
    Self::Int64,
    Self::UInt8,
    Self::UInt16,
    Self::UInt32,
    Self::UInt64,
    Self::Utf8,
    Self::LargeUtf8,
    Self::Binary,
    Self::LargeBinary,
    Self::FixedSizeBinary,
    Self::Date32,
    Self::Time64Microsecond,
    Self::TimestampMillisecond,
    Self::TimestampMicrosecond,
    Self::TimestampNanosecond,
    Self::Decimal128,
    Self::Embedding,
    Self::Fallback,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Null => Some("Null"),
      Self::Boolean => Some("Boolean"),
      Self::Float32 => Some("Float32"),
      Self::Float64 => Some("Float64"),
      Self::Int8 => Some("Int8"),
      Self::Int16 => Some("Int16"),
      Self::Int32 => Some("Int32"),
      Self::Int64 => Some("Int64"),
      Self::UInt8 => Some("UInt8"),
      Self::UInt16 => Some("UInt16"),
      Self::UInt32 => Some("UInt32"),
      Self::UInt64 => Some("UInt64"),
      Self::Utf8 => Some("Utf8"),
      Self::LargeUtf8 => Some("LargeUtf8"),
      Self::Binary => Some("Binary"),
      Self::LargeBinary => Some("LargeBinary"),
      Self::FixedSizeBinary => Some("FixedSizeBinary"),
      Self::Date32 => Some("Date32"),
      Self::Time64Microsecond => Some("Time64Microsecond"),
      Self::TimestampMillisecond => Some("TimestampMillisecond"),
      Self::TimestampMicrosecond => Some("TimestampMicrosecond"),
      Self::TimestampNanosecond => Some("TimestampNanosecond"),
      Self::Decimal128 => Some("Decimal128"),
      Self::Embedding => Some("Embedding"),
      Self::Fallback => Some("Fallback"),
      _ => None,
    }
  }
}
impl ::core::fmt::Debug for ScalarTag {
  fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> ::flatbuffers::Follow<'a> for ScalarTag {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { ::flatbuffers::read_scalar_at::<u16>(buf, loc) };
    Self(b)
  }
}

impl ::flatbuffers::Push for ScalarTag {
    type Output = ScalarTag;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { ::flatbuffers::emplace_scalar::<u16>(dst, self.0) };
    }
}

impl ::flatbuffers::EndianScalar for ScalarTag {
  type Scalar = u16;
  #[inline]
  fn to_little_endian(self) -> u16 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u16) -> Self {
    let b = u16::from_le(v);
    Self(b)
  }
}

impl<'a> ::flatbuffers::Verifiable for ScalarTag {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    u16::run_verifier(v, pos)
  }
}

impl ::flatbuffers::SimpleToVerifyInSlice for ScalarTag {}
pub enum ScalarValuePayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ScalarValuePayload<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for ScalarValuePayload<'a> {
  type Inner = ScalarValuePayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ScalarValuePayload<'a> {
  pub const VT_TAG: ::flatbuffers::VOffsetT = 4;
  pub const VT_PAYLOAD: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    ScalarValuePayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ScalarValuePayloadArgs<'args>
  ) -> ::flatbuffers::WIPOffset<ScalarValuePayload<'bldr>> {
    let mut builder = ScalarValuePayloadBuilder::new(_fbb);
    if let Some(x) = args.payload { builder.add_payload(x); }
    builder.add_tag(args.tag);
    builder.finish()
  }


  #[inline]
  pub fn tag(&self) -> ScalarTag {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<ScalarTag>(ScalarValuePayload::VT_TAG, Some(ScalarTag::Null)).unwrap()}
  }
  #[inline]
  pub fn payload(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(ScalarValuePayload::VT_PAYLOAD, None)}
  }
}

impl ::flatbuffers::Verifiable for ScalarValuePayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<ScalarTag>("tag", Self::VT_TAG, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("payload", Self::VT_PAYLOAD, false)?
     .finish();
    Ok(())
  }
}
pub struct ScalarValuePayloadArgs<'a> {
    pub tag: ScalarTag,
    pub payload: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ScalarValuePayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    ScalarValuePayloadArgs {
      tag: ScalarTag::Null,
      payload: None,
    }
  }
}

pub struct ScalarValuePayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ScalarValuePayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tag(&mut self, tag: ScalarTag) {
    self.fbb_.push_slot::<ScalarTag>(ScalarValuePayload::VT_TAG, tag, ScalarTag::Null);
  }
  #[inline]
  pub fn add_payload(&mut self, payload: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(ScalarValuePayload::VT_PAYLOAD, payload);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ScalarValuePayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ScalarValuePayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<ScalarValuePayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for ScalarValuePayload<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("ScalarValuePayload");
      ds.field("tag", &self.tag());
      ds.field("payload", &self.payload());
      ds.finish()
  }
}
pub enum ColumnValueOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ColumnValue<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for ColumnValue<'a> {
  type Inner = ColumnValue<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ColumnValue<'a> {
  pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
  pub const VT_VALUE: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    ColumnValue { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ColumnValueArgs<'args>
  ) -> ::flatbuffers::WIPOffset<ColumnValue<'bldr>> {
    let mut builder = ColumnValueBuilder::new(_fbb);
    if let Some(x) = args.value { builder.add_value(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(ColumnValue::VT_NAME, None)}
  }
  #[inline]
  pub fn value(&self) -> Option<ScalarValuePayload<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<ScalarValuePayload>>(ColumnValue::VT_VALUE, None)}
  }
}

impl ::flatbuffers::Verifiable for ColumnValue<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<ScalarValuePayload>>("value", Self::VT_VALUE, false)?
     .finish();
    Ok(())
  }
}
pub struct ColumnValueArgs<'a> {
    pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub value: Option<::flatbuffers::WIPOffset<ScalarValuePayload<'a>>>,
}
impl<'a> Default for ColumnValueArgs<'a> {
  #[inline]
  fn default() -> Self {
    ColumnValueArgs {
      name: None,
      value: None,
    }
  }
}

pub struct ColumnValueBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ColumnValueBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(ColumnValue::VT_NAME, name);
  }
  #[inline]
  pub fn add_value(&mut self, value: ::flatbuffers::WIPOffset<ScalarValuePayload<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<ScalarValuePayload>>(ColumnValue::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ColumnValueBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ColumnValueBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<ColumnValue<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for ColumnValue<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("ColumnValue");
      ds.field("name", &self.name());
      ds.field("value", &self.value());
      ds.finish()
  }
}
pub enum RowPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct RowPayload<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for RowPayload<'a> {
  type Inner = RowPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> RowPayload<'a> {
  pub const VT_COLUMNS: ::flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    RowPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args RowPayloadArgs<'args>
  ) -> ::flatbuffers::WIPOffset<RowPayload<'bldr>> {
    let mut builder = RowPayloadBuilder::new(_fbb);
    if let Some(x) = args.columns { builder.add_columns(x); }
    builder.finish()
  }


  #[inline]
  pub fn columns(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ColumnValue<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ColumnValue>>>>(RowPayload::VT_COLUMNS, None)}
  }
}

impl ::flatbuffers::Verifiable for RowPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<ColumnValue>>>>("columns", Self::VT_COLUMNS, false)?
     .finish();
    Ok(())
  }
}
pub struct RowPayloadArgs<'a> {
    pub columns: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ColumnValue<'a>>>>>,
}
impl<'a> Default for RowPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    RowPayloadArgs {
      columns: None,
    }
  }
}

pub struct RowPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> RowPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_columns(&mut self, columns: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<ColumnValue<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(RowPayload::VT_COLUMNS, columns);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> RowPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    RowPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<RowPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for RowPayload<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("RowPayload");
      ds.field("columns", &self.columns());
      ds.finish()
  }
}
pub enum UserTableRowPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct UserTableRowPayload<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for UserTableRowPayload<'a> {
  type Inner = UserTableRowPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> UserTableRowPayload<'a> {
  pub const VT_USER_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_SEQ: ::flatbuffers::VOffsetT = 6;
  pub const VT_DELETED: ::flatbuffers::VOffsetT = 8;
  pub const VT_FIELDS: ::flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    UserTableRowPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args UserTableRowPayloadArgs<'args>
  ) -> ::flatbuffers::WIPOffset<UserTableRowPayload<'bldr>> {
    let mut builder = UserTableRowPayloadBuilder::new(_fbb);
    builder.add_seq(args.seq);
    if let Some(x) = args.fields { builder.add_fields(x); }
    if let Some(x) = args.user_id { builder.add_user_id(x); }
    builder.add_deleted(args.deleted);
    builder.finish()
  }


  #[inline]
  pub fn user_id(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(UserTableRowPayload::VT_USER_ID, None)}
  }
  #[inline]
  pub fn seq(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(UserTableRowPayload::VT_SEQ, Some(0)).unwrap()}
  }
  #[inline]
  pub fn deleted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(UserTableRowPayload::VT_DELETED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn fields(&self) -> Option<RowPayload<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<RowPayload>>(UserTableRowPayload::VT_FIELDS, None)}
  }
}

impl ::flatbuffers::Verifiable for UserTableRowPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("user_id", Self::VT_USER_ID, false)?
     .visit_field::<i64>("seq", Self::VT_SEQ, false)?
     .visit_field::<bool>("deleted", Self::VT_DELETED, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<RowPayload>>("fields", Self::VT_FIELDS, false)?
     .finish();
    Ok(())
  }
}
pub struct UserTableRowPayloadArgs<'a> {
    pub user_id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub seq: i64,
    pub deleted: bool,
    pub fields: Option<::flatbuffers::WIPOffset<RowPayload<'a>>>,
}
impl<'a> Default for UserTableRowPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    UserTableRowPayloadArgs {
      user_id: None,
      seq: 0,
      deleted: false,
      fields: None,
    }
  }
}

pub struct UserTableRowPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> UserTableRowPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_user_id(&mut self, user_id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(UserTableRowPayload::VT_USER_ID, user_id);
  }
  #[inline]
  pub fn add_seq(&mut self, seq: i64) {
    self.fbb_.push_slot::<i64>(UserTableRowPayload::VT_SEQ, seq, 0);
  }
  #[inline]
  pub fn add_deleted(&mut self, deleted: bool) {
    self.fbb_.push_slot::<bool>(UserTableRowPayload::VT_DELETED, deleted, false);
  }
  #[inline]
  pub fn add_fields(&mut self, fields: ::flatbuffers::WIPOffset<RowPayload<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<RowPayload>>(UserTableRowPayload::VT_FIELDS, fields);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> UserTableRowPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    UserTableRowPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<UserTableRowPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for UserTableRowPayload<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("UserTableRowPayload");
      ds.field("user_id", &self.user_id());
      ds.field("seq", &self.seq());
      ds.field("deleted", &self.deleted());
      ds.field("fields", &self.fields());
      ds.finish()
  }
}
pub enum SharedTableRowPayloadOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SharedTableRowPayload<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for SharedTableRowPayload<'a> {
  type Inner = SharedTableRowPayload<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SharedTableRowPayload<'a> {
  pub const VT_SEQ: ::flatbuffers::VOffsetT = 4;
  pub const VT_DELETED: ::flatbuffers::VOffsetT = 6;
  pub const VT_FIELDS: ::flatbuffers::VOffsetT = 8;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    SharedTableRowPayload { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SharedTableRowPayloadArgs<'args>
  ) -> ::flatbuffers::WIPOffset<SharedTableRowPayload<'bldr>> {
    let mut builder = SharedTableRowPayloadBuilder::new(_fbb);
    builder.add_seq(args.seq);
    if let Some(x) = args.fields { builder.add_fields(x); }
    builder.add_deleted(args.deleted);
    builder.finish()
  }


  #[inline]
  pub fn seq(&self) -> i64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i64>(SharedTableRowPayload::VT_SEQ, Some(0)).unwrap()}
  }
  #[inline]
  pub fn deleted(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(SharedTableRowPayload::VT_DELETED, Some(false)).unwrap()}
  }
  #[inline]
  pub fn fields(&self) -> Option<RowPayload<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<RowPayload>>(SharedTableRowPayload::VT_FIELDS, None)}
  }
}

impl ::flatbuffers::Verifiable for SharedTableRowPayload<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i64>("seq", Self::VT_SEQ, false)?
     .visit_field::<bool>("deleted", Self::VT_DELETED, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<RowPayload>>("fields", Self::VT_FIELDS, false)?
     .finish();
    Ok(())
  }
}
pub struct SharedTableRowPayloadArgs<'a> {
    pub seq: i64,
    pub deleted: bool,
    pub fields: Option<::flatbuffers::WIPOffset<RowPayload<'a>>>,
}
impl<'a> Default for SharedTableRowPayloadArgs<'a> {
  #[inline]
  fn default() -> Self {
    SharedTableRowPayloadArgs {
      seq: 0,
      deleted: false,
      fields: None,
    }
  }
}

pub struct SharedTableRowPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SharedTableRowPayloadBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_seq(&mut self, seq: i64) {
    self.fbb_.push_slot::<i64>(SharedTableRowPayload::VT_SEQ, seq, 0);
  }
  #[inline]
  pub fn add_deleted(&mut self, deleted: bool) {
    self.fbb_.push_slot::<bool>(SharedTableRowPayload::VT_DELETED, deleted, false);
  }
  #[inline]
  pub fn add_fields(&mut self, fields: ::flatbuffers::WIPOffset<RowPayload<'b >>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<RowPayload>>(SharedTableRowPayload::VT_FIELDS, fields);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> SharedTableRowPayloadBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SharedTableRowPayloadBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<SharedTableRowPayload<'a>> {
    let o = self.fbb_.end_table(self.start_);
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for SharedTableRowPayload<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("SharedTableRowPayload");
      ds.field("seq", &self.seq());
      ds.field("deleted", &self.deleted());
      ds.field("fields", &self.fields());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `RowPayload`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_row_payload_unchecked`.
pub fn root_as_row_payload(buf: &[u8]) -> Result<RowPayload<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<RowPayload>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `RowPayload` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_row_payload_unchecked`.
pub fn size_prefixed_root_as_row_payload(buf: &[u8]) -> Result<RowPayload<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<RowPayload>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `RowPayload` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_row_payload_unchecked`.
pub fn root_as_row_payload_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RowPayload<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<RowPayload<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `RowPayload` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_row_payload_unchecked`.
pub fn size_prefixed_root_as_row_payload_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<RowPayload<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<RowPayload<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a RowPayload and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `RowPayload`.
pub unsafe fn root_as_row_payload_unchecked(buf: &[u8]) -> RowPayload<'_> {
  unsafe { ::flatbuffers::root_unchecked::<RowPayload>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed RowPayload and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `RowPayload`.
pub unsafe fn size_prefixed_root_as_row_payload_unchecked(buf: &[u8]) -> RowPayload<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<RowPayload>(buf) }
}
pub const ROW_PAYLOAD_IDENTIFIER: &str = "KROW";

#[inline]
pub fn row_payload_buffer_has_identifier(buf: &[u8]) -> bool {
  ::flatbuffers::buffer_has_identifier(buf, ROW_PAYLOAD_IDENTIFIER, false)
}

#[inline]
pub fn row_payload_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  ::flatbuffers::buffer_has_identifier(buf, ROW_PAYLOAD_IDENTIFIER, true)
}

#[inline]
pub fn finish_row_payload_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<RowPayload<'a>>) {
  fbb.finish(root, Some(ROW_PAYLOAD_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_row_payload_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<RowPayload<'a>>) {
  fbb.finish_size_prefixed(root, Some(ROW_PAYLOAD_IDENTIFIER));
}
}  // pub mod row
}  // pub mod serialization
}  // pub mod kalamdb

