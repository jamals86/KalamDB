// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;

#[allow(unused_imports, dead_code)]
pub mod kalamdb {

    #[allow(unused_imports, dead_code)]
    pub mod serialization {

        #[allow(unused_imports, dead_code)]
        pub mod row {

            #[deprecated(
                since = "2.0.0",
                note = "Use associated constants instead. This will no longer be generated in 2021."
            )]
            pub const ENUM_MIN_SCALAR_TAG: u16 = 0;
            #[deprecated(
                since = "2.0.0",
                note = "Use associated constants instead. This will no longer be generated in 2021."
            )]
            pub const ENUM_MAX_SCALAR_TAG: u16 = 24;
            #[deprecated(
                since = "2.0.0",
                note = "Use associated constants instead. This will no longer be generated in 2021."
            )]
            #[allow(non_camel_case_types)]
            pub const ENUM_VALUES_SCALAR_TAG: [ScalarTag; 25] = [
                ScalarTag::Null,
                ScalarTag::Boolean,
                ScalarTag::Float32,
                ScalarTag::Float64,
                ScalarTag::Int8,
                ScalarTag::Int16,
                ScalarTag::Int32,
                ScalarTag::Int64,
                ScalarTag::UInt8,
                ScalarTag::UInt16,
                ScalarTag::UInt32,
                ScalarTag::UInt64,
                ScalarTag::Utf8,
                ScalarTag::LargeUtf8,
                ScalarTag::Binary,
                ScalarTag::LargeBinary,
                ScalarTag::FixedSizeBinary,
                ScalarTag::Date32,
                ScalarTag::Time64Microsecond,
                ScalarTag::TimestampMillisecond,
                ScalarTag::TimestampMicrosecond,
                ScalarTag::TimestampNanosecond,
                ScalarTag::Decimal128,
                ScalarTag::Embedding,
                ScalarTag::Fallback,
            ];

            #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
            #[repr(transparent)]
            pub struct ScalarTag(pub u16);
            #[allow(non_upper_case_globals)]
            impl ScalarTag {
                pub const Null: Self = Self(0);
                pub const Boolean: Self = Self(1);
                pub const Float32: Self = Self(2);
                pub const Float64: Self = Self(3);
                pub const Int8: Self = Self(4);
                pub const Int16: Self = Self(5);
                pub const Int32: Self = Self(6);
                pub const Int64: Self = Self(7);
                pub const UInt8: Self = Self(8);
                pub const UInt16: Self = Self(9);
                pub const UInt32: Self = Self(10);
                pub const UInt64: Self = Self(11);
                pub const Utf8: Self = Self(12);
                pub const LargeUtf8: Self = Self(13);
                pub const Binary: Self = Self(14);
                pub const LargeBinary: Self = Self(15);
                pub const FixedSizeBinary: Self = Self(16);
                pub const Date32: Self = Self(17);
                pub const Time64Microsecond: Self = Self(18);
                pub const TimestampMillisecond: Self = Self(19);
                pub const TimestampMicrosecond: Self = Self(20);
                pub const TimestampNanosecond: Self = Self(21);
                pub const Decimal128: Self = Self(22);
                pub const Embedding: Self = Self(23);
                pub const Fallback: Self = Self(24);

                pub const ENUM_MIN: u16 = 0;
                pub const ENUM_MAX: u16 = 24;
                pub const ENUM_VALUES: &'static [Self] = &[
                    Self::Null,
                    Self::Boolean,
                    Self::Float32,
                    Self::Float64,
                    Self::Int8,
                    Self::Int16,
                    Self::Int32,
                    Self::Int64,
                    Self::UInt8,
                    Self::UInt16,
                    Self::UInt32,
                    Self::UInt64,
                    Self::Utf8,
                    Self::LargeUtf8,
                    Self::Binary,
                    Self::LargeBinary,
                    Self::FixedSizeBinary,
                    Self::Date32,
                    Self::Time64Microsecond,
                    Self::TimestampMillisecond,
                    Self::TimestampMicrosecond,
                    Self::TimestampNanosecond,
                    Self::Decimal128,
                    Self::Embedding,
                    Self::Fallback,
                ];
                /// Returns the variant's name or "" if unknown.
                pub fn variant_name(self) -> Option<&'static str> {
                    match self {
                        Self::Null => Some("Null"),
                        Self::Boolean => Some("Boolean"),
                        Self::Float32 => Some("Float32"),
                        Self::Float64 => Some("Float64"),
                        Self::Int8 => Some("Int8"),
                        Self::Int16 => Some("Int16"),
                        Self::Int32 => Some("Int32"),
                        Self::Int64 => Some("Int64"),
                        Self::UInt8 => Some("UInt8"),
                        Self::UInt16 => Some("UInt16"),
                        Self::UInt32 => Some("UInt32"),
                        Self::UInt64 => Some("UInt64"),
                        Self::Utf8 => Some("Utf8"),
                        Self::LargeUtf8 => Some("LargeUtf8"),
                        Self::Binary => Some("Binary"),
                        Self::LargeBinary => Some("LargeBinary"),
                        Self::FixedSizeBinary => Some("FixedSizeBinary"),
                        Self::Date32 => Some("Date32"),
                        Self::Time64Microsecond => Some("Time64Microsecond"),
                        Self::TimestampMillisecond => Some("TimestampMillisecond"),
                        Self::TimestampMicrosecond => Some("TimestampMicrosecond"),
                        Self::TimestampNanosecond => Some("TimestampNanosecond"),
                        Self::Decimal128 => Some("Decimal128"),
                        Self::Embedding => Some("Embedding"),
                        Self::Fallback => Some("Fallback"),
                        _ => None,
                    }
                }
            }
            impl ::core::fmt::Debug for ScalarTag {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    if let Some(name) = self.variant_name() {
                        f.write_str(name)
                    } else {
                        f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
                    }
                }
            }
            impl<'a> ::flatbuffers::Follow<'a> for ScalarTag {
                type Inner = Self;
                #[inline]
                unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                    let b = unsafe { ::flatbuffers::read_scalar_at::<u16>(buf, loc) };
                    Self(b)
                }
            }

            impl ::flatbuffers::Push for ScalarTag {
                type Output = ScalarTag;
                #[inline]
                unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
                    unsafe { ::flatbuffers::emplace_scalar::<u16>(dst, self.0) };
                }
            }

            impl ::flatbuffers::EndianScalar for ScalarTag {
                type Scalar = u16;
                #[inline]
                fn to_little_endian(self) -> u16 {
                    self.0.to_le()
                }
                #[inline]
                #[allow(clippy::wrong_self_convention)]
                fn from_little_endian(v: u16) -> Self {
                    let b = u16::from_le(v);
                    Self(b)
                }
            }

            impl<'a> ::flatbuffers::Verifiable for ScalarTag {
                #[inline]
                fn run_verifier(
                    v: &mut ::flatbuffers::Verifier,
                    pos: usize,
                ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                    u16::run_verifier(v, pos)
                }
            }

            impl ::flatbuffers::SimpleToVerifyInSlice for ScalarTag {}
            pub enum ScalarValuePayloadOffset {}
            #[derive(Copy, Clone, PartialEq)]

            pub struct ScalarValuePayload<'a> {
                pub _tab: ::flatbuffers::Table<'a>,
            }

            impl<'a> ::flatbuffers::Follow<'a> for ScalarValuePayload<'a> {
                type Inner = ScalarValuePayload<'a>;
                #[inline]
                unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                    Self {
                        _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                    }
                }
            }

            impl<'a> ScalarValuePayload<'a> {
                pub const VT_TAG: ::flatbuffers::VOffsetT = 4;
                pub const VT_IS_NULL: ::flatbuffers::VOffsetT = 6;
                pub const VT_BOOL_VALUE: ::flatbuffers::VOffsetT = 8;
                pub const VT_I8_VALUE: ::flatbuffers::VOffsetT = 10;
                pub const VT_I16_VALUE: ::flatbuffers::VOffsetT = 12;
                pub const VT_I32_VALUE: ::flatbuffers::VOffsetT = 14;
                pub const VT_I64_VALUE: ::flatbuffers::VOffsetT = 16;
                pub const VT_U8_VALUE: ::flatbuffers::VOffsetT = 18;
                pub const VT_U16_VALUE: ::flatbuffers::VOffsetT = 20;
                pub const VT_U32_VALUE: ::flatbuffers::VOffsetT = 22;
                pub const VT_U64_VALUE: ::flatbuffers::VOffsetT = 24;
                pub const VT_F32_VALUE: ::flatbuffers::VOffsetT = 26;
                pub const VT_F64_VALUE: ::flatbuffers::VOffsetT = 28;
                pub const VT_TEXT_VALUE: ::flatbuffers::VOffsetT = 30;
                pub const VT_BYTES_VALUE: ::flatbuffers::VOffsetT = 32;
                pub const VT_FIXED_SIZE: ::flatbuffers::VOffsetT = 34;
                pub const VT_TIMEZONE: ::flatbuffers::VOffsetT = 36;
                pub const VT_DECIMAL_PRECISION: ::flatbuffers::VOffsetT = 38;
                pub const VT_DECIMAL_SCALE: ::flatbuffers::VOffsetT = 40;
                pub const VT_EMBEDDING_SIZE: ::flatbuffers::VOffsetT = 42;
                pub const VT_EMBEDDING_VALUES: ::flatbuffers::VOffsetT = 44;
                pub const VT_EMBEDDING_VALID: ::flatbuffers::VOffsetT = 46;

                #[inline]
                pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                    ScalarValuePayload { _tab: table }
                }
                #[allow(unused_mut)]
                pub fn create<
                    'bldr: 'args,
                    'args: 'mut_bldr,
                    'mut_bldr,
                    A: ::flatbuffers::Allocator + 'bldr,
                >(
                    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                    args: &'args ScalarValuePayloadArgs<'args>,
                ) -> ::flatbuffers::WIPOffset<ScalarValuePayload<'bldr>> {
                    let mut builder = ScalarValuePayloadBuilder::new(_fbb);
                    builder.add_f64_value(args.f64_value);
                    builder.add_u64_value(args.u64_value);
                    builder.add_i64_value(args.i64_value);
                    if let Some(x) = args.embedding_valid {
                        builder.add_embedding_valid(x);
                    }
                    if let Some(x) = args.embedding_values {
                        builder.add_embedding_values(x);
                    }
                    builder.add_embedding_size(args.embedding_size);
                    if let Some(x) = args.timezone {
                        builder.add_timezone(x);
                    }
                    builder.add_fixed_size(args.fixed_size);
                    if let Some(x) = args.bytes_value {
                        builder.add_bytes_value(x);
                    }
                    if let Some(x) = args.text_value {
                        builder.add_text_value(x);
                    }
                    builder.add_f32_value(args.f32_value);
                    builder.add_u32_value(args.u32_value);
                    builder.add_i32_value(args.i32_value);
                    builder.add_u16_value(args.u16_value);
                    builder.add_i16_value(args.i16_value);
                    builder.add_tag(args.tag);
                    builder.add_decimal_scale(args.decimal_scale);
                    builder.add_decimal_precision(args.decimal_precision);
                    builder.add_u8_value(args.u8_value);
                    builder.add_i8_value(args.i8_value);
                    builder.add_bool_value(args.bool_value);
                    builder.add_is_null(args.is_null);
                    builder.finish()
                }

                #[inline]
                pub fn tag(&self) -> ScalarTag {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab
                            .get::<ScalarTag>(ScalarValuePayload::VT_TAG, Some(ScalarTag::Null))
                            .unwrap()
                    }
                }
                #[inline]
                pub fn is_null(&self) -> bool {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<bool>(ScalarValuePayload::VT_IS_NULL, Some(false)).unwrap()
                    }
                }
                #[inline]
                pub fn bool_value(&self) -> bool {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab
                            .get::<bool>(ScalarValuePayload::VT_BOOL_VALUE, Some(false))
                            .unwrap()
                    }
                }
                #[inline]
                pub fn i8_value(&self) -> i8 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<i8>(ScalarValuePayload::VT_I8_VALUE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn i16_value(&self) -> i16 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<i16>(ScalarValuePayload::VT_I16_VALUE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn i32_value(&self) -> i32 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<i32>(ScalarValuePayload::VT_I32_VALUE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn i64_value(&self) -> i64 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<i64>(ScalarValuePayload::VT_I64_VALUE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn u8_value(&self) -> u8 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<u8>(ScalarValuePayload::VT_U8_VALUE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn u16_value(&self) -> u16 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<u16>(ScalarValuePayload::VT_U16_VALUE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn u32_value(&self) -> u32 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<u32>(ScalarValuePayload::VT_U32_VALUE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn u64_value(&self) -> u64 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<u64>(ScalarValuePayload::VT_U64_VALUE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn f32_value(&self) -> f32 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<f32>(ScalarValuePayload::VT_F32_VALUE, Some(0.0)).unwrap()
                    }
                }
                #[inline]
                pub fn f64_value(&self) -> f64 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<f64>(ScalarValuePayload::VT_F64_VALUE, Some(0.0)).unwrap()
                    }
                }
                #[inline]
                pub fn text_value(&self) -> Option<&'a str> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                            ScalarValuePayload::VT_TEXT_VALUE,
                            None,
                        )
                    }
                }
                #[inline]
                pub fn bytes_value(&self) -> Option<::flatbuffers::Vector<'a, u8>> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab
                            .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, u8>>>(
                                ScalarValuePayload::VT_BYTES_VALUE,
                                None,
                            )
                    }
                }
                #[inline]
                pub fn fixed_size(&self) -> i32 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<i32>(ScalarValuePayload::VT_FIXED_SIZE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn timezone(&self) -> Option<&'a str> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                            ScalarValuePayload::VT_TIMEZONE,
                            None,
                        )
                    }
                }
                #[inline]
                pub fn decimal_precision(&self) -> u8 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab
                            .get::<u8>(ScalarValuePayload::VT_DECIMAL_PRECISION, Some(0))
                            .unwrap()
                    }
                }
                #[inline]
                pub fn decimal_scale(&self) -> i8 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<i8>(ScalarValuePayload::VT_DECIMAL_SCALE, Some(0)).unwrap()
                    }
                }
                #[inline]
                pub fn embedding_size(&self) -> i32 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab
                            .get::<i32>(ScalarValuePayload::VT_EMBEDDING_SIZE, Some(0))
                            .unwrap()
                    }
                }
                #[inline]
                pub fn embedding_values(&self) -> Option<::flatbuffers::Vector<'a, f32>> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab
                            .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, f32>>>(
                                ScalarValuePayload::VT_EMBEDDING_VALUES,
                                None,
                            )
                    }
                }
                #[inline]
                pub fn embedding_valid(&self) -> Option<::flatbuffers::Vector<'a, bool>> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab
                            .get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, bool>>>(
                                ScalarValuePayload::VT_EMBEDDING_VALID,
                                None,
                            )
                    }
                }
            }

            impl ::flatbuffers::Verifiable for ScalarValuePayload<'_> {
                #[inline]
                fn run_verifier(
                    v: &mut ::flatbuffers::Verifier,
                    pos: usize,
                ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                    v.visit_table(pos)?
     .visit_field::<ScalarTag>("tag", Self::VT_TAG, false)?
     .visit_field::<bool>("is_null", Self::VT_IS_NULL, false)?
     .visit_field::<bool>("bool_value", Self::VT_BOOL_VALUE, false)?
     .visit_field::<i8>("i8_value", Self::VT_I8_VALUE, false)?
     .visit_field::<i16>("i16_value", Self::VT_I16_VALUE, false)?
     .visit_field::<i32>("i32_value", Self::VT_I32_VALUE, false)?
     .visit_field::<i64>("i64_value", Self::VT_I64_VALUE, false)?
     .visit_field::<u8>("u8_value", Self::VT_U8_VALUE, false)?
     .visit_field::<u16>("u16_value", Self::VT_U16_VALUE, false)?
     .visit_field::<u32>("u32_value", Self::VT_U32_VALUE, false)?
     .visit_field::<u64>("u64_value", Self::VT_U64_VALUE, false)?
     .visit_field::<f32>("f32_value", Self::VT_F32_VALUE, false)?
     .visit_field::<f64>("f64_value", Self::VT_F64_VALUE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("text_value", Self::VT_TEXT_VALUE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, u8>>>("bytes_value", Self::VT_BYTES_VALUE, false)?
     .visit_field::<i32>("fixed_size", Self::VT_FIXED_SIZE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("timezone", Self::VT_TIMEZONE, false)?
     .visit_field::<u8>("decimal_precision", Self::VT_DECIMAL_PRECISION, false)?
     .visit_field::<i8>("decimal_scale", Self::VT_DECIMAL_SCALE, false)?
     .visit_field::<i32>("embedding_size", Self::VT_EMBEDDING_SIZE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, f32>>>("embedding_values", Self::VT_EMBEDDING_VALUES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, bool>>>("embedding_valid", Self::VT_EMBEDDING_VALID, false)?
     .finish();
                    Ok(())
                }
            }
            pub struct ScalarValuePayloadArgs<'a> {
                pub tag: ScalarTag,
                pub is_null: bool,
                pub bool_value: bool,
                pub i8_value: i8,
                pub i16_value: i16,
                pub i32_value: i32,
                pub i64_value: i64,
                pub u8_value: u8,
                pub u16_value: u16,
                pub u32_value: u32,
                pub u64_value: u64,
                pub f32_value: f32,
                pub f64_value: f64,
                pub text_value: Option<::flatbuffers::WIPOffset<&'a str>>,
                pub bytes_value: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, u8>>>,
                pub fixed_size: i32,
                pub timezone: Option<::flatbuffers::WIPOffset<&'a str>>,
                pub decimal_precision: u8,
                pub decimal_scale: i8,
                pub embedding_size: i32,
                pub embedding_values:
                    Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, f32>>>,
                pub embedding_valid:
                    Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, bool>>>,
            }
            impl<'a> Default for ScalarValuePayloadArgs<'a> {
                #[inline]
                fn default() -> Self {
                    ScalarValuePayloadArgs {
                        tag: ScalarTag::Null,
                        is_null: false,
                        bool_value: false,
                        i8_value: 0,
                        i16_value: 0,
                        i32_value: 0,
                        i64_value: 0,
                        u8_value: 0,
                        u16_value: 0,
                        u32_value: 0,
                        u64_value: 0,
                        f32_value: 0.0,
                        f64_value: 0.0,
                        text_value: None,
                        bytes_value: None,
                        fixed_size: 0,
                        timezone: None,
                        decimal_precision: 0,
                        decimal_scale: 0,
                        embedding_size: 0,
                        embedding_values: None,
                        embedding_valid: None,
                    }
                }
            }

            pub struct ScalarValuePayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
                fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
            }
            impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ScalarValuePayloadBuilder<'a, 'b, A> {
                #[inline]
                pub fn add_tag(&mut self, tag: ScalarTag) {
                    self.fbb_.push_slot::<ScalarTag>(
                        ScalarValuePayload::VT_TAG,
                        tag,
                        ScalarTag::Null,
                    );
                }
                #[inline]
                pub fn add_is_null(&mut self, is_null: bool) {
                    self.fbb_.push_slot::<bool>(ScalarValuePayload::VT_IS_NULL, is_null, false);
                }
                #[inline]
                pub fn add_bool_value(&mut self, bool_value: bool) {
                    self.fbb_.push_slot::<bool>(
                        ScalarValuePayload::VT_BOOL_VALUE,
                        bool_value,
                        false,
                    );
                }
                #[inline]
                pub fn add_i8_value(&mut self, i8_value: i8) {
                    self.fbb_.push_slot::<i8>(ScalarValuePayload::VT_I8_VALUE, i8_value, 0);
                }
                #[inline]
                pub fn add_i16_value(&mut self, i16_value: i16) {
                    self.fbb_.push_slot::<i16>(ScalarValuePayload::VT_I16_VALUE, i16_value, 0);
                }
                #[inline]
                pub fn add_i32_value(&mut self, i32_value: i32) {
                    self.fbb_.push_slot::<i32>(ScalarValuePayload::VT_I32_VALUE, i32_value, 0);
                }
                #[inline]
                pub fn add_i64_value(&mut self, i64_value: i64) {
                    self.fbb_.push_slot::<i64>(ScalarValuePayload::VT_I64_VALUE, i64_value, 0);
                }
                #[inline]
                pub fn add_u8_value(&mut self, u8_value: u8) {
                    self.fbb_.push_slot::<u8>(ScalarValuePayload::VT_U8_VALUE, u8_value, 0);
                }
                #[inline]
                pub fn add_u16_value(&mut self, u16_value: u16) {
                    self.fbb_.push_slot::<u16>(ScalarValuePayload::VT_U16_VALUE, u16_value, 0);
                }
                #[inline]
                pub fn add_u32_value(&mut self, u32_value: u32) {
                    self.fbb_.push_slot::<u32>(ScalarValuePayload::VT_U32_VALUE, u32_value, 0);
                }
                #[inline]
                pub fn add_u64_value(&mut self, u64_value: u64) {
                    self.fbb_.push_slot::<u64>(ScalarValuePayload::VT_U64_VALUE, u64_value, 0);
                }
                #[inline]
                pub fn add_f32_value(&mut self, f32_value: f32) {
                    self.fbb_.push_slot::<f32>(ScalarValuePayload::VT_F32_VALUE, f32_value, 0.0);
                }
                #[inline]
                pub fn add_f64_value(&mut self, f64_value: f64) {
                    self.fbb_.push_slot::<f64>(ScalarValuePayload::VT_F64_VALUE, f64_value, 0.0);
                }
                #[inline]
                pub fn add_text_value(&mut self, text_value: ::flatbuffers::WIPOffset<&'b str>) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                        ScalarValuePayload::VT_TEXT_VALUE,
                        text_value,
                    );
                }
                #[inline]
                pub fn add_bytes_value(
                    &mut self,
                    bytes_value: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, u8>>,
                ) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                        ScalarValuePayload::VT_BYTES_VALUE,
                        bytes_value,
                    );
                }
                #[inline]
                pub fn add_fixed_size(&mut self, fixed_size: i32) {
                    self.fbb_.push_slot::<i32>(ScalarValuePayload::VT_FIXED_SIZE, fixed_size, 0);
                }
                #[inline]
                pub fn add_timezone(&mut self, timezone: ::flatbuffers::WIPOffset<&'b str>) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                        ScalarValuePayload::VT_TIMEZONE,
                        timezone,
                    );
                }
                #[inline]
                pub fn add_decimal_precision(&mut self, decimal_precision: u8) {
                    self.fbb_.push_slot::<u8>(
                        ScalarValuePayload::VT_DECIMAL_PRECISION,
                        decimal_precision,
                        0,
                    );
                }
                #[inline]
                pub fn add_decimal_scale(&mut self, decimal_scale: i8) {
                    self.fbb_.push_slot::<i8>(
                        ScalarValuePayload::VT_DECIMAL_SCALE,
                        decimal_scale,
                        0,
                    );
                }
                #[inline]
                pub fn add_embedding_size(&mut self, embedding_size: i32) {
                    self.fbb_.push_slot::<i32>(
                        ScalarValuePayload::VT_EMBEDDING_SIZE,
                        embedding_size,
                        0,
                    );
                }
                #[inline]
                pub fn add_embedding_values(
                    &mut self,
                    embedding_values: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, f32>>,
                ) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                        ScalarValuePayload::VT_EMBEDDING_VALUES,
                        embedding_values,
                    );
                }
                #[inline]
                pub fn add_embedding_valid(
                    &mut self,
                    embedding_valid: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b, bool>>,
                ) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                        ScalarValuePayload::VT_EMBEDDING_VALID,
                        embedding_valid,
                    );
                }
                #[inline]
                pub fn new(
                    _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                ) -> ScalarValuePayloadBuilder<'a, 'b, A> {
                    let start = _fbb.start_table();
                    ScalarValuePayloadBuilder {
                        fbb_: _fbb,
                        start_: start,
                    }
                }
                #[inline]
                pub fn finish(self) -> ::flatbuffers::WIPOffset<ScalarValuePayload<'a>> {
                    let o = self.fbb_.end_table(self.start_);
                    ::flatbuffers::WIPOffset::new(o.value())
                }
            }

            impl ::core::fmt::Debug for ScalarValuePayload<'_> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut ds = f.debug_struct("ScalarValuePayload");
                    ds.field("tag", &self.tag());
                    ds.field("is_null", &self.is_null());
                    ds.field("bool_value", &self.bool_value());
                    ds.field("i8_value", &self.i8_value());
                    ds.field("i16_value", &self.i16_value());
                    ds.field("i32_value", &self.i32_value());
                    ds.field("i64_value", &self.i64_value());
                    ds.field("u8_value", &self.u8_value());
                    ds.field("u16_value", &self.u16_value());
                    ds.field("u32_value", &self.u32_value());
                    ds.field("u64_value", &self.u64_value());
                    ds.field("f32_value", &self.f32_value());
                    ds.field("f64_value", &self.f64_value());
                    ds.field("text_value", &self.text_value());
                    ds.field("bytes_value", &self.bytes_value());
                    ds.field("fixed_size", &self.fixed_size());
                    ds.field("timezone", &self.timezone());
                    ds.field("decimal_precision", &self.decimal_precision());
                    ds.field("decimal_scale", &self.decimal_scale());
                    ds.field("embedding_size", &self.embedding_size());
                    ds.field("embedding_values", &self.embedding_values());
                    ds.field("embedding_valid", &self.embedding_valid());
                    ds.finish()
                }
            }
            pub enum ColumnValueOffset {}
            #[derive(Copy, Clone, PartialEq)]

            pub struct ColumnValue<'a> {
                pub _tab: ::flatbuffers::Table<'a>,
            }

            impl<'a> ::flatbuffers::Follow<'a> for ColumnValue<'a> {
                type Inner = ColumnValue<'a>;
                #[inline]
                unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                    Self {
                        _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                    }
                }
            }

            impl<'a> ColumnValue<'a> {
                pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
                pub const VT_VALUE: ::flatbuffers::VOffsetT = 6;

                #[inline]
                pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                    ColumnValue { _tab: table }
                }
                #[allow(unused_mut)]
                pub fn create<
                    'bldr: 'args,
                    'args: 'mut_bldr,
                    'mut_bldr,
                    A: ::flatbuffers::Allocator + 'bldr,
                >(
                    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                    args: &'args ColumnValueArgs<'args>,
                ) -> ::flatbuffers::WIPOffset<ColumnValue<'bldr>> {
                    let mut builder = ColumnValueBuilder::new(_fbb);
                    if let Some(x) = args.value {
                        builder.add_value(x);
                    }
                    if let Some(x) = args.name {
                        builder.add_name(x);
                    }
                    builder.finish()
                }

                #[inline]
                pub fn name(&self) -> Option<&'a str> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab
                            .get::<::flatbuffers::ForwardsUOffset<&str>>(ColumnValue::VT_NAME, None)
                    }
                }
                #[inline]
                pub fn value(&self) -> Option<ScalarValuePayload<'a>> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<::flatbuffers::ForwardsUOffset<ScalarValuePayload>>(
                            ColumnValue::VT_VALUE,
                            None,
                        )
                    }
                }
            }

            impl ::flatbuffers::Verifiable for ColumnValue<'_> {
                #[inline]
                fn run_verifier(
                    v: &mut ::flatbuffers::Verifier,
                    pos: usize,
                ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                    v.visit_table(pos)?
                        .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                            "name",
                            Self::VT_NAME,
                            false,
                        )?
                        .visit_field::<::flatbuffers::ForwardsUOffset<ScalarValuePayload>>(
                            "value",
                            Self::VT_VALUE,
                            false,
                        )?
                        .finish();
                    Ok(())
                }
            }
            pub struct ColumnValueArgs<'a> {
                pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
                pub value: Option<::flatbuffers::WIPOffset<ScalarValuePayload<'a>>>,
            }
            impl<'a> Default for ColumnValueArgs<'a> {
                #[inline]
                fn default() -> Self {
                    ColumnValueArgs {
                        name: None,
                        value: None,
                    }
                }
            }

            pub struct ColumnValueBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
                fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
            }
            impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ColumnValueBuilder<'a, 'b, A> {
                #[inline]
                pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b str>) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                        ColumnValue::VT_NAME,
                        name,
                    );
                }
                #[inline]
                pub fn add_value(
                    &mut self,
                    value: ::flatbuffers::WIPOffset<ScalarValuePayload<'b>>,
                ) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<ScalarValuePayload>>(
                        ColumnValue::VT_VALUE,
                        value,
                    );
                }
                #[inline]
                pub fn new(
                    _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                ) -> ColumnValueBuilder<'a, 'b, A> {
                    let start = _fbb.start_table();
                    ColumnValueBuilder {
                        fbb_: _fbb,
                        start_: start,
                    }
                }
                #[inline]
                pub fn finish(self) -> ::flatbuffers::WIPOffset<ColumnValue<'a>> {
                    let o = self.fbb_.end_table(self.start_);
                    ::flatbuffers::WIPOffset::new(o.value())
                }
            }

            impl ::core::fmt::Debug for ColumnValue<'_> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut ds = f.debug_struct("ColumnValue");
                    ds.field("name", &self.name());
                    ds.field("value", &self.value());
                    ds.finish()
                }
            }
            pub enum RowPayloadOffset {}
            #[derive(Copy, Clone, PartialEq)]

            pub struct RowPayload<'a> {
                pub _tab: ::flatbuffers::Table<'a>,
            }

            impl<'a> ::flatbuffers::Follow<'a> for RowPayload<'a> {
                type Inner = RowPayload<'a>;
                #[inline]
                unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                    Self {
                        _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                    }
                }
            }

            impl<'a> RowPayload<'a> {
                pub const VT_COLUMNS: ::flatbuffers::VOffsetT = 4;

                #[inline]
                pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                    RowPayload { _tab: table }
                }
                #[allow(unused_mut)]
                pub fn create<
                    'bldr: 'args,
                    'args: 'mut_bldr,
                    'mut_bldr,
                    A: ::flatbuffers::Allocator + 'bldr,
                >(
                    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                    args: &'args RowPayloadArgs<'args>,
                ) -> ::flatbuffers::WIPOffset<RowPayload<'bldr>> {
                    let mut builder = RowPayloadBuilder::new(_fbb);
                    if let Some(x) = args.columns {
                        builder.add_columns(x);
                    }
                    builder.finish()
                }

                #[inline]
                pub fn columns(
                    &self,
                ) -> Option<
                    ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ColumnValue<'a>>>,
                > {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<::flatbuffers::ForwardsUOffset<
                            ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ColumnValue>>,
                        >>(RowPayload::VT_COLUMNS, None)
                    }
                }
            }

            impl ::flatbuffers::Verifiable for RowPayload<'_> {
                #[inline]
                fn run_verifier(
                    v: &mut ::flatbuffers::Verifier,
                    pos: usize,
                ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                    v.visit_table(pos)?
                        .visit_field::<::flatbuffers::ForwardsUOffset<
                            ::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<ColumnValue>>,
                        >>("columns", Self::VT_COLUMNS, false)?
                        .finish();
                    Ok(())
                }
            }
            pub struct RowPayloadArgs<'a> {
                pub columns: Option<
                    ::flatbuffers::WIPOffset<
                        ::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<ColumnValue<'a>>>,
                    >,
                >,
            }
            impl<'a> Default for RowPayloadArgs<'a> {
                #[inline]
                fn default() -> Self {
                    RowPayloadArgs { columns: None }
                }
            }

            pub struct RowPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
                fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
            }
            impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> RowPayloadBuilder<'a, 'b, A> {
                #[inline]
                pub fn add_columns(
                    &mut self,
                    columns: ::flatbuffers::WIPOffset<
                        ::flatbuffers::Vector<'b, ::flatbuffers::ForwardsUOffset<ColumnValue<'b>>>,
                    >,
                ) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                        RowPayload::VT_COLUMNS,
                        columns,
                    );
                }
                #[inline]
                pub fn new(
                    _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                ) -> RowPayloadBuilder<'a, 'b, A> {
                    let start = _fbb.start_table();
                    RowPayloadBuilder {
                        fbb_: _fbb,
                        start_: start,
                    }
                }
                #[inline]
                pub fn finish(self) -> ::flatbuffers::WIPOffset<RowPayload<'a>> {
                    let o = self.fbb_.end_table(self.start_);
                    ::flatbuffers::WIPOffset::new(o.value())
                }
            }

            impl ::core::fmt::Debug for RowPayload<'_> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut ds = f.debug_struct("RowPayload");
                    ds.field("columns", &self.columns());
                    ds.finish()
                }
            }
            pub enum UserTableRowPayloadOffset {}
            #[derive(Copy, Clone, PartialEq)]

            pub struct UserTableRowPayload<'a> {
                pub _tab: ::flatbuffers::Table<'a>,
            }

            impl<'a> ::flatbuffers::Follow<'a> for UserTableRowPayload<'a> {
                type Inner = UserTableRowPayload<'a>;
                #[inline]
                unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                    Self {
                        _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                    }
                }
            }

            impl<'a> UserTableRowPayload<'a> {
                pub const VT_USER_ID: ::flatbuffers::VOffsetT = 4;
                pub const VT_SEQ: ::flatbuffers::VOffsetT = 6;
                pub const VT_DELETED: ::flatbuffers::VOffsetT = 8;
                pub const VT_FIELDS: ::flatbuffers::VOffsetT = 10;

                #[inline]
                pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                    UserTableRowPayload { _tab: table }
                }
                #[allow(unused_mut)]
                pub fn create<
                    'bldr: 'args,
                    'args: 'mut_bldr,
                    'mut_bldr,
                    A: ::flatbuffers::Allocator + 'bldr,
                >(
                    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                    args: &'args UserTableRowPayloadArgs<'args>,
                ) -> ::flatbuffers::WIPOffset<UserTableRowPayload<'bldr>> {
                    let mut builder = UserTableRowPayloadBuilder::new(_fbb);
                    builder.add_seq(args.seq);
                    if let Some(x) = args.fields {
                        builder.add_fields(x);
                    }
                    if let Some(x) = args.user_id {
                        builder.add_user_id(x);
                    }
                    builder.add_deleted(args.deleted);
                    builder.finish()
                }

                #[inline]
                pub fn user_id(&self) -> Option<&'a str> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(
                            UserTableRowPayload::VT_USER_ID,
                            None,
                        )
                    }
                }
                #[inline]
                pub fn seq(&self) -> i64 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe { self._tab.get::<i64>(UserTableRowPayload::VT_SEQ, Some(0)).unwrap() }
                }
                #[inline]
                pub fn deleted(&self) -> bool {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<bool>(UserTableRowPayload::VT_DELETED, Some(false)).unwrap()
                    }
                }
                #[inline]
                pub fn fields(&self) -> Option<RowPayload<'a>> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<::flatbuffers::ForwardsUOffset<RowPayload>>(
                            UserTableRowPayload::VT_FIELDS,
                            None,
                        )
                    }
                }
            }

            impl ::flatbuffers::Verifiable for UserTableRowPayload<'_> {
                #[inline]
                fn run_verifier(
                    v: &mut ::flatbuffers::Verifier,
                    pos: usize,
                ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                    v.visit_table(pos)?
                        .visit_field::<::flatbuffers::ForwardsUOffset<&str>>(
                            "user_id",
                            Self::VT_USER_ID,
                            false,
                        )?
                        .visit_field::<i64>("seq", Self::VT_SEQ, false)?
                        .visit_field::<bool>("deleted", Self::VT_DELETED, false)?
                        .visit_field::<::flatbuffers::ForwardsUOffset<RowPayload>>(
                            "fields",
                            Self::VT_FIELDS,
                            false,
                        )?
                        .finish();
                    Ok(())
                }
            }
            pub struct UserTableRowPayloadArgs<'a> {
                pub user_id: Option<::flatbuffers::WIPOffset<&'a str>>,
                pub seq: i64,
                pub deleted: bool,
                pub fields: Option<::flatbuffers::WIPOffset<RowPayload<'a>>>,
            }
            impl<'a> Default for UserTableRowPayloadArgs<'a> {
                #[inline]
                fn default() -> Self {
                    UserTableRowPayloadArgs {
                        user_id: None,
                        seq: 0,
                        deleted: false,
                        fields: None,
                    }
                }
            }

            pub struct UserTableRowPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
                fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
            }
            impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> UserTableRowPayloadBuilder<'a, 'b, A> {
                #[inline]
                pub fn add_user_id(&mut self, user_id: ::flatbuffers::WIPOffset<&'b str>) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(
                        UserTableRowPayload::VT_USER_ID,
                        user_id,
                    );
                }
                #[inline]
                pub fn add_seq(&mut self, seq: i64) {
                    self.fbb_.push_slot::<i64>(UserTableRowPayload::VT_SEQ, seq, 0);
                }
                #[inline]
                pub fn add_deleted(&mut self, deleted: bool) {
                    self.fbb_.push_slot::<bool>(UserTableRowPayload::VT_DELETED, deleted, false);
                }
                #[inline]
                pub fn add_fields(&mut self, fields: ::flatbuffers::WIPOffset<RowPayload<'b>>) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<RowPayload>>(
                        UserTableRowPayload::VT_FIELDS,
                        fields,
                    );
                }
                #[inline]
                pub fn new(
                    _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                ) -> UserTableRowPayloadBuilder<'a, 'b, A> {
                    let start = _fbb.start_table();
                    UserTableRowPayloadBuilder {
                        fbb_: _fbb,
                        start_: start,
                    }
                }
                #[inline]
                pub fn finish(self) -> ::flatbuffers::WIPOffset<UserTableRowPayload<'a>> {
                    let o = self.fbb_.end_table(self.start_);
                    ::flatbuffers::WIPOffset::new(o.value())
                }
            }

            impl ::core::fmt::Debug for UserTableRowPayload<'_> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut ds = f.debug_struct("UserTableRowPayload");
                    ds.field("user_id", &self.user_id());
                    ds.field("seq", &self.seq());
                    ds.field("deleted", &self.deleted());
                    ds.field("fields", &self.fields());
                    ds.finish()
                }
            }
            pub enum SharedTableRowPayloadOffset {}
            #[derive(Copy, Clone, PartialEq)]

            pub struct SharedTableRowPayload<'a> {
                pub _tab: ::flatbuffers::Table<'a>,
            }

            impl<'a> ::flatbuffers::Follow<'a> for SharedTableRowPayload<'a> {
                type Inner = SharedTableRowPayload<'a>;
                #[inline]
                unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                    Self {
                        _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                    }
                }
            }

            impl<'a> SharedTableRowPayload<'a> {
                pub const VT_SEQ: ::flatbuffers::VOffsetT = 4;
                pub const VT_DELETED: ::flatbuffers::VOffsetT = 6;
                pub const VT_FIELDS: ::flatbuffers::VOffsetT = 8;

                #[inline]
                pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                    SharedTableRowPayload { _tab: table }
                }
                #[allow(unused_mut)]
                pub fn create<
                    'bldr: 'args,
                    'args: 'mut_bldr,
                    'mut_bldr,
                    A: ::flatbuffers::Allocator + 'bldr,
                >(
                    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                    args: &'args SharedTableRowPayloadArgs<'args>,
                ) -> ::flatbuffers::WIPOffset<SharedTableRowPayload<'bldr>> {
                    let mut builder = SharedTableRowPayloadBuilder::new(_fbb);
                    builder.add_seq(args.seq);
                    if let Some(x) = args.fields {
                        builder.add_fields(x);
                    }
                    builder.add_deleted(args.deleted);
                    builder.finish()
                }

                #[inline]
                pub fn seq(&self) -> i64 {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe { self._tab.get::<i64>(SharedTableRowPayload::VT_SEQ, Some(0)).unwrap() }
                }
                #[inline]
                pub fn deleted(&self) -> bool {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab
                            .get::<bool>(SharedTableRowPayload::VT_DELETED, Some(false))
                            .unwrap()
                    }
                }
                #[inline]
                pub fn fields(&self) -> Option<RowPayload<'a>> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<::flatbuffers::ForwardsUOffset<RowPayload>>(
                            SharedTableRowPayload::VT_FIELDS,
                            None,
                        )
                    }
                }
            }

            impl ::flatbuffers::Verifiable for SharedTableRowPayload<'_> {
                #[inline]
                fn run_verifier(
                    v: &mut ::flatbuffers::Verifier,
                    pos: usize,
                ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                    v.visit_table(pos)?
                        .visit_field::<i64>("seq", Self::VT_SEQ, false)?
                        .visit_field::<bool>("deleted", Self::VT_DELETED, false)?
                        .visit_field::<::flatbuffers::ForwardsUOffset<RowPayload>>(
                            "fields",
                            Self::VT_FIELDS,
                            false,
                        )?
                        .finish();
                    Ok(())
                }
            }
            pub struct SharedTableRowPayloadArgs<'a> {
                pub seq: i64,
                pub deleted: bool,
                pub fields: Option<::flatbuffers::WIPOffset<RowPayload<'a>>>,
            }
            impl<'a> Default for SharedTableRowPayloadArgs<'a> {
                #[inline]
                fn default() -> Self {
                    SharedTableRowPayloadArgs {
                        seq: 0,
                        deleted: false,
                        fields: None,
                    }
                }
            }

            pub struct SharedTableRowPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
                fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
            }
            impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SharedTableRowPayloadBuilder<'a, 'b, A> {
                #[inline]
                pub fn add_seq(&mut self, seq: i64) {
                    self.fbb_.push_slot::<i64>(SharedTableRowPayload::VT_SEQ, seq, 0);
                }
                #[inline]
                pub fn add_deleted(&mut self, deleted: bool) {
                    self.fbb_.push_slot::<bool>(SharedTableRowPayload::VT_DELETED, deleted, false);
                }
                #[inline]
                pub fn add_fields(&mut self, fields: ::flatbuffers::WIPOffset<RowPayload<'b>>) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<RowPayload>>(
                        SharedTableRowPayload::VT_FIELDS,
                        fields,
                    );
                }
                #[inline]
                pub fn new(
                    _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                ) -> SharedTableRowPayloadBuilder<'a, 'b, A> {
                    let start = _fbb.start_table();
                    SharedTableRowPayloadBuilder {
                        fbb_: _fbb,
                        start_: start,
                    }
                }
                #[inline]
                pub fn finish(self) -> ::flatbuffers::WIPOffset<SharedTableRowPayload<'a>> {
                    let o = self.fbb_.end_table(self.start_);
                    ::flatbuffers::WIPOffset::new(o.value())
                }
            }

            impl ::core::fmt::Debug for SharedTableRowPayload<'_> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut ds = f.debug_struct("SharedTableRowPayload");
                    ds.field("seq", &self.seq());
                    ds.field("deleted", &self.deleted());
                    ds.field("fields", &self.fields());
                    ds.finish()
                }
            }
            pub enum SystemTableRowPayloadOffset {}
            #[derive(Copy, Clone, PartialEq)]

            pub struct SystemTableRowPayload<'a> {
                pub _tab: ::flatbuffers::Table<'a>,
            }

            impl<'a> ::flatbuffers::Follow<'a> for SystemTableRowPayload<'a> {
                type Inner = SystemTableRowPayload<'a>;
                #[inline]
                unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                    Self {
                        _tab: unsafe { ::flatbuffers::Table::new(buf, loc) },
                    }
                }
            }

            impl<'a> SystemTableRowPayload<'a> {
                pub const VT_FIELDS: ::flatbuffers::VOffsetT = 4;

                #[inline]
                pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
                    SystemTableRowPayload { _tab: table }
                }
                #[allow(unused_mut)]
                pub fn create<
                    'bldr: 'args,
                    'args: 'mut_bldr,
                    'mut_bldr,
                    A: ::flatbuffers::Allocator + 'bldr,
                >(
                    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
                    args: &'args SystemTableRowPayloadArgs<'args>,
                ) -> ::flatbuffers::WIPOffset<SystemTableRowPayload<'bldr>> {
                    let mut builder = SystemTableRowPayloadBuilder::new(_fbb);
                    if let Some(x) = args.fields {
                        builder.add_fields(x);
                    }
                    builder.finish()
                }

                #[inline]
                pub fn fields(&self) -> Option<RowPayload<'a>> {
                    // Safety:
                    // Created from valid Table for this object
                    // which contains a valid value in this slot
                    unsafe {
                        self._tab.get::<::flatbuffers::ForwardsUOffset<RowPayload>>(
                            SystemTableRowPayload::VT_FIELDS,
                            None,
                        )
                    }
                }
            }

            impl ::flatbuffers::Verifiable for SystemTableRowPayload<'_> {
                #[inline]
                fn run_verifier(
                    v: &mut ::flatbuffers::Verifier,
                    pos: usize,
                ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
                    v.visit_table(pos)?
                        .visit_field::<::flatbuffers::ForwardsUOffset<RowPayload>>(
                            "fields",
                            Self::VT_FIELDS,
                            false,
                        )?
                        .finish();
                    Ok(())
                }
            }
            pub struct SystemTableRowPayloadArgs<'a> {
                pub fields: Option<::flatbuffers::WIPOffset<RowPayload<'a>>>,
            }
            impl<'a> Default for SystemTableRowPayloadArgs<'a> {
                #[inline]
                fn default() -> Self {
                    SystemTableRowPayloadArgs { fields: None }
                }
            }

            pub struct SystemTableRowPayloadBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
                fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
            }
            impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> SystemTableRowPayloadBuilder<'a, 'b, A> {
                #[inline]
                pub fn add_fields(&mut self, fields: ::flatbuffers::WIPOffset<RowPayload<'b>>) {
                    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<RowPayload>>(
                        SystemTableRowPayload::VT_FIELDS,
                        fields,
                    );
                }
                #[inline]
                pub fn new(
                    _fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                ) -> SystemTableRowPayloadBuilder<'a, 'b, A> {
                    let start = _fbb.start_table();
                    SystemTableRowPayloadBuilder {
                        fbb_: _fbb,
                        start_: start,
                    }
                }
                #[inline]
                pub fn finish(self) -> ::flatbuffers::WIPOffset<SystemTableRowPayload<'a>> {
                    let o = self.fbb_.end_table(self.start_);
                    ::flatbuffers::WIPOffset::new(o.value())
                }
            }

            impl ::core::fmt::Debug for SystemTableRowPayload<'_> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    let mut ds = f.debug_struct("SystemTableRowPayload");
                    ds.field("fields", &self.fields());
                    ds.finish()
                }
            }
            #[inline]
            /// Verifies that a buffer of bytes contains a `RowPayload`
            /// and returns it.
            /// Note that verification is still experimental and may not
            /// catch every error, or be maximally performant. For the
            /// previous, unchecked, behavior use
            /// `root_as_row_payload_unchecked`.
            pub fn root_as_row_payload(
                buf: &[u8],
            ) -> Result<RowPayload<'_>, ::flatbuffers::InvalidFlatbuffer> {
                ::flatbuffers::root::<RowPayload>(buf)
            }
            #[inline]
            /// Verifies that a buffer of bytes contains a size prefixed
            /// `RowPayload` and returns it.
            /// Note that verification is still experimental and may not
            /// catch every error, or be maximally performant. For the
            /// previous, unchecked, behavior use
            /// `size_prefixed_root_as_row_payload_unchecked`.
            pub fn size_prefixed_root_as_row_payload(
                buf: &[u8],
            ) -> Result<RowPayload<'_>, ::flatbuffers::InvalidFlatbuffer> {
                ::flatbuffers::size_prefixed_root::<RowPayload>(buf)
            }
            #[inline]
            /// Verifies, with the given options, that a buffer of bytes
            /// contains a `RowPayload` and returns it.
            /// Note that verification is still experimental and may not
            /// catch every error, or be maximally performant. For the
            /// previous, unchecked, behavior use
            /// `root_as_row_payload_unchecked`.
            pub fn root_as_row_payload_with_opts<'b, 'o>(
                opts: &'o ::flatbuffers::VerifierOptions,
                buf: &'b [u8],
            ) -> Result<RowPayload<'b>, ::flatbuffers::InvalidFlatbuffer> {
                ::flatbuffers::root_with_opts::<RowPayload<'b>>(opts, buf)
            }
            #[inline]
            /// Verifies, with the given verifier options, that a buffer of
            /// bytes contains a size prefixed `RowPayload` and returns
            /// it. Note that verification is still experimental and may not
            /// catch every error, or be maximally performant. For the
            /// previous, unchecked, behavior use
            /// `root_as_row_payload_unchecked`.
            pub fn size_prefixed_root_as_row_payload_with_opts<'b, 'o>(
                opts: &'o ::flatbuffers::VerifierOptions,
                buf: &'b [u8],
            ) -> Result<RowPayload<'b>, ::flatbuffers::InvalidFlatbuffer> {
                ::flatbuffers::size_prefixed_root_with_opts::<RowPayload<'b>>(opts, buf)
            }
            #[inline]
            /// Assumes, without verification, that a buffer of bytes contains a RowPayload and returns it.
            /// # Safety
            /// Callers must trust the given bytes do indeed contain a valid `RowPayload`.
            pub unsafe fn root_as_row_payload_unchecked(buf: &[u8]) -> RowPayload<'_> {
                unsafe { ::flatbuffers::root_unchecked::<RowPayload>(buf) }
            }
            #[inline]
            /// Assumes, without verification, that a buffer of bytes contains a size prefixed RowPayload and returns it.
            /// # Safety
            /// Callers must trust the given bytes do indeed contain a valid size prefixed `RowPayload`.
            pub unsafe fn size_prefixed_root_as_row_payload_unchecked(
                buf: &[u8],
            ) -> RowPayload<'_> {
                unsafe { ::flatbuffers::size_prefixed_root_unchecked::<RowPayload>(buf) }
            }
            pub const ROW_PAYLOAD_IDENTIFIER: &str = "KROW";

            #[inline]
            pub fn row_payload_buffer_has_identifier(buf: &[u8]) -> bool {
                ::flatbuffers::buffer_has_identifier(buf, ROW_PAYLOAD_IDENTIFIER, false)
            }

            #[inline]
            pub fn row_payload_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
                ::flatbuffers::buffer_has_identifier(buf, ROW_PAYLOAD_IDENTIFIER, true)
            }

            #[inline]
            pub fn finish_row_payload_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
                fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                root: ::flatbuffers::WIPOffset<RowPayload<'a>>,
            ) {
                fbb.finish(root, Some(ROW_PAYLOAD_IDENTIFIER));
            }

            #[inline]
            pub fn finish_size_prefixed_row_payload_buffer<
                'a,
                'b,
                A: ::flatbuffers::Allocator + 'a,
            >(
                fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
                root: ::flatbuffers::WIPOffset<RowPayload<'a>>,
            ) {
                fbb.finish_size_prefixed(root, Some(ROW_PAYLOAD_IDENTIFIER));
            }
        } // pub mod row
    } // pub mod serialization
} // pub mod kalamdb
