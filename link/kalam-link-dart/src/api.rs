//! Public API surface for flutter_rust_bridge codegen.
//!
//! Every `pub` function and type in this module is picked up by FRB and
//! gets a corresponding Dart binding generated automatically.
//!
//! ## Streaming pattern
//!
//! FRB v2 generates `StreamSink` in user boilerplate code rather than
//! exporting it from the crate.  To avoid depending on generated code,
//! subscriptions use an **async pull model**: call `dart_subscription_next`
//! in a loop from Dart, which internally awaits the next event from the
//! underlying `SubscriptionManager`.
//!
//! ## Connection events
//!
//! Connection lifecycle events (connect, disconnect, error, receive, send)
//! also follow the async-pull model. When `enable_connection_events` is
//! `true` in [`dart_create_client`], events are queued internally and
//! retrieved via [`dart_next_connection_event`].

use crate::models::{
    DartAuthProvider, DartChangeEvent, DartConnectionError, DartConnectionEvent,
    DartDisconnectReason, DartHealthCheckResponse, DartLoginResponse, DartQueryResponse,
    DartServerSetupRequest, DartServerSetupResponse, DartSetupStatusResponse,
    DartSubscriptionConfig,
};
use flutter_rust_bridge::frb;
use std::collections::VecDeque;
use std::sync::Arc;
use tokio::sync::{Mutex, Notify};

// ---------------------------------------------------------------------------
// Client wrapper
// ---------------------------------------------------------------------------

/// Opaque handle to a connected KalamDB client.
///
/// Create one via [`dart_create_client`] and pass it to query/subscribe helpers.
pub struct DartKalamClient {
    inner: kalam_link::KalamLinkClient,
    /// Queue of connection lifecycle events (populated when event handlers are
    /// enabled). Dart pulls from this via [`dart_next_connection_event`].
    ///
    /// Uses `std::sync::Mutex` (not tokio) because the event handler callbacks
    /// are synchronous closures; tokio Mutex requires `.await` or has borrow
    /// issues with `try_lock()` inside `#[frb(sync)]` functions.
    event_queue: Arc<std::sync::Mutex<VecDeque<DartConnectionEvent>>>,
    /// Notifier so the pull-side can await without busy-looping.
    event_notify: Arc<Notify>,
    /// Whether connection event collection is enabled.
    events_enabled: bool,
}

/// Create a new KalamDB client.
///
/// * `base_url` — server URL, e.g. `"https://db.example.com"` or `"http://localhost:3000"`.
/// * `auth` — authentication method (basic, JWT, or none).
/// * `timeout_ms` — optional HTTP request timeout in milliseconds (default 30 000).
/// * `max_retries` — optional retry count for idempotent queries (default 3).
/// * `enable_connection_events` — when `true`, connection lifecycle events
///   (connect, disconnect, error, receive, send) are queued internally and
///   can be retrieved via [`dart_next_connection_event`].
/// * `disable_compression` — when `true`, the WebSocket URL includes
///   `?compress=false` so the server sends plain-text JSON frames instead of
///   gzip-compressed binary frames. Useful during development.
#[frb(sync)]
pub fn dart_create_client(
    base_url: String,
    auth: DartAuthProvider,
    timeout_ms: Option<i64>,
    max_retries: Option<i32>,
    enable_connection_events: Option<bool>,
    disable_compression: Option<bool>,
) -> anyhow::Result<DartKalamClient> {
    create_client_inner(
        base_url,
        auth,
        timeout_ms,
        max_retries,
        enable_connection_events,
        disable_compression,
    )
}

/// Internal helper that performs the actual client construction.
///
/// Extracted from [`dart_create_client`] so that the `#[frb(sync)]` macro
/// expansion does not interfere with borrow lifetimes inside the event
/// handler closures.
fn create_client_inner(
    base_url: String,
    auth: DartAuthProvider,
    timeout_ms: Option<i64>,
    max_retries: Option<i32>,
    enable_connection_events: Option<bool>,
    disable_compression: Option<bool>,
) -> anyhow::Result<DartKalamClient> {
    let event_queue: Arc<std::sync::Mutex<VecDeque<DartConnectionEvent>>> =
        Arc::new(std::sync::Mutex::new(VecDeque::new()));
    let event_notify = Arc::new(Notify::new());
    let events_enabled = enable_connection_events.unwrap_or(false);

    let mut builder = kalam_link::KalamLinkClient::builder()
        .base_url(base_url)
        .auth(auth.into_native());

    if let Some(ms) = timeout_ms {
        builder = builder.timeout(std::time::Duration::from_millis(ms as u64));
    }
    if let Some(r) = max_retries {
        builder = builder.max_retries(r as u32);
    }
    if disable_compression.unwrap_or(false) {
        builder = builder.connection_options(
            kalam_link::ConnectionOptions::default().with_disable_compression(true),
        );
    }

    // Wire connection lifecycle event handlers that push into the queue.
    if events_enabled {
        builder = builder.event_handlers(build_event_handlers(
            event_queue.clone(),
            event_notify.clone(),
        ));
    }

    let client = builder.build()?;
    Ok(DartKalamClient {
        inner: client,
        event_queue,
        event_notify,
        events_enabled,
    })
}

/// Update the authentication credentials on a live client.
///
/// This is used to implement refresh-token flows from Dart:
/// before re-subscribing or on a schedule, Dart calls the user's
/// `authProvider` callback, receives a new [Auth], and calls this
/// function to push updated credentials into the Rust client.
///
/// The new credentials take effect on the next `subscribe()` call.
#[frb(sync)]
pub fn dart_update_auth(
    client: &mut DartKalamClient,
    auth: DartAuthProvider,
) -> anyhow::Result<()> {
    client
        .inner
        .set_auth(auth.into_native());
    Ok(())
}

/// Build [`EventHandlers`](kalam_link::EventHandlers) that push events into
/// a shared queue and notify waiters.
fn build_event_handlers(
    queue: Arc<std::sync::Mutex<VecDeque<DartConnectionEvent>>>,
    notify: Arc<Notify>,
) -> kalam_link::EventHandlers {
    let mut handlers = kalam_link::EventHandlers::new();

    // on_connect
    {
        let q = queue.clone();
        let n = notify.clone();
        handlers = handlers.on_connect(move || {
            if let Ok(mut guard) = q.lock() {
                guard.push_back(DartConnectionEvent::Connect);
            }
            n.notify_one();
        });
    }

    // on_disconnect
    {
        let q = queue.clone();
        let n = notify.clone();
        handlers = handlers.on_disconnect(move |reason| {
            let event = DartConnectionEvent::Disconnect {
                reason: DartDisconnectReason {
                    message: reason.message,
                    code: reason.code.map(|c| c as i32),
                },
            };
            if let Ok(mut guard) = q.lock() {
                guard.push_back(event);
            }
            n.notify_one();
        });
    }

    // on_error
    {
        let q = queue.clone();
        let n = notify.clone();
        handlers = handlers.on_error(move |error| {
            let event = DartConnectionEvent::Error {
                error: DartConnectionError {
                    message: error.message,
                    recoverable: error.recoverable,
                },
            };
            if let Ok(mut guard) = q.lock() {
                guard.push_back(event);
            }
            n.notify_one();
        });
    }

    // on_receive (debug)
    {
        let q = queue.clone();
        let n = notify.clone();
        handlers = handlers.on_receive(move |msg: &str| {
            let event = DartConnectionEvent::Receive {
                message: msg.to_owned(),
            };
            if let Ok(mut guard) = q.lock() {
                guard.push_back(event);
            }
            n.notify_one();
        });
    }

    // on_send (debug)
    {
        let q = queue;
        let n = notify;
        handlers = handlers.on_send(move |msg: &str| {
            let event = DartConnectionEvent::Send {
                message: msg.to_owned(),
            };
            if let Ok(mut guard) = q.lock() {
                guard.push_back(event);
            }
            n.notify_one();
        });
    }

    handlers
}

// ---------------------------------------------------------------------------
// Query
// ---------------------------------------------------------------------------

/// Execute a SQL query, optionally with parameters and namespace.
///
/// * `params_json` — JSON-encoded array of parameter values, e.g. `'["val1", 42]'`.
///   Pass `null` for no parameters.
/// * `namespace` — optional namespace context for unqualified table names.
pub async fn dart_execute_query(
    client: &DartKalamClient,
    sql: String,
    params_json: Option<String>,
    namespace: Option<String>,
) -> anyhow::Result<DartQueryResponse> {
    let params: Option<Vec<serde_json::Value>> = match params_json {
        Some(json) => Some(serde_json::from_str(&json)?),
        None => None,
    };
    let response = client
        .inner
        .execute_query(&sql, None, params, namespace.as_deref())
        .await?;
    Ok(DartQueryResponse::from(response))
}

// ---------------------------------------------------------------------------
// Auth endpoints
// ---------------------------------------------------------------------------

/// Log in with username and password. Returns tokens and user info.
pub async fn dart_login(
    client: &DartKalamClient,
    username: String,
    password: String,
) -> anyhow::Result<DartLoginResponse> {
    let response = client.inner.login(&username, &password).await?;
    Ok(DartLoginResponse::from(response))
}

/// Refresh an access token using a refresh token.
pub async fn dart_refresh_token(
    client: &DartKalamClient,
    refresh_token: String,
) -> anyhow::Result<DartLoginResponse> {
    let response = client.inner.refresh_access_token(&refresh_token).await?;
    Ok(DartLoginResponse::from(response))
}

// ---------------------------------------------------------------------------
// Health / Setup
// ---------------------------------------------------------------------------

/// Check server health (version, status, etc.).
pub async fn dart_health_check(
    client: &DartKalamClient,
) -> anyhow::Result<DartHealthCheckResponse> {
    let response = client.inner.health_check().await?;
    Ok(DartHealthCheckResponse::from(response))
}

/// Check whether the server requires initial setup.
pub async fn dart_check_setup_status(
    client: &DartKalamClient,
) -> anyhow::Result<DartSetupStatusResponse> {
    let response = client.inner.check_setup_status().await?;
    Ok(DartSetupStatusResponse::from(response))
}

/// Perform initial server setup (create first admin user).
pub async fn dart_server_setup(
    client: &DartKalamClient,
    request: DartServerSetupRequest,
) -> anyhow::Result<DartServerSetupResponse> {
    let response = client.inner.server_setup(request.into_native()).await?;
    Ok(DartServerSetupResponse::from(response))
}

// ---------------------------------------------------------------------------
// Connection events (async pull model)
// ---------------------------------------------------------------------------

/// Pull the next connection lifecycle event.
///
/// Returns `None` when event collection is disabled or the client is dropped.
/// Dart should call this in a loop:
///
/// ```dart
/// while (true) {
///   final event = await dartNextConnectionEvent(client: client);
///   if (event == null) break;
///   // handle event ...
/// }
/// ```
pub async fn dart_next_connection_event(
    client: &DartKalamClient,
) -> anyhow::Result<Option<DartConnectionEvent>> {
    if !client.events_enabled {
        return Ok(None);
    }

    // Fast path: check queue first
    {
        let mut queue = client
            .event_queue
            .lock()
            .map_err(|e| anyhow::anyhow!("event queue lock poisoned: {e}"))?;
        if let Some(event) = queue.pop_front() {
            return Ok(Some(event));
        }
    }

    // Slow path: wait for notification, then drain one event
    client.event_notify.notified().await;
    let mut queue = client
        .event_queue
        .lock()
        .map_err(|e| anyhow::anyhow!("event queue lock poisoned: {e}"))?;
    Ok(queue.pop_front())
}

/// Check whether connection event collection is enabled for this client.
#[frb(sync)]
pub fn dart_connection_events_enabled(client: &DartKalamClient) -> bool {
    client.events_enabled
}

// ---------------------------------------------------------------------------
// Subscription (async pull model)
// ---------------------------------------------------------------------------

/// Opaque handle to an active live-query subscription.
///
/// On the Dart side, call [`dart_subscription_next`] in a loop to pull
/// events. The loop ends when `None` is returned (subscription closed).
pub struct DartSubscription {
    inner: Arc<Mutex<kalam_link::SubscriptionManager>>,
    sub_id: String,
}

/// Create a live-query subscription.
///
/// * `sql` — the SELECT query to subscribe to.
/// * `config` — optional advanced configuration (batch size, etc.).
///
/// Returns an opaque [`DartSubscription`] handle.  Use
/// [`dart_subscription_next`] to pull events and
/// [`dart_subscription_close`] to tear down.
pub async fn dart_subscribe(
    client: &DartKalamClient,
    sql: String,
    config: Option<DartSubscriptionConfig>,
) -> anyhow::Result<DartSubscription> {
    let sub = if let Some(cfg) = config {
        let mut native_cfg = cfg.into_native();
        native_cfg.sql = sql;
        client.inner.subscribe_with_config(native_cfg).await?
    } else {
        client.inner.subscribe(&sql).await?
    };

    let sub_id = sub.subscription_id().to_owned();
    Ok(DartSubscription {
        inner: Arc::new(Mutex::new(sub)),
        sub_id,
    })
}

/// Pull the next change event from a subscription.
///
/// Returns `None` when the subscription has ended (server closed or
/// [`dart_subscription_close`] was called).
pub async fn dart_subscription_next(
    subscription: &DartSubscription,
) -> anyhow::Result<Option<DartChangeEvent>> {
    let mut sub = subscription.inner.lock().await;
    match sub.next().await {
        Some(Ok(event)) => Ok(Some(DartChangeEvent::from(event))),
        Some(Err(e)) => Err(e.into()),
        None => Ok(None),
    }
}

/// Close a subscription and release server-side resources.
pub async fn dart_subscription_close(subscription: &DartSubscription) -> anyhow::Result<()> {
    let mut sub = subscription.inner.lock().await;
    sub.close().await?;
    Ok(())
}

/// Get the server-assigned subscription ID.
#[frb(sync)]
pub fn dart_subscription_id(subscription: &DartSubscription) -> String {
    subscription.sub_id.clone()
}
