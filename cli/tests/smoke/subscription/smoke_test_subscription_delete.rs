// Smoke Test: Live query subscription receives DELETE change events
//
// Covers: user table subscription receiving INSERT and DELETE notifications
// Ensures the DELETE notification pipeline is fully working end-to-end
//
// Regression test: Previously DELETE notifications were generated by the backend
// but silently dropped by the UI because it only checked `rows` (which is null
// for DELETE; the data is in `old_values`).

use crate::common::*;

#[ntest::timeout(120000)]
#[test]
fn smoke_subscription_receives_delete_event() {
    if !require_server_running() {
        return;
    }

    let namespace = generate_unique_namespace("smoke_del");
    let table = generate_unique_table("sub_del");
    let full = format!("{}.{}", namespace, table);

    // 1) Create namespace + user table
    let ns_sql = format!("CREATE NAMESPACE IF NOT EXISTS {}", namespace);
    execute_sql_as_root_via_client(&ns_sql).expect("create namespace should succeed");

    let create_sql = format!(
        r#"CREATE TABLE {} (
            id BIGINT AUTO_INCREMENT PRIMARY KEY,
            content VARCHAR NOT NULL
        ) WITH (TYPE='USER')"#,
        full
    );
    execute_sql_as_root_via_client(&create_sql).expect("create table should succeed");

    // 2) Insert a row that we will later delete
    let ins = format!("INSERT INTO {} (content) VALUES ('to_be_deleted')", full);
    execute_sql_as_root_via_client(&ins).expect("insert should succeed");

    // 3) Start subscription
    let query = format!("SELECT * FROM {}", full);
    let mut listener = SubscriptionListener::start(&query).expect("subscription should start");

    // 3a) Drain initial snapshot data
    let snapshot_deadline = std::time::Instant::now() + std::time::Duration::from_secs(6);
    while std::time::Instant::now() < snapshot_deadline {
        match listener.try_read_line(std::time::Duration::from_millis(100)) {
            Ok(Some(line)) => {
                if !line.trim().is_empty() {
                    println!("[subscription][snapshot] {}", line);
                }
            },
            Ok(None) => break,
            Err(_) => continue,
        }
    }

    // 4) Insert another row to verify INSERT notification works
    let ins2 = format!("INSERT INTO {} (content) VALUES ('live_insert')", full);
    execute_sql_as_root_via_client(&ins2).expect("live insert should succeed");

    let mut insert_received = false;
    let insert_deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);
    while std::time::Instant::now() < insert_deadline {
        match listener.try_read_line(std::time::Duration::from_millis(100)) {
            Ok(Some(line)) => {
                println!("[subscription][insert] {}", line);
                if line.contains("live_insert") || line.contains("Insert") {
                    insert_received = true;
                    break;
                }
            },
            Ok(None) => break,
            Err(_) => continue,
        }
    }
    assert!(
        insert_received,
        "expected INSERT change event for 'live_insert' within 5s"
    );

    // 5) DELETE the first row and verify DELETE notification arrives
    let del = format!("DELETE FROM {} WHERE content = 'to_be_deleted'", full);
    println!("[DEBUG] Executing DELETE: {}", del);
    execute_sql_as_root_via_client(&del).expect("delete should succeed");
    println!("[DEBUG] DELETE completed, waiting for delete change event...");

    let mut delete_lines: Vec<String> = Vec::new();
    let delete_deadline = std::time::Instant::now() + std::time::Duration::from_secs(5);
    while std::time::Instant::now() < delete_deadline {
        match listener.try_read_line(std::time::Duration::from_millis(100)) {
            Ok(Some(line)) => {
                println!("[subscription][delete] {}", line);
                delete_lines.push(line.clone());
                // The ChangeEvent::Delete debug format contains "Delete {"
                if line.contains("Delete") || line.contains("delete") {
                    println!("[DEBUG] Found DELETE change event!");
                    break;
                }
            },
            Ok(None) => break,
            Err(_) => continue,
        }
    }

    let delete_joined = delete_lines.join("\n");
    assert!(
        delete_joined.contains("Delete") || delete_joined.contains("delete"),
        "expected DELETE change event within 5s; got: {}",
        delete_joined
    );
    // Also verify the deleted row data is included
    assert!(
        delete_joined.contains("to_be_deleted"),
        "DELETE event should include the deleted row data ('to_be_deleted'); got: {}",
        delete_joined
    );

    println!("  âœ… DELETE live query notification verified");

    // Cleanup
    listener.stop().ok();
    let _ = execute_sql_as_root_via_client(&format!("DROP NAMESPACE {} CASCADE", namespace));
}
